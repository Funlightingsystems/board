<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; Board 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/classic.css" />
    
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../../../../../_static/doctools.js"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../../../../../../../index.html">Board 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">&lt;no title&gt;</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>== CMD_DESCRIPTION_ACL ==
设置对象权限。</p>
<p>== CMD_USAGE_ACL ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^acl (–^user=&lt;用户名&gt; | –^group=&lt;组名称&gt;)</dt><dd><p>(-^allowed|-^denied|-^overrideallowed|-^overridedenied=+|-&lt;权限&gt;[,…])[,…]
&lt;对象规格&gt;</p>
</dd>
</dl>
<p>–^user             用户名。
–^group            组名称。
-^allowed           启用指定的一项或多项权限。使用</p>
<blockquote>
<div><p>逗号对各个权限进行分隔。（使用 ‘cm ^showpermissions’
可显示所有可用权限。）</p>
</div></blockquote>
<dl class="simple">
<dt>-^denied            拒绝指定的一项或多项权限。使用</dt><dd><p>逗号对各个权限进行分隔。（使用 ‘cm ^showpermissions’
可显示所有可用权限。）</p>
</dd>
<dt>-^overrideallowed   覆盖允许的一项或多项权限。使用</dt><dd><p>逗号对各个权限进行分隔。（使用 ‘cm ^showpermissions’
可显示所有可用权限。）</p>
</dd>
<dt>-^overridedenied    覆盖拒绝的一项或多项权限。使用</dt><dd><p>逗号对各个权限进行分隔。（使用 ‘cm ^showpermissions’
可显示所有可用权限。）</p>
</dd>
<dt>对象规格         要设置权限的对象。</dt><dd><p>此命令的有效对象为：
存储库服务器、存储库、分支、变更集、标签、项
和属性。
（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>安全路径的特殊用法：</dt><dd><dl class="simple">
<dt>cm ^acl [(–^user=&lt;用户名&gt; | –^group=&lt;组名称&gt;)</dt><dd><p>(-^allowed|-^denied|-^overrideallowed|-^overridedenied=+|-&lt;权限&gt;[,…])[,…]]
[–^delete] [–^branches=[+ | -]&lt;分支&gt;[,…]]
&lt;规格&gt;</p>
</dd>
<dt>–^delete           删除安全路径。</dt><dd><p>请参阅“备注”以了解更多信息。</p>
</dd>
<dt>–^branches         将安全路径权限设置为一个分支组。</dt><dd><p>使用逗号对各个分支进行分隔。
（可选）每个分支前面可添加 + 或 -
符号，从而指定在编辑时必须在列表中添加
还是删除某个分支。
请参阅“备注”以了解更多信息。</p>
</dd>
</dl>
<p>规格               要设置权限的安全路径。</p>
</dd>
</dl>
<p>== CMD_HELP_ACL ==
为了配置权限，需要了解 Plastic SCM 安全机制的工作原理。
请查看《安全指南》以了解权限的工作原理：
<a class="reference external" href="https://www.plasticscm.com/download/help/securityguide">https://www.plasticscm.com/download/help/securityguide</a></p>
<p>备注：</p>
<blockquote>
<div><p>此命令设置用户或组对于指定对象、存储库、分支、标签
和/或服务器路径的权限。</p>
<dl>
<dt>对象规格：</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可了解如何指定对象。）
‘^acl’ 命令使用一种特殊类型的规格：安全路径。</p>
<ul>
<li><dl>
<dt>安全路径规格：</dt><dd><p>^path:server_path[#tag]
示例：^path:/src/foo.c</p>
<blockquote>
<div><p>^path:/doc/pdf
^path:/doc/pdf#documents</p>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>权限操作：</dt><dd><p>使用 -^allowed 和 -^denied 指定要设置的权限。
使用 -^overrideallowed 和 -^overridedenied 参数指定
要覆盖的权限。</p>
<p>每个操作都需要一个权限列表（以逗号分隔）。</p>
</dd>
<dt>权限名称：</dt><dd><p>每个权限名称前面都带有 + 或 - 符号。
+ 符号表示设置权限，而 - 符号表示清除权限。
要查看对象的权限，请使用 ‘cm ^showacl’ 命令。</p>
</dd>
<dt>覆盖的权限：</dt><dd><p>使用 -^overrideallowed 和 -^overridedenied
来覆盖权限可以绕过继承。
这对于绕过在存储库或服务器级别设置的权限
很有帮助。
示例：</p>
<blockquote>
<div><p>cm ^acl –^user=vio -^allowed=+^ci -^overrideallowed=+^ci ^br:<a class="reference external" href="mailto:qa&#37;&#52;&#48;test">qa<span>&#64;</span>test</a>
（允许用户 ‘vio’ 在存储库 ‘test’ 上的分支 ‘qa’ 上签入，
即使该用户的权限在存储库级别被拒绝也是如此。）</p>
</div></blockquote>
</dd>
<dt>服务器路径权限（又称“安全路径”）：</dt><dd><ul class="simple">
<li><p>允许为给定的服务器路径指定权限。</p></li>
<li><p>在签入操作期间会检查这些权限。</p></li>
<li><p>也可以在更新操作期间检查这些权限，
并可以将这些权限用作一种防止某些目录和文件
下载到工作区的方法。</p></li>
<li><p>对于要签入的每一项，服务器都会尝试将项路径
与安全路径匹配。如果匹配，则签入操作
将检查是否可以签入该项。</p></li>
</ul>
<p>可为安全路径定义的权限
如下：</p>
<blockquote>
<div><p>‘^ci’、’^change’、’^add’、’^move’、’^rm’、’^read’</p>
</div></blockquote>
<p>对于任何涉及的项，如果权限检查不成功，
则检入操作将回滚。</p>
<p>要将安全路径权限设置为一个分支组，请使用
–^branches 选项。
示例：</p>
<blockquote>
<div><p>cm ^acl –^user=jo -^denied=+^ci ^path:/src#rule0 –^branches=main,main/rel0</p>
</div></blockquote>
<p>要编辑与安全路径关联的 ACL，该标记很有用。
示例：</p>
<blockquote>
<div><p>cm ^acl –^user=jo -^denied=+^rm ^path:/src#rule0
（如果没有标记，则需要再次指定
分支列表。）</p>
</div></blockquote>
<p>安全路径的分支列表是可以编辑的。
示例：</p>
<blockquote>
<div><p>cm ^acl ^path:/src#rule0 –^branches=-main,+main/rel1
（从列表中删除 ‘main’ 并添加 ‘main/rel1’。）</p>
</div></blockquote>
<p>要删除安全路径，请使用 –^delete 参数。
示例：</p>
<blockquote>
<div><p>cm ^acl –^user=jo –^delete ^path:/src#rule0</p>
</div></blockquote>
</dd>
<dt>继承：</dt><dd><p>继承是 Plastic SCM 3.0 时期的一种选项。
这是高级选项，但几乎已弃用。
该选项允许对象从任何其他对象继承权限，
从而覆盖默认的继承关系。</p>
<p>使用选项 -^cut 切断继承链。
使用选项 -^cutncpy 切断并复制当前继承的
权限。（这个选项受到 Windows 文件系统权限的启发，
在 Windows 文件系统中可以切断继承关系但保留实际权限。）</p>
<p>-^inherit 选项允许用户从对象规格继承。
示例：’-^inherit=对象规格’</p>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^acl –^user=danipen -^denied=+^ci ^rep:core
（拒绝用户 ‘danipen’ 在存储库 ‘core’ 上签入。）</p>
<p>cm ^acl –^group=developers -^allowed=+^view,-^read -^denied=+^chgperm ^br:main
（该命令向 ‘main’ 分支中的 ‘developers’ 组
授予查看权限、清除读取权限并拒绝 chgperm 权限。）</p>
</div></blockquote>
<p>安全路径示例：</p>
<blockquote>
<div><p>cm ^acl –^group=devs -^denied=+^ci ^path:/server#rel –^branches=main,main/2.0
（对于在分支 ‘main’ 和 ‘main/2.0’ 中与 ‘/server’ 匹配的任何路径，
该命令拒绝向 ‘devs’ 组授予签入权限。创建标记 ‘#rel’
是为了稍后能够进行引用。）</p>
<p>cm ^acl ^path:/server#rel –^branches=-/main,+/main/Rel2.1
（更新具有 ‘rel’ 标记的安全路径 ‘/server’，
删除 ‘main’ 分支，并将分支 ‘main/Rel2.1’ 添加到
安全路径所应用到的分支组。就前面的示例而言，
现在分支列表将包含 ‘main/Rel2.1’ 和 ‘main/2.0’。）</p>
<p>cm ^acl –^user=vsanchezm -^allowed=-^read -^overrideallowed=+^read ^path:/doc
（删除授权给 ‘vsanchezm’ 的 ‘^read’ 权限，在 ‘/doc’ 路径中对其进行覆盖。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ACTIVATEUSER ==
激活许可的用户。</p>
<p>== CMD_USAGE_ACTIVATEUSER ==
用法：</p>
<blockquote>
<div><p>cm ^activateuser | ^au &lt;用户名&gt;[ …][–^server=&lt;存储库服务器规格&gt;]</p>
<dl class="simple">
<dt>用户名   要激活的一个或多个用户名。使用双引号 (” “)</dt><dd><p>指定包含空格的用户名。使用空格
对各个用户名进行分隔。</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>选项：</dt><dd><dl class="simple">
<dt>–^server=&lt;存储库服务器规格&gt;  激活指定服务器中的用户。</dt><dd><p>如果未指定服务器，则在 client.conf 文件
中的默认服务器中执行命令。
（使用 ‘cm ^help ^objectspec’ 可进一步了解
存储库服务器规格。）</p>
</dd>
</dl>
</dd>
</dl>
<p>== CMD_HELP_ACTIVATEUSER ==
备注：</p>
<blockquote>
<div><p>要激活用户，必须已事先禁用该用户。
默认情况下，用户第一次在 Plastic SCM 中执行写操作时
会被激活。仅当未超过最大用户数时，
才会自动激活用户。</p>
<p>有关停用 Plastic SCM 用户的更多信息，
请参阅 ‘cm ^help ^deactivateuser’ 命令。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^activateuser john
cm ^activateuser david “mary collins”
cm ^au peter –^server=localhost:8087</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ADD ==
向版本控制中添加项。</p>
<p>== CMD_USAGE_ADD ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^add [-^R | -^r | –^recursive] [–^silent] [–^ignorefailed]</dt><dd><p>[–^skipcontentcheck] [–^coparent] [–^filetypes=&lt;文件&gt;] [–^noinfo]
[–^format=&lt;格式字符串&gt;] [–^errorformat=&lt;格式字符串&gt;]
&lt;项路径&gt;[ …]</p>
</dd>
<dt>项路径   要移动的一个或多个项。使用双引号 (” “) 指定</dt><dd><p>包含空格的路径。使用空格对各个项进行分隔。
使用 * 添加当前目录的所有内容。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>-^R -^r –^recursive   以递归方式添加项。
–^silent            不显示任何输出。
–^ignorefailed      如果无法添加某一项，则添加操作将在没有</p>
<blockquote>
<div><p>这一项的情况下继续进行。注意：如果无法添加
某个目录，则不会添加目录中的内容。</p>
</div></blockquote>
<dl class="simple">
<dt>–^skipcontentcheck  如果不足以根据扩展名将文件设置为</dt><dd><p>文本或二进制，则会将该文件设置为二进制，
而不是检查内容来检测类型。这样做
是为了在进行大量签入时提高性能。</p>
</dd>
</dl>
<p>–^coparent          对要添加的项的父级进行签出。
–^filetypes         要使用的 filetypes 文件。请查看以下链接以了解</p>
<blockquote>
<div><p>更多信息：
<a class="reference external" href="http://blog.plasticscm.com/2008/03/custom-file-types.html">http://blog.plasticscm.com/2008/03/custom-file-types.html</a></p>
</div></blockquote>
<p>–^noinfo            不打印进度信息。
–^format            检索特定格式的输出消息。请查看</p>
<blockquote>
<div><p>示例以了解更多信息。</p>
</div></blockquote>
<dl class="simple">
<dt>–^errorformat       检索特定格式的错误消息</dt><dd><p>（如果有）。请查看示例以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_ADD ==
备注：</p>
<blockquote>
<div><p>添加项的要求：
- 要添加的项的父目录必须已事先添加。</p>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^add’ 命令可从 stdin 读取路径。为此，请传递一个破折号
“-”。
示例：cm ^add -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要添加的文件。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id1"><span class="problematic" id="id2">*</span></a>.c | cm ^add -
（在 Windows 中，添加工作区中的所有 .c 文件。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^add file1.txt file2.txt
（添加 ‘file1.txt’ 和 ‘file2.txt’ 项。）</p>
<p>cm ^add c:workspacefile.txt
（添加路径 ‘c:workspace’ 中的 ‘file.txt’ 项。）</p>
<p>cm ^add -^R c:workspacesrc
（以递归方式添加 ‘src’。）</p>
<p>cm ^add -^R *
（以递归方式添加当前目录的所有内容。）</p>
<p>cm ^add -^R * –^filetypes=filetypes.conf
（以递归方式添加当前目录的所有内容，使用
‘filetypes.conf’ 根据文件的扩展名为文件分配类型，
而不是检查文件内容。）</p>
<p>cm ^add –^coparent c:workspacedirfile.txt
（将 ‘file.txt’ 添加到源代码管理中，并执行 ‘dir’ 的签出。）</p>
<p>cm ^add -^R * –^format=”ADD {0}” –^errorformat=”ERR {0}”
（以递归方式添加当前目录的所有内容，
对于成功添加的文件，打印 ‘^ADD &lt;项&gt;’，而对于无法添加的项，
则打印 ‘^ERR &lt;项&gt;’。）</p>
</div></blockquote>
<p>== CMD_USAGE_ADDIGNOREPATTERN ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^addignorepattern &lt;模式&gt;[ …]</dt><dd><p>[–^workspace=&lt;工作区路径&gt; | –^allworkspaces] [–^remove]</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_DESCRIPTION_ADMIN ==
在服务器上执行管理命令。</p>
<p>== CMD_USAGE_ADMIN ==
用法：</p>
<blockquote>
<div><p>cm ^admin &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>可用命令：</p>
<blockquote>
<div><p>^readonly</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^admin &lt;命令&gt; –^usage
cm ^admin &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_ADMIN ==
备注：</p>
<blockquote>
<div><p>只有服务器管理员才能执行管理命令。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^admin ^readonly ^enter
cm ^admin ^readonly ^status</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ADMIN_READONLY ==
启用/禁用服务器只读模式。</p>
<p>== CMD_USAGE_ADMIN_READONLY ==
用法：</p>
<blockquote>
<div><p>cm ^admin ^readonly (^enter | ^leave | ^status) [&lt;服务器&gt;]</p>
</div></blockquote>
<p>操作：</p>
<blockquote>
<div><p>^enter   服务器进入只读模式。写操作将被拒绝。
^leave   服务器退出只读模式。
^status  显示服务器只读模式状态。</p>
</div></blockquote>
<dl class="simple">
<dt>选项：</dt><dd><dl class="simple">
<dt>服务器  在指定服务器（服务器:端口）中执行命令。（使用</dt><dd><p>‘cm ^help ^objectspec’ 可进一步了解服务器规格。）
如果未指定服务器，则该命令适用于当前工作区的
服务器。
如果当前路径不在工作区中，则该命令适用于
client.conf 配置文件中定义的默认服务器。</p>
</dd>
</dl>
</dd>
</dl>
<p>== CMD_HELP_ADMIN_READONLY ==
备注：</p>
<blockquote>
<div><p>只有服务器管理员才能进入服务器只读模式。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^admin ^readonly ^enter diana:8086
cm ^admin ^readonly ^leave</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ANNOTATE ==
显示文件每一行上次修改所在的变更集及其作者。</p>
<p>== CMD_USAGE_ANNOTATE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^annotate | ^blame &lt;规格&gt;[ …]</dt><dd><p>[–^format=&lt;格式字符串&gt;]
[–^ignore=(^eol | ^whitespaces | ^”eol&amp;whitespaces” | ^none)]
[–^dateformat=&lt;日期格式字符串&gt;]
[–^encoding=&lt;名称&gt;]
[–^stats]
[–^repository=&lt;存储库规格&gt;]</p>
</dd>
<dt>规格        要批注的文件的规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）
使用双引号 (” “) 指定包含空格的路径。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format        检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
<dt>–^ignore        设置指定的比较方法。</dt><dd><p>请参阅“备注”以了解更多信息。</p>
</dd>
</dl>
<p>–^dateformat    设置输出格式以打印日期。
–^encoding      指定输出编码，如：utf-8。</p>
<blockquote>
<div><p>请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</div></blockquote>
<p>–^stats         显示统计信息。
–^repository    指定用于计算批注的存储库</p>
<blockquote>
<div><p>规格。默认情况下，此命令使用的
存储库存储了工作区中已加载的
修订存储库。（使用 ‘cm ^help ^objectspec’ 可进一步
了解存储库规格。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_ANNOTATE ==
备注：</p>
<blockquote>
<div><p>无法批注二进制文件。</p>
<p class="attribution">—^ignore 选项：
^none                检测行尾和空格差异。
^eol                 忽略行尾差异。
^whitespaces         忽略空格差异。
^”eol&amp;whitespaces”   忽略行尾和空格差异。</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>–^format 选项：</dt><dd><p>此命令的输出参数如下：
{^owner}        上次更改行的用户。
{^rev}          行的源修订规格。
{^content}      行内容。
{^date}         签入行的日期。
{^comment}      行的源修订的注释。
{^changeset}    行的源修订的变更集。
{^line}         文件中的行号。
{^id}           项 ID。
{^parentid}     项的父级 ID。
{^rep}          项的存储库。
{^branch}       行的源修订的分支。
{^ismergerev}   是否在合并中创建了行的修订。</p>
</dd>
</dl>
<p class="attribution">—^dateformat:
指定打印日期的输出格式。
请参阅以下网址中指明的受支持格式：
<a class="reference external" href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings">https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings</a></p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>–^repository:</dt><dd><p>从远程存储库检索数据。适合用于分布式
场景。</p>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^blame c:workspacesrc –^ignore=^”eol&amp;whitespaces” –^encoding=utf-8
cm ^annotate c:workspacefile.txt –^ignore=^eol</p>
<p>cm ^annotate c:workspacefile.txt –^format=”{^owner} {^date, 10} {^content}”
（依次写入 owner 字段、一个空格、date 字段（右对齐）、
一个空格以及 content 字段。）</p>
<dl class="simple">
<dt>cm ^blame c:workspacefile.txt –^format=”{^owner, -7} {^comment} {^date}” </dt><dd><p>–^dateformat=yyyyMMdd</p>
</dd>
</dl>
<p>（依次写入 owner 字段（占用 7 个空格，左对齐）、
一个空格、comment 字段、另一个空格以及结尾的
格式化日期（例如，20170329）。）</p>
<p>cm ^annotate c:workspacefile.txt –^repository=centralRep&#64;myserver:8084</p>
<p>cm ^blame ^serverpath:/src/client/checkin/Checkin.cs#^cs:73666
（使用服务器路径对变更集 73666 中开始的文件进行批注。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_APPLY_LOCAL ==
检查是否有本地更改（本地移动、本地删除和本地更改）
并应用这些更改，以便 Plastic SCM 开始跟踪这些更改。</p>
<p>== CMD_USAGE_APPLY_LOCAL ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^applylocal | ^al [–^dependencies] [&lt;项路径&gt;[ …]]</dt><dd><dl class="simple">
<dt>[–^machinereadable [–^startlineseparator=&lt;分隔符&gt;]</dt><dd><p>[–^endlineseparator=&lt;分隔符&gt;] [–^fieldseparator=&lt;分隔符&gt;]]</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^dependencies        将本地更改依赖项添加到要应用</dt><dd><p>的项。</p>
</dd>
<dt>项路径             要应用的项。使用空格对各个路径进行</dt><dd><p>分隔。使用双引号 (” “) 指定包含空格
的路径。</p>
</dd>
</dl>
<p>–^machinereadable     以易于解析的格式输出结果。
–^startlineseparator  与 ‘–^machinereadable’ 标志结合使用，指定</p>
<blockquote>
<div><p>行应如何开头。</p>
</div></blockquote>
<dl class="simple">
<dt>–^endlineseparator    与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>行应如何结尾。</p>
</dd>
<dt>–^fieldseparator      与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>应如何分隔字段。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_APPLY_LOCAL ==
备注：</p>
<blockquote>
<div><p>如果未指定 –^dependencies 和 &lt;项路径&gt;，则该操作涉及
工作区中的所有本地更改。
始终以递归方式从给定路径应用。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^applylocal foo.c bar.c</p>
<p>cm ^applylocal .
（应用当前目录中的所有本地更改。）</p>
<p>cm ^applylocal
（应用工作区中的所有本地更改。）</p>
<p>cm ^applylocal –^machinereadable
（应用工作区中的所有本地更改，并以易于解析的
简化格式打印结果。）</p>
<dl class="simple">
<dt>cm ^applylocal –^machinereadable –^startlineseparator=”&gt;” </dt><dd><p>–^endlineseparator=”&lt;” –^fieldseparator=”,”</p>
</dd>
</dl>
<p>（应用工作区中的所有本地更改，并以易于解析的
简化格式打印结果，以指定的字符串作为行的开头和结尾以及
对各字段进行分隔。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ARCHIVE ==
将数据存档在外部存储中。</p>
<p>== CMD_USAGE_ARCHIVE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^archive | ^arch &lt;修订规格&gt;[ …][-^c | –^comment=&lt;注释字符串&gt;]</dt><dd><p>[–^file=&lt;基项文件&gt;]</p>
</dd>
</dl>
<p>（从存储库中提取数据并将这些数据存储在外部存储中。）</p>
<p>cm ^archive | ^arch &lt;修订规格&gt;[ …]–^restore
（将以前存档的修订还原到存储库中。）</p>
<dl class="simple">
<dt>修订规格             一个或多个修订规格。可通过 “-” 修饰符从 STDIN</dt><dd><p>进行读取。（使用 ‘cm ^help ^objectspec’ 可
进一步了解修订规格。）</p>
</dd>
<dt>–^restore           从生成的存档文件中还原以前存档的</dt><dd><p>数据。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>-^c | –^comment      在要创建的存档存储文件中设置注释。
–^file              新存档数据文件的名称前缀和</p>
<blockquote>
<div><p>（可选）路径。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_ARCHIVE ==
备注：</p>
<blockquote>
<div><p>此命令从存储库数据库中提取数据并将这些数据存储在
外部存储中，从而节省数据库空间。
此命令还可以将以前存档的修订还原到
存储库数据库中 (–^restore)。</p>
<p>使用 ‘cm ^help ^objectspec’ 可了解如何指定修订规格。</p>
<p>运行此命令的用户必须是 Plastic SCM 服务器管理员
（存储库服务器所有者）才能完成操作。</p>
<p>来自指定修订中的每个数据段都将存储在
不同的文件中，且文件名以 –^file
参数定义的值开头。此参数可以包含完整路径值，其中包括
未来存档文件的前缀，也可以仅包含此前缀值。</p>
<p>存档后可以通过两种方式访问来自指定修订中的
数据：</p>
<ul class="simple">
<li><p>从客户端：客户端将检测数据是否已存档，
并提示用户输入文件的位置。
用户可以通过创建一个名为 externaldata.conf 的
文件（在标准配置文件位置，使用适用于
client.conf 文件的相同规则）来配置外部数据位置，
其中包含已存档数据所在的路径。</p></li>
<li><p>从服务器：通过这种方式，用户将不必知道数据
是否已存档，因为请求将以透明的方式由服务器
解析。为此，管理员将在服务器目录中创建一个
名为 externaldata.conf 的文件，并在该文件中填充
已存档的卷所在的路径。</p></li>
</ul>
<p>要取消存档（还原）一个修订（或一组修订），必须能够
从客户端访问已存档的文件。因此，无法取消存档
服务器正在解析的数据（方法 2），原因是客户端
无法将数据识别为已存档。如果使用了方法 2，
为了成功取消存档，管理员必须首先编辑
externaldata.conf 服务器文件，以便删除对必须取消存档的
已存档文件的访问权限。</p>
<p>设置 PLASTICEDITOR 环境变量可指定用于键入注释的
编辑器。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^archive bigfile.zip#^br:/main
（在分支 ‘main’ 中存档 ‘bigfile.zip’ 的最后一个修订。）</p>
<p>cm ^archive ^rev:myfile.pdf#^cs:2 -^c=”大型 PDF 文件” –^file=c:arch_filesarch
（将变更集 2 中 myfile.pdf 的修订存档在 ‘c:archived_files’
文件夹中。存档的文件名将以 ‘arch’ 开头（例如 arch_11_56）。）</p>
<dl class="simple">
<dt>cm ^find “^revs ^where ^size &gt; 26214400” –^format=”{^item}#{^branch}” </dt><dd><p>–^nototal | cm ^archive –^comment=”volume00” –^file=”volume00” -</p>
</dd>
</dl>
<p>（将所有大于 25Mb 的文件存档在名称 ‘volume00’ 开头的
文件中。）</p>
<dl class="simple">
<dt>cm ^find “^revs ^where ^size &gt; 26214400 ^and ^archived=’true’” </dt><dd><p>–^format=”{^item}#{^branch}” –^nototal | cm ^archive –^restore</p>
</dd>
</dl>
<p>（还原所有大于 25Mb 的存档文件。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ATTRIBUTE ==
允许用户管理属性。</p>
<p>== CMD_USAGE_ATTRIBUTE ==
用法：</p>
<blockquote>
<div><p>cm ^attribute | ^att &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^create | ^mk
^delete | ^rm
^set
^unset
^rename
^edit</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^attribute &lt;命令&gt; –^usage
cm ^attribute &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_ATTRIBUTE ==
示例：</p>
<blockquote>
<div><p>cm ^attribute ^create 状态
cm ^attribute ^set ^att:status ^br:/main/SCM105 未完成
cm ^attribute ^unset ^att:status ^br:/main/SCM105
cm ^attribute ^delete ^att:status
cm ^attribute ^rename ^att:status “构建状态”
cm ^attribute ^edit ^att:status “CI 管道中任务的状态”</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHANGELIST ==
对更改列表中的待定更改进行分组。</p>
<p>== CMD_USAGE_CHANGELIST ==
用法：</p>
<blockquote>
<div><ol class="loweralpha">
<li><p>管理更改列表对象：</p>
<p>cm ^changelist | ^clist [–^symlink]
（显示所有更改列表。）</p>
<dl class="simple">
<dt>cm ^changelist | ^clist ^add &lt;更改列表名称&gt;</dt><dd><p>[&lt;更改列表描述&gt;] [–^persistent | –^notpersistent] [–^symlink]</p>
</dd>
</dl>
<p>（创建更改列表。）</p>
<p>cm ^changelist | ^clist ^rm &lt;更改列表名称&gt; [–^symlink]
（删除所选的更改列表。如果此更改列表包含待定更改，
这些更改将移至 ^default 更改列表。）</p>
<dl class="simple">
<dt>cm ^changelist | ^clist ^edit &lt;更改列表名称&gt; [&lt;操作名称&gt; &lt;操作值&gt;]</dt><dd><p>[–^persistent | –^notpersistent] [–^symlink]</p>
</dd>
</dl>
<p>（编辑所选的更改列表。）</p>
</li>
<li><p>管理给定更改列表的内容：</p>
<dl class="simple">
<dt>cm ^changelist | ^clist &lt;更改列表名称&gt; (^add | ^rm) &lt;路径名称&gt;[ …]</dt><dd><p>[–^symlink]</p>
</dd>
</dl>
<p>（通过添加 (‘^add’) 或删除 (‘^rm’) 与给定路径名称匹配的更改
来添加所选的更改列表。使用空格
对各个路径名称进行分隔。使用双引号 (” “) 指定包含空格的
路径。路径的状态必须为 ‘^Added’ 或 ‘^Checked-out’。）</p>
</li>
</ol>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>更改列表名称          更改列表的名称。
更改列表描述          更改列表的描述。
操作名称         选择 ‘^rename’ 或 ‘^description’ 来编辑</p>
<blockquote>
<div><p>更改列表。</p>
</div></blockquote>
<dl class="simple">
<dt>操作值        在编辑更改列表时应用新名称或</dt><dd><p>新描述。</p>
</dd>
<dt>–^persistent        即使更改列表的内容已被签入或还原，</dt><dd><p>更改列表也会保留在工作区中。</p>
</dd>
<dt>–^notpersistent     （默认值）即使更改列表的内容已被签入</dt><dd><p>或还原，更改列表也不会保留在
工作区中。</p>
</dd>
<dt>–^symlink           将操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_CHANGELIST ==
备注：</p>
<blockquote>
<div><p>‘^changelist’ 命令会处理工作区待定更改列表以及更改列表中
包含的更改。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^changelist
（显示当前工作区更改列表。）</p>
<p>cm ^changelist ^add 配置更改 “dotConf 文件” –^persistent
（创建一个名为 ‘配置更改’ 和描述为 ‘dotConf
文件’ 的新更改列表，该更改列表在待定更改列表被签入
或还原后将在当前工作区中持久保留。）</p>
<p>cm ^changelist ^edit 配置更改 ^rename 配置文件 –^notpersistent
（编辑名为 ‘配置更改’ 的更改列表，并将该更改列表重命名为
‘配置文件’。此外还会将更改列表变为“非持久性”。）</p>
<p>cm ^changelist ^edit 配置更改 –^notpersistent
（编辑名为 ‘配置更改’ 的更改列表，并将该更改列表变为“非持久性”。）</p>
<p>cm ^changelist ^rm 配置文件
（从当前工作区中删除待定更改列表 ‘配置文件’。）</p>
<p>cm ^changelist 配置文件 ^add foo.conf
（将文件 ‘foo.conf’ 添加到 ‘配置文件’ 更改列表中。）</p>
<p>cm ^changelist 配置文件 ^rm foo.conf readme.txt
（从 ‘配置文件’ 更改列表中删除文件 ‘foo.conf’ 和 ‘readme.txt’，
并将这些文件移至系统默认更改列表。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHANGESET ==
对变更集执行高级操作。</p>
<p>== CMD_USAGE_CHANGESET ==
用法：</p>
<blockquote>
<div><p>cm ^changeset &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^move        | ^mv
^delete      | ^rm
^editcomment | ^edit</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^changeset &lt;命令&gt; –^usage
cm ^changeset &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_CHANGESET ==
示例：</p>
<blockquote>
<div><p>cm ^changeset ^move ^cs:<a class="reference external" href="mailto:15&#37;&#52;&#48;myrepo">15<span>&#64;</span>myrepo</a> ^br:<a class="reference external" href="mailto:/main/scm005&#37;&#52;&#48;myrepo">/main/scm005<span>&#64;</span>myrepo</a>
cm ^changeset ^delete ^cs:<a class="reference external" href="mailto:2b55f8aa-0b29-410f-b99c-60e573a309ca&#37;&#52;&#48;devData">2b55f8aa-0b29-410f-b99c-60e573a309ca<span>&#64;</span>devData</a></p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHANGESET_EDIT_COMMENT ==
修改变更集的注释。</p>
<p>== CMD_USAGE_CHANGESET_EDIT_COMMENT ==
用法：</p>
<blockquote>
<div><p>cm ^changeset ^editcomment | ^edit &lt;变更集规格&gt; &lt;新注释&gt;</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>变更集规格            要修改注释的目标变更集。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集
规格。）</p>
</dd>
<dt>新注释         要添加到目标变更集的</dt><dd><p>新注释。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_CHANGESET_EDIT_COMMENT ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>目标变更集规格必须有效。</p></li>
</ul>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^changeset ^editcomment ^cs:<a class="reference external" href="mailto:15&#37;&#52;&#48;myrepo">15<span>&#64;</span>myrepo</a> “我忘了添加签入详细信息”
cm ^changeset ^edit ^cs:cb11ecdb-1aa9-4f11-8698-dcab14e5885a </p>
<blockquote>
<div><p>“此注释文本将替代先前的注释文本。”</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHANGESET_MOVE ==
将变更集及其所有后代移动到另一个分支。</p>
<p>== CMD_USAGE_CHANGESET_MOVE ==
用法：</p>
<blockquote>
<div><p>cm ^changeset ^move | ^mv &lt;变更集规格&gt; &lt;分支规格&gt;</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>变更集规格            要移动到另一个分支的第一个变更集。All</dt><dd><p>同一分支中的所有后代变更集也将作为
该命令的目标。
（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集
规格。）</p>
</dd>
<dt>分支规格          存储目标变更集的目标</dt><dd><p>分支。目标分支需要为空或不存在；
如果目标分支不存在，该命令将创建
目标分支。
（使用 ‘cm ^help ^objectspec’ 可进一步了解分支
规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_CHANGESET_MOVE ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>目标变更集规格必须有效。</p></li>
<li><p>目标分支必须为空或不存在。</p></li>
<li><p>如果目标分支不存在，则会创建目标分支。</p></li>
<li><p>合并链接将保持不变，因为分支不会影响它们。</p></li>
</ul>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^changeset ^move ^cs:<a class="reference external" href="mailto:15&#37;&#52;&#48;myrepo">15<span>&#64;</span>myrepo</a> ^br:<a class="reference external" href="mailto:/main/scm005&#37;&#52;&#48;myrepo">/main/scm005<span>&#64;</span>myrepo</a>
cm ^changeset ^move ^cs:cb11ecdb-1aa9-4f11-8698-dcab14e5885a ^br:/hotfix/TL-352</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHANGESET_DELETE ==
从存储库中删除变更集。</p>
<p>== CMD_USAGE_CHANGESET_DELETE ==
用法：</p>
<blockquote>
<div><p>cm ^changeset ^delete | ^rm &lt;变更集规格&gt;</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl>
<dt>变更集规格           要删除的目标变更集。必须满足</dt><dd><p>某些特定条件。请参阅“备注”以了解更多信息。
（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集</p>
<blockquote>
<div><p>规格。）</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_CHANGESET_DELETE ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>目标变更集必须是其分支中的最后一个变更集。</p></li>
<li><p>目标变更集不能是任何其他变更集的父级。</p></li>
<li><p>目标变更集既不能作为合并链接的源，也不能
在间隔合并中作为源。</p></li>
<li><p>不得将任何标签应用于目标变更集。</p></li>
<li><p>目标变更集不能是根变更集 (‘^cs:0’)</p></li>
</ul>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^changeset ^rm ^cs:4525&#64;myrepo&#64;myserver
cm ^changeset ^delete ^cs:cb11ecdb-1aa9-4f11-8698-dcab14e5885a</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHANGEUSERPASSWORD ==
更改用户密码 (UP)。</p>
<p>== CMD_USAGE_CHANGEUSERPASSWORD ==
用法：</p>
<blockquote>
<div><p>cm ^changepassword | ^passwd</p>
</div></blockquote>
<p>== CMD_HELP_CHANGEUSERPASSWORD ==
备注：</p>
<blockquote>
<div><p>仅当安全性配置为 UP（用户/密码）时，
此命令才可用。请参阅《管理指南》以了解更多信息。
需要新旧密码。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^passwd</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHECKCONNECTION ==
检查与服务器的连接。</p>
<p>== CMD_USAGE_CHECKCONNECTION ==
用法：</p>
<blockquote>
<div><p>cm ^checkconnection | ^cc</p>
</div></blockquote>
<p>== CMD_HELP_CHECKCONNECTION ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>此命令返回一条消息，指示是否存在与配置的
Plastic SCM 服务器之间的有效连接。</p></li>
<li><p>此命令检查配置的用户是否有效。此外
还会检查与服务器的版本兼容性。</p></li>
</ul>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHECKDB ==
检查存储库的完整性。</p>
<p>== CMD_USAGE_CHECKDB ==
用法：</p>
<blockquote>
<div><p>cm ^checkdatabase | ^chkdb [&lt;存储库服务器规格&gt; | &lt;存储库规格&gt;]</p>
</div></blockquote>
<p>使用 ‘cm ^help ^objectspec’ 可进一步了解存储库服务器和存储库规格。</p>
<p>== CMD_HELP_CHECKDB ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>如果未指定存储库服务器规格和存储库规格，
则将在 client.conf 文件内指定的服务器中执行检查。</p></li>
</ul>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^checkdatabase ^repserver:localhost:8084
cm ^chkdb ^rep:default&#64;localhost:8084</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHECKIN ==
将更改存储在存储库中。</p>
<p>== CMD_USAGE_CHECKIN ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^checkin | ^ci [&lt;项路径&gt;[ …]]</dt><dd><p>[-^c=&lt;注释字符串&gt; | -^commentsfile=&lt;注释文件&gt;]
[–^all|-^a] [–^applychanged] [–^private] [–^update] [–^symlink]
[–^noshowchangeset]
[–^machinereadable [–^startlineseparator=&lt;分隔符&gt;]</p>
<blockquote>
<div><p>[–^endlineseparator=&lt;分隔符&gt;] [–^fieldseparator=&lt;分隔符&gt;]]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>项路径             要签入的项。使用双引号 (” “)</dt><dd><p>指定包含空格的路径。使用空格
对各个项路径进行分隔。
使用 . 将签入应用到当前目录。</p>
</dd>
<dt>-^c                    将指定的注释应用于在签入操作中创建的</dt><dd><p>变更集。</p>
</dd>
<dt>-^commentsfile         将指定文件中的注释应用于在签入操作中</dt><dd><p>创建的变更集。</p>
</dd>
<dt>–^all | -^a            还包括在给定路径上进行了本地更改、移动</dt><dd><p>和删除的项。</p>
</dd>
<dt>–^applychanged        将签入操作应用于在工作区中</dt><dd><p>检测到的已更改项以及
签出的项。</p>
</dd>
<dt>–^private             还包括在工作区中检测到的</dt><dd><p>私有项。</p>
</dd>
<dt>–^update              自动处理更新合并</dt><dd><p>（如果最终发生此行为）。</p>
</dd>
<dt>–^symlink             将签入操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
</dl>
<p>–^noshowchangeset     不打印结果变更集。
–^machinereadable     以易于解析的格式输出结果。
–^startlineseparator  与 ‘–^machinereadable’ 标志结合使用，指定</p>
<blockquote>
<div><p>行应如何开头。</p>
</div></blockquote>
<dl class="simple">
<dt>–^endlineseparator    与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>行应如何结尾。</p>
</dd>
<dt>–^fieldseparator      与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>应如何分隔字段。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_CHECKIN ==
备注：</p>
<blockquote>
<div><ul>
<li><p>如果未指定 &lt;项路径&gt;，则签入操作涉及
工作区中的所有待定更改。</p></li>
<li><p>签入操作始终以递归方式从给定路径应用。</p></li>
<li><p>要签入项，必须满足以下条件：
- 项必须受源代码管理。
- 如果是私有项（不受源代码管理），则必须有 –^private</p>
<blockquote>
<div><p>标志才能签入该项。</p>
</div></blockquote>
<ul class="simple">
<li><p>必须签出项。</p></li>
<li><p>如果已更改但未签出项，则除非 &lt;项路径&gt; 是目录
或包含通配符 (‘*’)，否则不需要
–^applychanged 标志。</p></li>
</ul>
</li>
</ul>
<p>修订内容必须与以前的修订不同才能
签入。</p>
<p>设置 PLASTICEDITOR 环境变量可指定用于键入注释的
编辑器。</p>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^checkin’ 命令可从 stdin 读取路径。为此，请传递一个
破折号 “-”。
示例：cm ^checkin -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要签入的文件。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id3"><span class="problematic" id="id4">*</span></a>.c | cm ^checkin –^all -
（在 Windows 中，签入工作区中的所有 .c 文件。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^checkin file1.txt file2.txt
（签入已签出的文件 ‘file1.txt’ 和 ‘file2.txt’。）</p>
<p>cm ^checkin .-^commentsfile=mycomment.txt
（签入当前目录并在 ‘mycomment.txt’ 文件中
设置注释。）</p>
<p>cm ^checkin 链接 –^symlink
（签入 ‘链接’ 文件而不是目标；适用于 UNIX
环境。）</p>
<p>cm ^ci file1.txt -^c=”我的注释”
（签入 ‘file1.txt’ 并包含注释。）</p>
<p>cm ^status –^short –^compact –^changelist=pending_to_review | cm ^checkin -
（列出名为 ‘pending_to_review’ 的更改列表中的路径，并将此列表
重定向到 checkin 命令的输入。）</p>
<p>cm ^ci .–^machinereadable
（签入当前目录，并以易于解析的简化格式
打印结果。）</p>
<p>cm ^ci .–^machinereadable –^startlineseparator=”&gt;” –^endlineseparator=”&lt;” –^fieldseparator=”,”
（签入当前目录，并以易于解析的简化格式
打印结果，以指定的字符串作为行的开头和结尾以及
对各字段进行分隔。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHECKOUT ==
将文件标记为修改就绪。</p>
<p>== CMD_USAGE_CHECKOUT ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^checkout | ^co [&lt;项路径&gt;[ …]] [-^R | -^r | –^recursive]</dt><dd><p>[–^format=&lt;格式字符串&gt;]
[–^errorformat=&lt;格式字符串&gt;] [–^resultformat=&lt;格式字符串&gt;]
[–^silent] [–^symlink] [–^ignorefailed]
[–^machinereadable [–^startlineseparator=&lt;分隔符&gt;]</p>
<blockquote>
<div><p>[–^endlineseparator=&lt;分隔符&gt;] [–^fieldseparator=&lt;分隔符&gt;]]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>项路径             要签出的项。使用双引号 (” “)</dt><dd><p>指定包含空格的路径。使用空格
对各个项路径进行分隔。
使用 . 将签出应用到当前目录。</p>
</dd>
</dl>
<p>-^R                    以递归方式签出文件。
–^format              检索特定格式的输出进度</p>
<blockquote>
<div><p>消息。请查看示例以了解更多信息。</p>
</div></blockquote>
<dl class="simple">
<dt>–^errorformat         检索特定格式的错误消息</dt><dd><p>（如果有）。请查看示例以了解更多信息。</p>
</dd>
<dt>–^resultformat        检索特定格式的输出结果</dt><dd><p>消息。请查看示例以了解更多信息。</p>
</dd>
</dl>
<p>–^silent              不显示任何输出。
–^symlink             将签出操作应用于符号链接而不是</p>
<blockquote>
<div><p>目标。</p>
</div></blockquote>
<dl class="simple">
<dt>–^ignorefailed        如果无法锁定某项（无法执行独占签出），</dt><dd><p>则签出操作将在没有这一项的情况下
继续进行。</p>
</dd>
</dl>
<p>–^machinereadable     以易于解析的格式输出结果。
–^startlineseparator  与 ‘–^machinereadable’ 标志结合使用，指定</p>
<blockquote>
<div><p>行应如何开头。</p>
</div></blockquote>
<dl class="simple">
<dt>–^endlineseparator    与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>行应如何结尾。</p>
</dd>
<dt>–^fieldseparator      与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>应如何分隔字段。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_CHECKOUT ==
备注：</p>
<blockquote>
<div><p>要签出项，必须满足以下条件：
- 项必须受源代码管理。
- 必须签入项。</p>
<p>如果在服务器上配置了锁（存在 lock.conf），则每次
在某条路径上进行签出时，Plastic 都会检查是否符合规则，
如果符合，该路径将处于独占签出（锁定）状态，以便任何其他人
都无法同时进行签出。
可使用 ‘cm ^lock ^list’ 获取服务器中的所有锁。
请参阅《管理员指南》以了解更多信息：
<a class="reference external" href="https://www.plasticscm.com/download/help/adminguide">https://www.plasticscm.com/download/help/adminguide</a></p>
<p>格式字符串将占位符 ‘{0}’ 替换为要签出的
项的路径。请查看示例以了解具体用法。</p>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^checkout’ 命令可从 stdin 读取路径。为此，请传递一个
破折号 “-”。
示例：cm ^checkout -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要签出的文件。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id5"><span class="problematic" id="id6">*</span></a>.c | cm ^checkout -
（在 Windows 中，签出工作区中的所有 .c 文件。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^checkout file1.txt file2.txt
（签出 ‘file1.txt’ 和 ‘file2.txt’ 文件。）</p>
<p>cm ^co <a href="#id7"><span class="problematic" id="id8">*</span></a>.txt
（签出所有文本文件。）</p>
<p>cm ^checkout .
（签出当前目录。）</p>
<p>cm ^checkout -^R c:workspacesrc
（以递归方式签出 ‘src’ 文件夹。）</p>
<dl class="simple">
<dt>cm ^co file.txt –^format=”正在签出项 {0}”</dt><dd><p>–^errorformat=”签出项 {0} 时出错” /
–^resultformat=”项 {0} 已签出”</p>
</dd>
</dl>
<p>（签出 ‘file.txt’，并使用指定的格式字符串
显示操作的进度、结果和错误。）</p>
<p>cm ^checkout 链接 –^symlink
（签出 ‘链接’ 文件而不是签出到目标；适用于 UNIX
环境。）</p>
<p>cm ^checkout .-^R –^ignorefailed
（以递归方式签出当前文件夹，忽略无法签出的
文件。）</p>
<p>cm ^co .–^machinereadable –^startlineseparator=”&gt;”
（签出当前目录，并以易于解析的简化格式打印结果，
以指定的字符串作为行的开头。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHECKSELECTORSYNTAX ==
检查选择器的语法。</p>
<p>== CMD_USAGE_CHECKSELECTORSYNTAX ==
用法：</p>
<blockquote>
<div><p>cm ^checkselectorsyntax | ^css –^file=&lt;选择器文件&gt;
（检查选择器文件语法。）</p>
<p>^cat &lt;选择器文件&gt; | cm ^checkselectorsyntax | ^css -
（适用于 Unix。在标准输入中检查选择器文件。）</p>
<p>^type &lt;选择器文件&gt; | cm ^checkselectorsyntax | ^css -
（适用于 Windows。在标准输入中检查选择器文件。）</p>
<p class="attribution">—^file     要从中读取选择器的文件。</p>
</div></blockquote>
<p>== CMD_HELP_CHECKSELECTORSYNTAX ==
备注：</p>
<blockquote>
<div><p>此命令在文件或标准输入中读取选择器，并检查
选择器是否为有效语法。如果语法检查结果为失败，则会将原因
打印在标准输出中。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^checkselectorsyntax –^file=myselector.txt
（检查 ‘myselector.txt’ 文件的语法。）</p>
<p>^cat myselector.txt | cm ^checkselectorsyntax
（在标准输入中检查 ‘myselector.txt’ 的语法。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CHGREVTYPE ==
更改某个项的修订类型（二进制或文本）。</p>
<p>== CMD_USAGE_CHGREVTYPE ==
用法：</p>
<blockquote>
<div><p>cm ^changerevisiontype | ^chgrevtype | ^crt &lt;项路径&gt;[ …]–^type=(^bin | ^txt)</p>
<dl class="simple">
<dt>项路径           要更改修订类型的项。使用双引号 (” “)</dt><dd><p>指定包含空格的路径。使用空格
对各个项路径进行分隔。</p>
</dd>
</dl>
<p>–^type              目标修订类型。选择 ‘^bin’ 或 ‘^txt’。</p>
</div></blockquote>
<p>== CMD_HELP_CHGREVTYPE ==
备注：</p>
<blockquote>
<div><p>此命令只能应用于文件，而不能应用于目录。
指定的类型必须是系统支持的类型：’^bin’ 或 ‘^txt’（二进制
或文本）。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^changerevisiontype c:workspacefile.txt –^type=^txt
（将 ‘file.txt’ 修订类型更改为文本。）</p>
<p>cm ^chgrevtype comp.zip “image file.jpg” –^type=^bin
（将 ‘comp.zip’ 和 “image file.jpg” 修订类型更改为二进制。）</p>
<p>cm ^crt <em>.</em> –^type=^txt
（将所有文件的修订类型更改为文本。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_TRIGGER_EDIT ==
编辑触发器。</p>
<p>== CMD_USAGE_TRIGGER_EDIT ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^trigger | ^tr ^edit &lt;子类型_类型&gt; &lt;位置编号&gt;</dt><dd><p>[–^position=&lt;新位置&gt;]
[–^name=&lt;新名称&gt;] [–^script=&lt;脚本路径&gt;]
[–^filter=&lt;筛选器字符串&gt;] [–^server=&lt;存储库服务器规格&gt;]</p>
</dd>
<dt>子类型_类型        触发器执行和触发器操作。</dt><dd><p>键入 ‘cm ^showtriggertypes’ 可查看触发器类型
列表。</p>
</dd>
</dl>
<p>位置编号     要修改的触发器占用位置。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^position          指定触发器的新位置。</dt><dd><p>此位置不能正在由相同类型的另一个
触发器使用。</p>
</dd>
</dl>
<p>–^name              指定触发器的新名称。
–^script            指定触发器脚本的新执行路径。</p>
<blockquote>
<div><p>如果脚本以 “^webtrigger “ 开头，则认为
这是 Web 触发器。请参阅“备注”以了解
更多详细信息。</p>
</div></blockquote>
<p>–^filter            仅检查与指定筛选条件匹配的项。
–^server            修改指定服务器上的触发器。</p>
<blockquote>
<div><p>如果未指定服务器，则在客户端上配置的
服务器上执行命令。
（使用 ‘cm ^help ^objectspec’ 可进一步了解服务器
规格。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_TRIGGER_EDIT ==
备注：</p>
<blockquote>
<div><p>Web 触发器：创建 Web 触发器的方法是键入 “^webtrigger &lt;目标-URI&gt;”
作为触发器命令。在这种情况下，触发器将针对指定的 URI
执行 POST 查询，其中，请求主体包含带有触发器
环境变量的 JSON 字典，还有一个指向字符串数组的
固定 INPUT 键。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^trigger ^edit ^after-setselector 6 –^name=”Backup2 管理器” –^script=”/new/path/al/script”
cm ^tr ^edit ^before-mklabel 7 –^position=4 –^server=myserver:8084
cm ^trigger ^edit ^after-add 2 –^script=”^webtrigger <a class="reference external" href="http://myserver.org/api">http://myserver.org/api</a>”</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CODEREVIEW ==
创建、编辑或删除代码审查。</p>
<p>== CMD_USAGE_CODEREVIEW ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^codereview &lt;规格&gt; &lt;标题&gt; [–^status=&lt;状态名称&gt;]</dt><dd><p>[–^assignee=&lt;用户名&gt;] [–^format=&lt;格式字符串&gt;]
[–^repository=&lt;存储库规格&gt;]</p>
</dd>
</dl>
<p>（创建代码审查。）</p>
<dl class="simple">
<dt>cm ^codereview -^e &lt;ID&gt; [–^status=&lt;状态名称&gt;] [–^assignee=&lt;用户名&gt;]</dt><dd><p>[–^repository=&lt;存储库规格&gt;]</p>
</dd>
</dl>
<p>（编辑代码审查。）</p>
<p>cm ^codereview -^d &lt;ID&gt; [ …][–^repository=&lt;存储库规格&gt;]
（删除一个或多个代码审查。）</p>
<dl class="simple">
<dt>规格                可以是变更集规格或分支规格。此规格</dt><dd><p>将作为新代码审查的目标。（使用
‘cm ^help ^objectspec’ 可进一步了解变更集规格
或分支规格。）</p>
</dd>
<dt>标题               用作新代码审查的标题的</dt><dd><p>文本字符串。</p>
</dd>
<dt>ID                  代码审查标识号。也可以使用</dt><dd><p>GUID。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>-^e                  编辑现有代码审查的参数。
-^d                  删除一个或多个现有代码审查。使用</p>
<blockquote>
<div><p>空格对各个代码审查 ID 进行分隔。</p>
</div></blockquote>
<dl class="simple">
<dt>–^status            设置代码审查的新状态。请参阅“备注”</dt><dd><p>以了解更多信息。</p>
</dd>
</dl>
<p>–^assignee          设置代码审查的新被分派人。
–^format            检索特定格式的输出消息。请参阅</p>
<blockquote>
<div><p>“备注”以了解更多信息。</p>
</div></blockquote>
<dl class="simple">
<dt>–^repository        设置要用作默认存储库的存储库。（使用</dt><dd><p>‘cm ^help ^objectspec’ 可进一步了解存储库
规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_CODEREVIEW ==
备注：</p>
<blockquote>
<div><p>此命令允许用户管理代码审查：为变更集或分支
创建、编辑和删除代码审查。</p>
<p>要创建新的代码审查，必须提供变更集/分支规格和
标题。也可以设置初始状态和被分派人。结果将返回
一个 ID（如果请求返回 GUID，则返回 GUID）。</p>
<p>要编辑或删除现有代码审查，必须提供目标代码
审查 ID（或 GUID）。如果没有错误，则不会显示任何消息。</p>
<p>状态参数只能是以下值之一：^”Under review”
（默认值）、^”Reviewed” 或 ^”Rework required”。</p>
<p>repository 参数可用于设置默认的工作
存储库。当用户想要在其他服务器上而不是在与当前工作区
关联的服务器上管理审查时，或者根本没有
当前工作区时，此参数很有用。</p>
<p>输出格式自定义：</p>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{0}             ID
{1}             GUID</p>
</div></blockquote>
<p>请注意，’–^format’ 参数仅在创建新的代码
审查时生效。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^codereview ^cs:1856&#64;myrepo&#64;myserver:8084 “我的代码审查” –^assignee=dummy
cm ^codereview ^br:/main/task001&#64;myrepo&#64;myserver:8084 “我的代码审查” –^status=^”Rework required” –^assignee=newbie –^format=”{^id} -&gt; {^guid}”</p>
<p>cm ^codereview 1367 -^e –^assignee=新的被分派人
cm ^codereview -^e 27658884-5dcc-49b7-b0ef-a5760ae740a3 –^status=已审查</p>
<p>cm ^codereview -^d 1367 <a class="reference external" href="mailto:--^repository=myremoterepo&#37;&#52;&#48;myremoteserver">–^repository=myremoterepo<span>&#64;</span>myremoteserver</a>:18084
cm ^codereview 27658884-5dcc-49b7-b0ef-a5760ae740a3 -^d</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CRYPT ==
对密码进行加密。</p>
<p>== CMD_USAGE_CRYPT ==
用法：</p>
<blockquote>
<div><p>cm ^crypt &lt;我的密码&gt;</p>
<p>我的密码          要加密的密码。</p>
</div></blockquote>
<p>== CMD_HELP_CRYPT ==
备注：</p>
<blockquote>
<div><p>此命令用于加密作为参数传递的给定密码。
旨在对配置文件中的密码进行加密并提高
安全性。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^crypt dbconfpassword -&gt; ENCRYPTED: encrypteddbconfpassword
（对数据库配置文件 ‘db.conf’ 中的密码进行加密。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_DEACTIVATEUSER ==
停用许可的用户。</p>
<p>== CMD_USAGE_DEACTIVATEUSER ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^deactivateuser | ^du &lt;用户名&gt;[ …][–^server=&lt;名称:端口&gt;]</dt><dd><p>[–^nosolveuser]</p>
</dd>
<dt>用户名            要停用的一个或多个用户名。使用空格</dt><dd><p>对各个用户名进行分隔。
如果是 SID，则需要 ‘–^nosolveuser’。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^server            停用指定服务器上的用户。</dt><dd><p>如果未指定服务器，则在客户端上配置的
服务器上执行命令。</p>
</dd>
<dt>–^nosolveuser       使用此选项时，该命令将不会检查身份验证系统上</dt><dd><p>是否存在相应的用户名。而且
&lt;用户名&gt; 必须是用户 SID。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_DEACTIVATEUSER ==
备注：</p>
<blockquote>
<div><p>此命令将用户设置为非活动状态，从而禁止该用户使用
Plastic SCM。</p>
<p>有关激活 Plastic SCM 用户的更多信息，请参阅 ‘cm ^activateuser’
命令。</p>
<p>此命令检查用户是否在基础身份验证系统（例如 ActiveDirectory、
LDAP、用户/密码…）上存在。
要强制停用在身份验证系统上不再存在的
用户，可以使用 ‘–^nosolveuser’ 选项。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^deactivateuser john
cm ^du peter “mary collins”
cm ^deactivateuser john –^server=myserver:8084
cm ^deactivateuser S-1-5-21-3631250224-3045023395-1892523819-1107 –^nosolveuser</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_DIFF ==
显示文件、变更集和标签之间的差异。</p>
<p>== CMD_USAGE_DIFF ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^diff &lt;变更集规格&gt; | &lt;标签规格&gt; | &lt;搁置规格&gt; [&lt;变更集规格&gt; | &lt;标签规格&gt; | &lt;搁置规格&gt;]</dt><dd><blockquote>
<div><p>[&lt;路径&gt;]
[–^added] [–^changed] [–^moved] [–^deleted]
[–^repositorypaths] [–^download=&lt;下载路径&gt;]
[–^encoding=&lt;名称&gt;]
[–^ignore=(^eol | ^whitespaces | ^”eol&amp;whitespaces” | ^none)]
[–^clean]
[–^format=&lt;格式字符串&gt;] [–^dateformat=&lt;格式字符串&gt;]</p>
</div></blockquote>
<p>显示“源”变更集或搁置集与“目标”变更集或搁置集
之间的差异。可使用变更集或标签规格
来指定变更集。
如果给出了两个规格，则第一个是差异比较的“源”，
第二个是“目标”。
如果仅给出一个规格，则“源”将是指定“目标”的
父变更集。
如果指定了可选路径，则将启动“差异比较窗口”以显示
该文件的两个修订之间的差异。</p>
</dd>
</dl>
<p>cm ^diff &lt;修订规格1&gt; &lt;修订规格2&gt;</p>
<blockquote>
<div><p>显示一对修订之间的差异。这些差异
显示在“差异比较窗口”中。指定的第一个修订将
显示在左侧。</p>
</div></blockquote>
<dl>
<dt>cm ^diff &lt;分支规格&gt; [–^added] [–^changed] [–^moved] [–^deleted]</dt><dd><blockquote>
<div><p>[–^repositorypaths] [–^download=&lt;下载路径&gt;]
[–^encoding=&lt;名称&gt;]
[–^ignore=(^eol | ^whitespaces | ^”eol&amp;whitespaces” | ^none)]
[–^clean]
[–^format=&lt;格式字符串&gt;] [–^dateformat=&lt;格式字符串&gt;]
[–^fullpaths | –^fp]</p>
</div></blockquote>
<p>显示分支差异。</p>
</dd>
</dl>
<p>（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl>
<dt>–^added             仅打印包含已添加到存储库的项</dt><dd><p>的差异。</p>
</dd>
<dt>–^changed           仅打印包含已更改的项</dt><dd><p>的差异。</p>
</dd>
<dt>–^moved             仅打印包含已移动或已重命名的项</dt><dd><p>的差异。</p>
</dd>
<dt>–^deleted           仅打印包含已删除的项</dt><dd><p>的差异。</p>
<p>如果未指定 ‘–^added’、’–^changed’、’–^moved’ 或 ‘–^deleted’，
则该命令将打印所有差异。</p>
<blockquote>
<div><p>‘^A’ 表示已添加的项。
‘^C’ 表示已更改的项。
‘^D’ 表示已删除的项。
‘^M’ 表示已移动的项。左侧的项是原始项，</p>
<blockquote>
<div><p>右侧是目标项。</p>
</div></blockquote>
</div></blockquote>
</dd>
<dt>–^repositorypaths   打印存储库路径而不是工作区路径。</dt><dd><p>（此选项将覆盖 ‘–^fullpaths’ 选项。）</p>
</dd>
<dt>–^download          将差异内容存储在指定的输出</dt><dd><p>路径中。</p>
</dd>
<dt>–^encoding          指定输出编码，如：utf-8。</dt><dd><p>请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
<dt>–^ignore            设置指定的比较方法。</dt><dd><p>请参阅“备注”以了解更多信息。</p>
</dd>
<dt>–^clean             不考虑由于合并而产生的</dt><dd><p>差异，仅考虑简单签入所创建的
差异。</p>
</dd>
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
<p>–^dateformat        用于输出日期的格式。
–^fullpaths, –^fp   如果可能，强制打印文件和目录的完整</p>
<blockquote>
<div><p>工作区路径。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_DIFF ==
备注：</p>
<blockquote>
<div><dl class="simple">
<dt>比较方法：</dt><dd><p>^eol                 忽略行尾差异。
^whitespaces         忽略空格差异。
^”eol&amp;whitespaces”   忽略行尾和空格差异。
^none                检测行尾和空格差异。</p>
</dd>
</dl>
<p>此命令接受格式字符串以显示输出。
此命令的参数如下：</p>
<blockquote>
<div><p>{^path}              项路径。
{^date}              更改日期/时间。
{^owner}             更改作者。
{^revid}             在差异比较中被视为目标的修订的</p>
<blockquote>
<div><p>修订 ID。</p>
</div></blockquote>
<dl class="simple">
<dt>{^parentrevid}       在差异比较中被视为目标的修订的</dt><dd><p>父级修订 ID。</p>
</dd>
<dt>{^baserevid}         在差异比较中被视为源的修订的</dt><dd><p>修订 ID。</p>
</dd>
</dl>
<p>{^srccmpath}         移动项（移动操作）之前的服务器路径。
{^dstcmpath}         移动项（移动操作）之后的服务器路径。
{^type}              项类型：</p>
<blockquote>
<div><p>^D   目录，
^B   二进制文件，
^F   文本文件，
^S   符号链接，
^X   Xlink。</p>
</div></blockquote>
<p>{^repository}        项的存储库。
{^status}            项状态：</p>
<blockquote>
<div><p>^A   已添加，
^D   已删除，
^M   已移动，
^C   已更改。</p>
</div></blockquote>
<p>{^fsprotection}      显示项权限 (Linux/Mac chmod)。
{^srcfsprotection}   显示父修订项权限。
{^newline}           插入一个新行。</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>有关 ‘^revid’ 的注意事项：</dt><dd><p>对于已添加的项，’^baserevid’ 和 ‘^parentrevid’ 将为 -1，因为
在这种情况下不存在以前的修订。
对于已删除的项，’^revid’ 是源修订的 ID，而
‘^baserevid’ 将为 -1，因为没有目标修订。
对于 Xlink，’^baserevid’ 和 ‘^parentrevid’ 都始终为 -1。</p>
</dd>
</dl>
<p>示例：</p>
<blockquote>
<div><p>比较分支：</p>
<blockquote>
<div><p>cm ^diff ^br:/main/task001
cm ^diff ^br:/main/task001 docreadme.txt</p>
</div></blockquote>
<p>比较变更集树：</p>
<blockquote>
<div><p>cm ^diff 19
cm ^diff 19 25
cm ^diff ^cs:19 ^cs:25 –^format=”{^path} {^parentrevid}”
cm ^diff ^cs:19 ^cs:23 –^format=”{^date} {^path}” –^dateformat=”yy/dd/MM HH:mm:ss”
cm ^diff ^cs:19 ^cs:23 –^changed
cm ^diff ^cs:19 ^cs:23 –^repositorypaths
cm ^diff ^cs:19 ^cs:23 –^download=”D:temp”
cm ^diff ^cs:19 ^cs:23 –^clean
cm ^diff ^cs:19 ^cs:23 docreadme.txt</p>
</div></blockquote>
<p>比较标签树：</p>
<blockquote>
<div><p>cm ^diff ^lb:FirstReleaseLabel ^lb:SecondReleaseLabel
cm ^diff ^lb:tag_193.2 ^cs:34214
cm ^diff ^cs:31492 ^lb:tag_193.2</p>
</div></blockquote>
<p>比较搁置树：</p>
<blockquote>
<div><p>cm ^diff ^sh:2
cm ^diff ^sh:2 ^sh:4</p>
</div></blockquote>
<dl>
<dt>比较修订规格：</dt><dd><p>cm ^diff ^rev:readme.txt#^cs:19 ^rev:readme.txt#^cs:20
cm ^diff ^serverpath:/doc/readme.txt#^cs:<a class="reference external" href="mailto:19&#37;&#52;&#48;myrepo">19<span>&#64;</span>myrepo</a> </p>
<blockquote>
<div><p>^serverpath:/doc/readme.txt#^br:/main&#64;myrepo&#64;localhost:8084</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>== CMD_DESCRIPTION_DIFFMETRICS ==
显示两个修订之间的差异比较指标。</p>
<p>== CMD_USAGE_DIFFMETRICS ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^diffmetrics | ^dm &lt;修订规格 1&gt; &lt;修订规格 2&gt; [–^format=&lt;格式字符串&gt;]</dt><dd><p>[–^encoding=&lt;名称&gt;]
[–^ignore=(^eol | ^whitespaces | ^”eol&amp;whitespaces” | ^none)]</p>
</dd>
<dt>修订规格           用于比较的修订。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解修订规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format          检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
<dt>–^encoding        指定输出编码，如：utf-8。</dt><dd><p>请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
<dt>–^ignore          设置指定的比较方法。</dt><dd><p>请参阅“备注”以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_DIFFMETRICS ==
备注：</p>
<blockquote>
<div><p>指标为：已更改、添加和删除的行数。</p>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{0}             已更改的行数。
{1}             已添加的行数。
{2}             已删除的行数。</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^diffmetrics file.txt#^cs:2 file.txt#^br:/main/scm0211 –^format=”已更改 {0} 行，已添加 {1} 行，已删除 {2} 行。”
（检索已格式化的差异比较指标结果。）</p>
<p>cm ^dm file.txt#^cs:2 file.txt#^cs:3 –^encoding=utf-8 –^ignore=^whitespaces</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_FASTEXPORT ==
以快速导出格式导出存储库。</p>
<p>== CMD_USAGE_FASTEXPORT ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^fast-export | ^fe &lt;存储库规格&gt; &lt;快速导出文件&gt;</dt><dd><p>[–^import-marks=&lt;标记文件&gt;]
[–^export-marks=&lt;标记文件&gt;]
[–^branchseparator=&lt;分隔符&gt;]
[–^nodata] [–^from=&lt;变更集ID&gt;] [–^to=&lt;变更集ID&gt;]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>存储库规格             要从中导出数据的存储库。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库规格。）</p>
</dd>
<dt>快速导出文件    具有存储库数据并采用 Git 快速导出格式的</dt><dd><p>文件。</p>
</dd>
<dt>–^import-marks      用于增量导入的标记文件。此文件</dt><dd><p>已在先前由 ‘–^export-marks’ 导出。此
文件中描述的变更集将不会被导入，
因为这些变更集已在先前被导入。</p>
</dd>
<dt>–^export-marks      所导入的变更集将保存到的文件。</dt><dd><p>此文件在以后的快速导入中用于表示
已导入的变更集。</p>
</dd>
<dt>–^branchseparator   Plastic SCM 使用 “/” 作为分支层次结构中的默认</dt><dd><p>分隔符。此选项允许将字符用作层次结构
分隔符，因此 main-task-sub 将在 Plastic SCM 中
映射为 /main/task/sub。</p>
</dd>
<dt>–^nodata            导出存储库，但不包括数据。这对于</dt><dd><p>检查导出功能是否可正确运行很有用。</p>
</dd>
</dl>
<p>–^from              从特定变更集导出。
–^to                导出到特定变更集。</p>
</div></blockquote>
<p>== CMD_HELP_FASTEXPORT ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>为了将 Plastic SCM 存储库导入到 Git，请使用诸如以下命令的命令：
^cat repo.fe.00 | ^git ^fast-import –^export-marks=marks.git  –^import-marks=marks.git</p></li>
<li><p>支持使用一个包含先前导入的变更集的
标记文件（’–^import-marks’ 和 ‘–^export-marks’ 文件）进行增量
导出。
这意味着将仅导出在先前快速导出中未导出的
新变更集。</p></li>
</ul>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^fast-export <a class="reference external" href="mailto:repo&#37;&#52;&#48;localhost">repo<span>&#64;</span>localhost</a>:8087 repo.fe.00 –^import-marks=marks.cm </dt><dd><p>–^export-marks=marks.cm</p>
</dd>
</dl>
<p>（将本地服务器中的存储库 ‘repo’ 以 Git 快速导出格式
导出到 ‘repo.fe.00’ 文件中，并创建标记文件以稍后
执行增量导出。）</p>
<p>cm ^fast-export <a class="reference external" href="mailto:repo&#37;&#52;&#48;localhost">repo<span>&#64;</span>localhost</a>:8087 repo.fe.00 –^from=20
（将本地服务器中的存储库 ‘repo’ 以 Git 快速导出格式
从变更集 ‘20’ 导出到 ‘repo.fe.00’ 文件中。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_FASTIMPORT ==
将 Git 快速导出数据导入到存储库中。</p>
<p>== CMD_USAGE_FASTIMPORT ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^fast-import | ^fi &lt;存储库规格&gt; &lt;快速导出文件&gt;</dt><dd><p>[–^import-marks=&lt;标记文件&gt;]
[–^export-marks=&lt;标记文件&gt;]
[–^stats] [–^branchseparator=&lt;分隔符&gt;]
[–^nodata] [–^ignoremissingchangesets] [–^mastertomain]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>存储库规格                     要将数据导入到的</dt><dd><p>存储库。如果事先不存在存储库，
则会创建该存储库。（使用 ‘cm ^help ^objectspec’ 可进一步
了解存储库规格。）</p>
</dd>
<dt>快速导出文件            具有存储库数据并采用 Git 快速</dt><dd><p>导出格式的文件。</p>
</dd>
<dt>–^import-marks              用于增量导入的标记文件。</dt><dd><p>此文件已在先前由
‘–^export-marks’ 导出。此文件中描述的
变更集将不会被导入，因为这些变更集
已在先前被导入。</p>
</dd>
<dt>–^export-marks              所导入的变更集将保存到的</dt><dd><p>文件。此文件在以后的
快速导入中用于表示
已导入的变更集。</p>
</dd>
</dl>
<p>–^stats                     打印一些有关导入过程的统计信息。
–^branchseparator           Plastic SCM 使用 “/” 作为分支层次结构</p>
<blockquote>
<div><p>中的默认分隔符。此选项允许
将字符用作层次结构分隔符，因此 main-task-sub
将在 Plastic SCM 中映射为 /main/task/sub。</p>
</div></blockquote>
<dl class="simple">
<dt>–^nodata                    导入 Git 快速导出结果，但不包括</dt><dd><p>数据。这对于检查导入功能是否可正确
运行很有用。</p>
</dd>
<dt>–^ignoremissingchangesets   无法导入的任何变更集都将被丢弃，</dt><dd><p>然后在没有这些变更集的情况下继续
进行快速导入操作。</p>
</dd>
</dl>
<p>–^mastertomain              使用 “^main” 而不是 “^master” 进行导入。</p>
</div></blockquote>
<p>== CMD_HELP_FASTIMPORT ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>为了导出 Git 存储库，请使用诸如以下命令的命令：
^git ^fast-export –^all -^M –^signed-tags=^strip –^tag-of-filtered-object=^drop&gt; ..git-fast-export.dat
-^M 选项对于检测移动的项很重要。</p></li>
<li><p>如果指定的存储库不存在，则会创建该存储库。</p></li>
<li><p>支持使用一个包含先前导入的变更集的
标记文件（’–^import-marks’ 和 ‘–^export-marks’ 文件）进行增量
导入。
这意味着将仅导入在先前快速导入中未导入的
新变更集。</p></li>
</ul>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^fast-import <a class="reference external" href="mailto:mynewrepo&#37;&#52;&#48;atenea">mynewrepo<span>&#64;</span>atenea</a>:8084  repo.fast-export
（将导出到 ‘repo.fast-export’ 文件中的内容导入到
服务器 ‘atenea:8084’ 上的 ‘mynewrepo’ 存储库中。）</p>
<p>cm ^fast-import <a class="reference external" href="mailto:repo&#37;&#52;&#48;atenea">repo<span>&#64;</span>atenea</a>:8084  repo.fast-export –^export-marks=rep.marks
（将导出到 ‘repo.fast-export’ 文件中的内容导入到
服务器 ‘atenea:8084’ 上的 ‘repo’ 存储库中，并创建一个标记文件
以稍后执行增量导入。）</p>
<dl class="simple">
<dt>cm ^fast-import <a class="reference external" href="mailto:repo&#37;&#52;&#48;server">repo<span>&#64;</span>server</a>:8084  repo.fast-export –^import-marks=repo.marks </dt><dd><p>–^export-marks=repo.marks</p>
</dd>
</dl>
<p>（导入 ‘repo.fast-export’ 文件的内容。仅导入
不在标记文件中的新变更集。同样的这个
标记文件还用于再次保存变更集列表，以便进行
下一次增量导入。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_FILEINFO ==
检索有关工作区中的项的详细信息。</p>
<p>== CMD_USAGE_FILEINFO ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^fileinfo &lt;项路径&gt;[ …][–^fields=&lt;字段值&gt;[,…]]</dt><dd><p>[[–^xml | -^x [=&lt;输出文件&gt;]] | [–^format=&lt;格式字符串&gt;]]
[–^symlink] [–^encoding=&lt;名称&gt;]</p>
</dd>
<dt>项路径           要显示的项。使用空格对各个项进行</dt><dd><p>分隔。
使用双引号 (” “) 指定包含空格的
路径。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^fields            一串用逗号分隔的值。此字符串用于</dt><dd><p>选择要为每项打印的字段。请参阅“备注”
以了解更多信息。</p>
</dd>
<dt>–^xml | -^x          以 XML 格式将输出打印到标准输出。</dt><dd><p>可以指定输出文件。此选项
不能与 ‘–^format’ 结合使用。</p>
</dd>
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。此选项不能与 ‘–^xml’
结合使用。
此 ‘–^format’ 选项优先于 ‘–^fields’（如果同时
指定了这两者）。</p>
</dd>
<dt>–^symlink           将 fileinfo 操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
<dt>–^encoding          指定输出编码，如：utf-8。</dt><dd><p>请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_FILEINFO ==
备注：</p>
<blockquote>
<div><p>此命令为每个所选项打印详细的属性列表。
默认情况下，每个属性都打印在新行上。</p>
<p>可以修改属性列表以仅显示用户所需的
属性。为实现此目的，可以使用 ‘–^fields=&lt;字段列表&gt;’，
其中会接受一串用逗号分隔的属性名称。这样就只会显示
已指明名称的那些参数。</p>
<p>修订头部变更集：</p>
<p>默认情况下会禁用此选项。请注意，检索此属性的
速度明显慢于其余属性，因此我们建议用户
将尽可能多的项组合在一起。这样可以避免
多次单独执行 ‘cm ^fileinfo’，从而缩短执行时间。
另外，此功能当前不适用于受控目录。</p>
<p>您可以在下面找到可用属性名称的完整列表。
默认情况下不会显示标有星号 (‘*’) 的名称：</p>
<blockquote>
<div><p>^ClientPath              项在磁盘上的本地路径。
^RelativePath            相对于工作区的路径。
^ServerPath              项的存储库路径。</p>
<blockquote>
<div><p>（注意：此选项当前
不支持已变换的工作区）。</p>
</div></blockquote>
<p>^Size                    项大小。
^Hash                    项哈希值总和。
^Owner                   项所属的用户。
^RevisionHeadChangeset   (*) 已加载到分支头部变更集内的</p>
<blockquote>
<div><p>修订变更集。
（请参阅上面的注意事项。）</p>
</div></blockquote>
<dl class="simple">
<dt>^RevisionChangeset       当前已加载到工作区内的</dt><dd><p>修订变更集。</p>
</dd>
<dt>^RepSpec                 项的存储库规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解
存储库规格。）</p>
</dd>
<dt>^Status                  工作区项状态：已添加、已签出、</dt><dd><p>已删除，等等。</p>
</dd>
<dt>^Type                    修订类型（文本、二进制、目录、符号链接</dt><dd><p>或未知）。</p>
</dd>
</dl>
<p>^Changelist              项所属的更改列表（如果有）。
^IsLocked                (*) 项是否已被独占签出</p>
<blockquote>
<div><p>锁定。</p>
</div></blockquote>
<p>^LockedBy                (*) 将项独占签出的用户。
^LockedWhere             (*) 将项独占签出的</p>
<blockquote>
<div><p>位置。</p>
</div></blockquote>
<dl class="simple">
<dt>^IsUnderXlink            项是否位于 Xlink</dt><dd><p>之下。</p>
</dd>
<dt>^UnderXlinkTarget        项所在的 Xlink 的目标</dt><dd><p>（如果有）。</p>
</dd>
<dt>^UnderXlinkPath          通过 Xlink 链接的存储库中的项服务器路径</dt><dd><p>（如果有）。</p>
</dd>
<dt>^UnderXlinkWritable      项所属的 Xlink 是否</dt><dd><p>可写。</p>
</dd>
<dt>^UnderXlinkRelative      项所属的 Xlink 是否</dt><dd><p>是相对 Xlink。</p>
</dd>
</dl>
<p>^IsXlink                 项本身是否是 Xlink。
^XlinkTarget             项指向的目标存储库（如果项</p>
<blockquote>
<div><p>是 Xlink）。</p>
</div></blockquote>
<dl class="simple">
<dt>^XlinkName               项的 Xlink 名称（如果项实际上</dt><dd><p>是 Xlink）。</p>
</dd>
<dt>^XlinkWritable           Xlink 项是否为</dt><dd><p>可写 Xlink。</p>
</dd>
<dt>^XlinkRelative           Xlink 项是否为</dt><dd><p>相对 Xlink。</p>
</dd>
</dl>
</div></blockquote>
<p>输出格式自定义：</p>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{^ClientPath}
{^RelativePath}
{^ServerPath}
{^Size}
{^Hash}
{^Owner}
{^RevisionHeadChangeset}
{^RevisionChangeset}
{^Status}
{^Type}
{^Changelist}
{^IsLocked}
{^LockedBy}
{^LockedWhere}
{^IsUnderXlink}
{^UnderXlinkTarget}
{^UnderXlinkPath}
{^UnderXlinkWritable}
{^UnderXlinkRelative}
{^IsXlink}
{^XlinkTarget}
{^XlinkName}
{^XlinkWritable}
{^XlinkRelative}
{^RepSpec}</p>
</div></blockquote>
<p>请注意，’–^format’ 和 ‘–^xml’ 选项是互斥的，
因此不能同时使用。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^fileinfo file1.txt file2.txt dir/
cm ^fileinfo “New Project.csproj” –^xml
cm ^fileinfo assets.art –^fields=^ServerPath,^Size,^IsLocked,^LockedBy
cm ^fileinfo proj_specs.docx –^fields=^ServerPath,^RevisionChangeset –^xml
cm ^fileinfo samples.ogg –^format=”{^ServerPath}[{^Owner}] -&gt; {^Size}”</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_FIND_QUERY ==
运行类似 SQL 的查询以查找 Plastic SCM 对象。</p>
<p>== CMD_USAGE_FIND_QUERY ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^find &lt;对象类型&gt;</dt><dd><p>[^where &lt;条件字符串&gt;]
[^on ^repository ‘&lt;存储库规格&gt;’ | ^on ^repositories ‘&lt;存储库规格1&gt;’,’&lt;存储库规格2&gt;’[,…]]
[–^format=&lt;格式字符串&gt;] [–^dateformat=&lt;日期格式&gt;]
[–^nototal] [–^file=&lt;转储文件&gt;] [–^xml]
[–^encoding=&lt;名称&gt;]</p>
</dd>
<dt>对象类型         要查找的对象类型。</dt><dd><p>（使用 ‘cm ^help ^showfindobjects’ 可了解如何指定
这些对象。）
您还可以阅读 ‘cm ^find’ 指南：
<a class="reference external" href="https://www.plasticscm.com/download/help/cmfind">https://www.plasticscm.com/download/help/cmfind</a></p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>条件字符串      搜索对象属性的条件。
存储库规格             搜索存储库别名或规格。</p>
<blockquote>
<div><p>如果是 ‘^on ^repositories’，请使用逗号
对存储库规格字段进行分隔。
（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
规格。）</p>
</div></blockquote>
<dl class="simple">
<dt>–^format            检索特定格式的输出消息。</dt><dd><p>请阅读 ‘cm ^find’ 指南以查看所有
可用作输出格式字符串的对象属性：
<a class="reference external" href="https://www.plasticscm.com/download/help/cmfind">https://www.plasticscm.com/download/help/cmfind</a></p>
</dd>
</dl>
<p>–^dateformat        用于输出日期的格式。
–^nototal           最后不输出记录数。
–^file              转储结果的文件。
–^xml               以 XML 格式将输出打印到标准输出。
–^encoding          指定输出编码，如：utf-8。</p>
<blockquote>
<div><p>请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_FIND_QUERY ==
备注：</p>
<blockquote>
<div><p>如果未指定存储库，则在工作区中配置的存储库上
进行搜索。</p>
<p>从命令行中使用比较运算符（&gt;、&lt;、&gt;=、&lt;=）
运行查询时，请注意，shell 将这些运算符视为 IO
重定向。因此，需要用双引号将查询
引起来。</p>
<p>‘cm ^find’ 命令接受格式字符串以显示输出。
每个输出参数由字符串进行标识，用户可以通过
在 ‘{’ 和 ‘}’ 花括号之间键入参数编号来引用参数。
输出参数通常对应于对象的属性。</p>
<dl class="simple">
<dt>一些有效的输出格式字符串如下：</dt><dd><p>–^format={^id}{^date}{^name}
–^format=”{^item}#{^branch} ^with ^date {^date}”</p>
</dd>
</dl>
<p>XML 和编码注意事项：</p>
<p>指定 ‘–^xml’ 选项后，该命令在标准输出中将命令结果
显示为 XML 文本。文本将以操作系统的
默认编码显示，因此在控制台中可能会
错误地显示非 ANSI 字符。如果将命令输出重定向到
文件，则将正确显示输出内容。当同时指定了 ‘–^xml’ 和 ‘–^file’
选项时，默认编码为 utf-8。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^find ^revision
cm ^find ^revision “^where ^changeset=23 ^and ^owner=’maria’”
cm ^find ^branch “^on ^repository ‘rep1’”
cm ^find ^label “^on ^repositories ‘rep1’, ‘^rep:<a class="reference external" href="mailto:default&#37;&#52;&#48;localhost">default<span>&#64;</span>localhost</a>:8084’”
cm ^find ^branch “^where ^parent=’^br:/main’ ^on ^repository ‘rep1’”
cm ^find ^revision “^where ^item=’^item:.’” –^format=”{^item}#{^branch}”
cm ^find ^revision “^where ^item=’^item:.’” –^xml –^file=c:queryresultsrevs.xml</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_FINDCHANGED ==
获取已更改文件的列表。已弃用此命令，保留此命令只是为了
向后兼容。请改用 ‘cm ^status’。</p>
<p>== CMD_USAGE_FINDCHANGED ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^findchanged | ^fc [-^R | -^r | –^recursive] [–^checkcontent]</dt><dd><p>[–^onlychanged] [&lt;路径&gt;]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>-^R                  以递归方式在目录中查找。
–^checkcontent      按内容比较文件。
–^onlychanged       仅查找已更改的文件；无法获得</p>
<blockquote>
<div><p>签出。</p>
</div></blockquote>
<dl class="simple">
<dt>路径                （默认值：当前目录。）</dt><dd><p>查找已更改文件的初始路径。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_FINDCHANGED ==
备注：</p>
<blockquote>
<div><p>如果未给出 ‘–^checkcontent’ 选项，Plastic 将根据文件时间戳
查找更改。当指定了 ‘–^checkcontent’ 选项时，比较的是
文件或文件夹内容，而不使用时间戳。</p>
<p>与 Plastic SCM 服务器断开连接的情况下，此命令对于检测
已更改的文件很有用。可以将输出通过管道传递到 checkout 命令，
从而在稍后检查更改（请参阅示例）。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^findchanged .
（在当前目录中查找已更改的文件。）</p>
<p>cm ^findchanged -^R .| cm ^checkout -
（签出已更改的元素。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_FINDCHECKEDOUT ==
获取已签出项的列表。已弃用此命令，保留此命令只是为了
向后兼容。请改用 ‘cm ^status’。</p>
<p>== CMD_USAGE_FINDCHECKEDOUT ==
用法：</p>
<blockquote>
<div><p>cm ^findcheckouts | ^fco [–^format=&lt;格式字符串&gt;] [–^basepath]</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
<dt>–^basepath          开始搜索签出的起始路径。如果</dt><dd><p>未指定，则使用当前路径。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_FINDCHECKEDOUT ==
备注：</p>
<blockquote>
<div><p>此命令适合用于在一个步骤中签入项或撤销签出所有
已签出的项，并将标准输出重定向到其他命令。
请参阅示例。</p>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{0}             日期。
{1}             所有者。
{2}             工作区信息。
{3}             客户端机器名称。
{4}             项路径。
{5}             分支和存储库信息。</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^findcheckouts –^format=”分支 {5} 上已更改的文件 {4}”
（查找已签出的项，并使用文件路径以及分支和存储库信息
来格式化输出。）</p>
<p>cm ^findcheckouts –^format={4} | cm ^checkin -
（签入所有已签出的项。）</p>
<p>cm ^findcheckouts –^format={4} | cm ^undocheckout -
（撤销签出所有已签出的项。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_FINDPRIVATE ==
获取私有项的列表。已弃用此命令，保留此命令只是为了
向后兼容。请改用 ‘cm ^status’。</p>
<p>== CMD_USAGE_FINDPRIVATE ==
用法：</p>
<blockquote>
<div><p>cm ^findprivate | ^fp [-^R | -^r | –^recursive] [–^exclusions] [&lt;路径&gt;]</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>-^R                  以递归方式在目录中查找。
–^exclusions        此选项允许在文件 ignore.conf 定义的</p>
<blockquote>
<div><p>已忽略路径内禁止搜索。</p>
</div></blockquote>
<dl class="simple">
<dt>路径                （默认值：当前目录。）</dt><dd><p>查找私有文件的初始路径。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_FINDPRIVATE ==
备注：</p>
<blockquote>
<div><p>如果指定了任何路径，Plastic SCM 将开始从当前目录
搜索。</p>
<p>此命令适合用于在文件夹上添加私有项，并将输出通过管道
传递到 add 命令。请参阅示例。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^findprivate .</p>
<p>cm ^findprivate -^R | cm ^add -
（以递归方式搜索私有项并添加这些项。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_GETCONFIG ==
获取配置信息。</p>
<p>== CMD_USAGE_GETCONFIG ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^getconfig [^setfileasreadonly] [^location] [^extensionworkingmode]</dt><dd><p>[^extensionprefix] [^defaultrepserver]</p>
</dd>
<dt>^setfileasreadonly       返回受保护文件是否保留为</dt><dd><p>只读。</p>
</dd>
</dl>
<p>^location                返回客户端配置路径。
^extensionworkingmode    返回扩展工作模式。
^extensionprefix         返回已配置的扩展前缀。
^defaultrepserver        返回默认存储库服务器的</p>
<blockquote>
<div><p>位置。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_GETCONFIG ==
示例：</p>
<blockquote>
<div><p>cm ^getconfig ^setfileasreadonly</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_GETFILE ==
下载给定修订的内容。</p>
<p>== CMD_USAGE_GETFILE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^getfile | ^cat &lt;修订规格&gt; [–^file=&lt;输出文件&gt;] [–^debug]</dt><dd><p>[–^symlink] [–^raw]</p>
</dd>
<dt>修订规格           对象规格。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^file            用于保存输出的文件。默认情况下会打印在</dt><dd><p>标准输出中。</p>
</dd>
<dt>–^debug           使用目录规格时，该命令</dt><dd><p>将显示目录中的所有项、目录的修订 ID
和文件系统保护。</p>
</dd>
<dt>–^symlink         将操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
</dl>
<p>–^raw             显示文件的原始数据。</p>
</div></blockquote>
<p>== CMD_HELP_GETFILE ==
示例：</p>
<blockquote>
<div><p>cm ^cat myfile.txt#^br:/main
（在 ‘myfile.txt’ 的分支 ‘^br:/main’ 中获取最后一个修订。）</p>
<p>cm ^getfile myfile.txt#^cs:3 –^file=tmp.txt
（获取 ‘myfile.txt’ 的变更集 3 并将该变更集写入文件 ‘tmp.txt’。）</p>
<p>cm ^cat ^serverpath:/src/foo.c#^br:<a class="reference external" href="mailto:/main/task003&#37;&#52;&#48;myrepo">/main/task003<span>&#64;</span>myrepo</a>
（在存储库 ‘myrepo’ 中的分支 ‘/main/task003’ 的最后一个变更集处
获取 ‘/src/foo.c’ 的内容）</p>
<p>cm ^cat ^revid:<a class="reference external" href="mailto:1230&#37;&#52;&#48;^rep">1230<span>&#64;</span>^rep</a>:<a class="reference external" href="mailto:myrep&#37;&#52;&#48;^repserver">myrep<span>&#64;</span>^repserver</a>:myserver:8084
（获得 ID 为 1230 的修订。）</p>
<p>cm ^getfile ^rev:info–^debug
（获取 ‘info’ 目录中的所有修订。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_GETREVISION ==
在工作区中加载修订。</p>
<p>== CMD_USAGE_GETREVISION ==
此命令会修改工作区中加载的修订，因此可能影响
以后的合并。
这是从旧版本继承的高级命令，因此请谨慎使用。</p>
<dl>
<dt>用法：</dt><dd><p>cm ^getrevision &lt;修订规格&gt;</p>
<dl class="simple">
<dt>修订规格           对象规格。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解修订规格。）</p>
</dd>
</dl>
</dd>
</dl>
<p>== CMD_HELP_GETREVISION ==
示例：</p>
<blockquote>
<div><p>cm ^getrevision file.txt#^cs:3
（获取 ‘file.txt’ 的变更集 3 修订。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_GETSTATUS ==
获取项的状态。</p>
<p>== CMD_USAGE_GETSTATUS ==
这是一个自动化命令，仅用于自动执行 ‘cm’。
此命令的用户友好度不如预期。</p>
<p>用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^getstatus | ^gs &lt;项路径&gt;[ …][–^format=&lt;格式字符串&gt;] [–^stats]</dt><dd><p>[-^R | -^r | –^recursive]</p>
</dd>
<dt>项路径           要获取相应状态的一个或多个项。使用双引号</dt><dd><p>(” “) 指定包含空格的路径。使用
空格对各个路径进行分隔。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
<p>–^stats             打印一些有关获取状态过程的统计信息。
-^R                  以递归方式显示目录中的状态。</p>
</div></blockquote>
<p>== CMD_HELP_GETSTATUS ==
备注：</p>
<blockquote>
<div><p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{0}             项路径。
{1}             项状态：</p>
<blockquote>
<div><p>0   私有，
1   已签入，
2   已签出。</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^getstatus’ 命令可从 stdin 读取路径。为此，请传递
一个破折号 “-”。
示例：cm ^getstatus -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要获取哪些路径的状态。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id9"><span class="problematic" id="id10">*</span></a>.c | cm ^getstatus –^format=”路径 {0} 状态 {1}” -
（在 Windows 中，获取工作区中所有 .c 文件的状态。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^getstatus file1.txt file2.txt
（获取文件的状态。）</p>
<p>cm ^gs info-^R –^format=”项 {0} 的状态为 {1}”
（获取目录及其所有项的状态，并显示
格式化的输出。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_GETTASKBRANCHES ==
获取与某个任务链接的分支。</p>
<p>== CMD_USAGE_GETTASKBRANCHES ==
这是一个自动化命令，仅用于自动执行 ‘cm’。
此命令的用户友好度不如预期。</p>
<p>用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^gettaskbranches | ^gtb &lt;任务名称&gt; [–^format=&lt;格式字符串&gt;]</dt><dd><p>[–^dateformat=&lt;日期格式&gt;]</p>
</dd>
</dl>
<p>任务名称           任务标识符。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
<p>–^dateformat        用于输出日期的格式。</p>
</div></blockquote>
<p>== CMD_HELP_GETTASKBRANCHES ==
备注：</p>
<blockquote>
<div><p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{^tab}           插入一个制表符空格位。
{^newline}       插入一个新行。
{^name}          分支名称。
{^owner}         分支的所有者。
{^date}          创建分支的日期。
{^type}          分支类型（如果是智能分支，则为 ‘T’，否则为 ‘F’）。
{^parent}        父分支。
{^comment}       分支的注释。
{^repname}       分支所在的存储库。
{^repserver}     服务器名称。</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^gettaskbranches 4311
cm ^gtb 4311 –^format=”^br:{^name}”
cm ^gtb 4311 –^format=”^br:{^name} {^date}” –^dateformat=”yyyy/MM/dd HH:mm:ss”</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_GETWWI ==
显示有关工作区选择器的信息。</p>
<p>== CMD_USAGE_GETWWI ==
用法：</p>
<blockquote>
<div><p>cm ^wi [&lt;工作区路径&gt;]</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>工作区路径             工作区在机器上的路径。</p>
</div></blockquote>
<p>== CMD_HELP_GETWWI ==
备注：</p>
<blockquote>
<div><p>‘^wi’ 命令显示工作区（存储库、分支和/或标签）
的工作配置。</p>
</div></blockquote>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^wi c:mywk</p>
</dd>
</dl>
<p>== CMD_DESCRIPTION_GWP ==
从路径获取工作区信息。</p>
<p>== CMD_USAGE_GWP ==
这是一个自动化命令，仅用于自动执行 ‘cm’。
此命令的用户友好度不如预期。</p>
<p>用法：</p>
<blockquote>
<div><p>cm ^getworkspacefrompath | ^gwp &lt;项路径&gt; [–^format=&lt;格式字符串&gt;]</p>
<p>项路径           磁盘上的文件或文件夹。</p>
</div></blockquote>
<dl class="simple">
<dt>选项：</dt><dd><dl class="simple">
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
</dd>
</dl>
<p>== CMD_HELP_GWP ==
备注：</p>
<blockquote>
<div><p>此命令显示有关路径中的工作区的信息。</p>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{0} | {^wkname}          工作区名称。
{1} | {^wkpath}          工作区路径。
{2} | {^machine}         客户端机器名称。
{3} | {^owner}           工作区所有者。
{4} | {^guid}            工作区 GUID。</p>
<p>{^tab}                   插入一个制表符空格位。
{^newline}               插入一个新行。</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^gwp c:myworkspacecodefile1.cpp –^format=”工作区名称：{^wkname}”</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_HELP ==
获取有关 Plastic SCM 命令的帮助。</p>
<p>== CMD_USAGE_HELP ==
用法：</p>
<blockquote>
<div><p>cm ^help &lt;命令&gt;</p>
</div></blockquote>
<p>== CMD_HELP_HELP ==</p>
<p>== CMD_DESCRIPTION_IOSTATS ==
显示有关硬件的统计信息。</p>
<p>== CMD_USAGE_IOSTATS ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^iostats [&lt;存储库服务器规格&gt;] [&lt;测试列表&gt;[ …]]</dt><dd><p>[–^nettotalmb=&lt;值_mb&gt;] [–^networkiterations=&lt;值_迭代&gt;]
[–^diskdatasize=&lt;值_大小&gt;] [–^disktestpath=&lt;值_路径&gt;]
[–^systemdisplaytime=&lt;值_时间&gt;]
[–^systemdisplaytimeinterval=&lt;值_间隔&gt;]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl>
<dt>存储库服务器规格                 用于执行网络测试的可用 Plastic SCM</dt><dd><p>服务器，例如 “serverUploadTest”
和/或 “serverDownloadTest”。
如果未提供服务器，该命令
将尝试与默认配置的服务器
通信。
（使用 ‘cm ^help ^objectspec’ 可进一步了解
服务器规格。）</p>
</dd>
<dt>测试列表                 可用的测试。使用空格对各个测试字段</dt><dd><p>进行分隔。
请参阅“备注”以了解更多信息。</p>
</dd>
<dt>–^nettotalmb                  表示在网络测试中传输的</dt><dd><p>用户数据量（以兆字节为单位），
例如 “^serverDownloadTest” 或
“^serverUploadTest”。
值必须介于 “4” 到 “512” 之间。
（默认值：16）</p>
</dd>
<dt>–^networkiterations           表示要运行的</dt><dd><p>“^serverDownloadTest” 和/或 “^serverUploadTest”
的迭代次数。
值必须介于 “1” 到 “100” 之间。
（默认值：1）</p>
</dd>
<dt>–^diskdatasize                表示将在 “^diskTest” 上写入</dt><dd><p>并随后读取的数据量（以兆字节
为单位）。
值必须介于 “100” 到 “4096” 之间。
（默认值：512）</p>
</dd>
<dt>–^disktestpath                “^diskTest” 将测试文件写入到的</dt><dd><p>路径。如果未提供此参数，
该命令将尝试使用系统临时
路径。</p>
</dd>
<dt>–^systemdisplaytime           显示系统资源使用情况的时间间隔</dt><dd><blockquote>
<div><p>（单位：秒）。此选项可用于
以下测试：”^systemNetworkUsage”
和 “^systemDiskUsage”。
值必须介于 “1” 到 “3600” 之间。
（默认值：5 秒）。</p>
</div></blockquote>
<dl class="simple">
<dt>–^systemdisplaytimeinterval  系统性能采样的时间间隔</dt><dd><p>（单位：秒）。此选项可用于
以下测试：
“^systemNetworkUsage” 和 “^systemDiskUsage”。
值必须介于 “1” 到 “60” 之间。
（默认值：1 秒）。</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_IOSTATS ==
备注：</p>
<blockquote>
<div><p>此命令要求在网速测试（”^serverUploadTest” 和/或
“^serverDownloadTest”）期间使用可用的服务器。</p>
<p>‘–^diskTestPath’ 必须指向属于要测试的物理
磁盘驱动器的路径。如果未指定路径，该命令将尝试
使用系统默认的临时路径。
指定路径的磁盘驱动器必须具有足够的可用空间才能执行
测试。</p>
<p>在执行命令期间，执行的测试可能导致
系统性能下降。</p>
<dl class="simple">
<dt>可用的测试：</dt><dd><dl class="simple">
<dt>–^serveruploadtest      （默认值）测量从 Plastic SCM 客户端到</dt><dd><p>服务器的数据上传速度。</p>
</dd>
<dt>–^serverdownloadtest    （默认值）测量从 Plastic SCM 服务器到</dt><dd><p>客户端的数据下载速度。</p>
</dd>
<dt>–^disktest              （默认值）测量磁盘读取速度和磁盘</dt><dd><p>写入速度。</p>
</dd>
<dt>–^systemnetworkusage    显示当前的系统网络资源</dt><dd><p>使用情况。
（显示 Microsoft Windows 提供的网络接口
性能计数器）。
仅在 Microsoft Windows 中可用。</p>
</dd>
<dt>–^systemdiskusage       显示当前的系统物理磁盘</dt><dd><p>使用情况。
（显示 Microsoft Windows 提供的网络接口
性能计数器）。
仅在 Microsoft Windows 中可用。</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^iostats MYSERVER:8087 –^serveruploadtest –^serverdownloadtest –^nettotalmb=32</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ISSUETRACKER ==
在指定的问题跟踪程序中获取、更新或查找问题状态。</p>
<p>== CMD_USAGE_ISSUETRACKER ==
用法：</p>
<blockquote>
<div><p>cm ^issuetracker &lt;名称&gt; ^status ^get &lt;任务_ID&gt; &lt;参数&gt;[ …]
cm ^issuetracker &lt;名称&gt; ^status ^update &lt;任务_ID&gt; &lt;状态&gt; &lt;参数&gt;[ …]
cm ^issuetracker &lt;名称&gt; ^status ^find &lt;状态&gt; &lt;参数&gt;[ …]
cm ^issuetracker &lt;名称&gt; ^connection ^check &lt;参数&gt;[ …]</p>
<dl class="simple">
<dt>名称                要连接的问题跟踪程序的名称。</dt><dd><p>目前仅支持 Jira。</p>
</dd>
</dl>
<p>任务_ID             要查询或更新的问题的编号。
^status              问题跟踪程序中某个问题的有效状态。</p>
</div></blockquote>
<p>Jira 参数（全部为必需参数）：</p>
<blockquote>
<div><p>–^user=&lt;用户&gt;         要验证身份的用户。
–^password=&lt;密码&gt; 用于身份验证的密码。
–^host=&lt;URL&gt;          问题跟踪程序的目标 URL。
–^projectkey=&lt;密钥&gt;    Jira 项目的项目密钥。</p>
</div></blockquote>
<p>== CMD_HELP_ISSUETRACKER ==
示例：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^issuetracker jira ^status ^get 11 <a class="reference external" href="mailto:--^user=user&#37;&#52;&#48;mail&#46;es">–^user=user<span>&#64;</span>mail<span>&#46;</span>es</a> –^password=pwd </dt><dd><p>–^host=https://user.atlassian.net –^projectkey=PRJ</p>
</dd>
</dl>
<p>（获取 ‘PRJ’ 项目的问题 11 的状态。）</p>
<dl class="simple">
<dt>cm ^issuetracker jira ^status ^update 11 “完成” <a class="reference external" href="mailto:--^user=user&#37;&#52;&#48;mail&#46;es">–^user=user<span>&#64;</span>mail<span>&#46;</span>es</a> </dt><dd><p>–^password=pwd –^host=https://user.atlassian.net –^projectkey=PRJ</p>
</dd>
</dl>
<p>（将 ‘PRJ’ 项目的问题 11 的状态更新为“完成”。）</p>
<dl class="simple">
<dt>cm ^issuetracker jira ^status ^find “完成” <a class="reference external" href="mailto:--^user=user&#37;&#52;&#48;mail&#46;es">–^user=user<span>&#64;</span>mail<span>&#46;</span>es</a> –^password=pwd </dt><dd><p>–^host=https://user.atlassian.net –^projectkey=PRJ</p>
</dd>
</dl>
<p>（为 ‘PRJ’ 项目获取相应状态设置为“完成”的任务 ID）</p>
<dl class="simple">
<dt>cm ^issuetracker jira ^connection ^check <a class="reference external" href="mailto:--^user=user&#37;&#52;&#48;mail&#46;es">–^user=user<span>&#64;</span>mail<span>&#46;</span>es</a> –^password=pwd </dt><dd><p>–^host=https://user.atlassian.net –^projectkey=PRJ</p>
</dd>
</dl>
<p>（检查配置参数是否有效。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LICENSEINFO ==
显示许可证信息和许可证使用情况。</p>
<p>== CMD_USAGE_LICENSEINFO ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^licenseinfo | ^li [–^server=&lt;存储库服务器规格&gt;] [–^inactive] [–^active]</dt><dd><p>[–^sort=(^name|^status)]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^server            从指定的服务器获取许可证信息。</dt><dd><p>如果未指定服务器，则在客户端上配置的
服务器上执行命令。
（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
服务器规格。）</p>
</dd>
</dl>
<p>–^inactive          在“许可证使用情况”部分中仅显示非活动用户。
–^active            在“许可证使用情况”部分中仅显示活动用户。
–^sort              按指定的排序选项之一对用户进行排序：</p>
<blockquote>
<div><p>‘^name’ 或 ‘^status’。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_LICENSEINFO ==
备注：</p>
<blockquote>
<div><p>显示的信息包括到期日期、已激活的用户和
已停用的用户等。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^licenseinfo
cm ^licenseinfo –^server=myserver:8084
cm ^licenseinfo –^sort=^name</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LINKTASK ==
将变更集链接到任务。</p>
<p>== CMD_USAGE_LINKTASK ==
这是一个自动化命令，仅用于自动执行 ‘cm’。
此命令的用户友好度不如预期。</p>
<p>用法：</p>
<blockquote>
<div><p>cm ^linktask | ^lt &lt;变更集规格&gt; &lt;扩展前缀&gt; &lt;任务名称&gt;</p>
<dl class="simple">
<dt>变更集规格            要链接到任务的完整变更集规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集
规格。）</p>
</dd>
<dt>扩展前缀          要使用的已配置问题跟踪系统的</dt><dd><p>扩展前缀。</p>
</dd>
</dl>
<p>任务名称           问题跟踪系统上的任务标识符。</p>
</div></blockquote>
<p>== CMD_HELP_LINKTASK ==
示例：</p>
<blockquote>
<div><p>cm ^lt ^cs:<a class="reference external" href="mailto:8&#37;&#52;&#48;^rep">8<span>&#64;</span>^rep</a>:<a class="reference external" href="mailto:default&#37;&#52;&#48;^repserver">default<span>&#64;</span>^repserver</a>:localhost:8084 jira PRJ-1</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LOCK_LIST ==
显示服务器上的锁定情况。</p>
<p>== CMD_USAGE_LOCK_LIST ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^lock ^list | ^ls [&lt;修订规格 &gt; [ …]] [–^server=&lt;服务器&gt;]</dt><dd><p>[–^onlycurrentuser] [–^onlycurrentworkspace]
[–^ignorecase]</p>
</dd>
<dt>修订规格             如果存在一个或多个修订，则此命令将</dt><dd><p>为每个指定的修订显示一个锁定行
（如果在服务器中锁定了该修订的关联项）。否则，
此命令将列出默认服务器中的所有锁定项
（或者使用 ‘–^server’ 选项来设置的已锁定项）
使用多个修订规格时，使用空格对各个修订规格
进行分隔。
（使用 ‘cm ^help ^objectspec’ 可进一步了解修订规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^server                存储库服务器规格。</dt><dd><p>此选项将覆盖从当前工作区
或 client.conf 文件检索到的默认
服务器。
（使用 ‘cm ^help ^objectspec’ 可进一步了解
服务器规格。）</p>
</dd>
<dt>–^onlycurrentuser       筛选结果，仅显示当前用户</dt><dd><p>执行的锁定。</p>
</dd>
<dt>–^onlycurrentworkspace  筛选结果，仅显示对当前工作区</dt><dd><p>执行的锁定（按名称进行匹配）。</p>
</dd>
<dt>–^ignorecase            使用服务器路径规格时，忽略路径中的</dt><dd><p>大小写。使用此标志后，即使用户写入 “/sRc/fOO.c”，
该命令也将对 “/src/foo.c” 有效。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_LOCK_LIST ==
备注：</p>
<blockquote>
<div><p>该命令将列出默认服务器中当前
已锁定的项。该命令还接受若干修订规格；在这种
情况下，仅显示属于所选项的锁定。
可使用 ‘–^server=&lt;服务器&gt;’ 来设置要查询的默认服务器。</p>
<dl class="simple">
<dt>该命令针对指定服务器中的每个锁定都会显示一行：</dt><dd><ul class="simple">
<li><p>已锁定项的 GUID。</p></li>
<li><p>执行锁定的用户名。</p></li>
<li><p>锁定操作所在的工作区的名称。</p></li>
<li><p>锁定项的路径（服务器路径格式）。</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^lock ^list
cm ^lock ^list –^server=myserver:8084
cm ^lock ^ls ^serverpath:/src/foo.c#^cs:99&#64;default&#64;localhost:8084
cm ^lock ^list ^revid:<a class="reference external" href="mailto:3521&#37;&#52;&#48;default">3521<span>&#64;</span>default</a> ^itemid:<a class="reference external" href="mailto:2381&#37;&#52;&#48;secondary">2381<span>&#64;</span>secondary</a> –^onlycurrentuser
cm ^lock ^ls –^onlycurrentuser
cm ^lock ^ls –^onlycurrentuser –^onlycurrentworkspace</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LISTUSERS ==
列出用户和组。</p>
<p>== CMD_USAGE_LISTUSERS ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^listusers | ^lu &lt;存储库服务器规格&gt; [–^onlyusers] [–^onlygroups]</dt><dd><p>[–^filter= &lt;筛选器字符串&gt;]</p>
</dd>
<dt>存储库服务器规格       存储库服务器规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^onlyusers         仅列出用户。
–^onlygroups        仅列出组。
–^filter            仅列出匹配指定筛选器的用户</p>
<blockquote>
<div><p>和/或组。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_LISTUSERS ==
示例：</p>
<blockquote>
<div><p>cm ^lu localhost:8084
（列出服务器中的所有用户。）</p>
<p>cm ^listusers localhost:8084 –^onlyusers –^filter=m
（仅列出服务器中包含 “m” 的用户。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LOCATION ==
返回 ‘cm’ 的路径。</p>
<p>== CMD_USAGE_LOCATION ==
用法：</p>
<blockquote>
<div><p>cm ^location</p>
</div></blockquote>
<p>== CMD_HELP_LOCATION ==</p>
<p>== CMD_DESCRIPTION_LOCK ==
此命令允许用户管理锁定。</p>
<p>== CMD_USAGE_LOCK ==
用法：</p>
<blockquote>
<div><p>cm ^lock &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^list | ^ls
^unlock</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^lock &lt;命令&gt; –^usage
cm ^lock &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_LOCK ==
示例：</p>
<blockquote>
<div><p>cm ^lock ^list
cm ^lock
（如果没有参数，则 ‘^list’ 为可选项。）
cm ^lock ^ls ^serverpath:/src/foo.c#^cs:99&#64;default&#64;localhost:8084
cm ^lock ^unlock 91961b14-3dfe-4062-8c4c-f33a81d201f5</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LOG ==
获取有关变更集内的修订的信息。</p>
<p>== CMD_USAGE_LOG ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^log [&lt;变更集规格&gt; | &lt;存储库规格&gt;] [–^from=&lt;变更集规格起点&gt;] [–^allbranches]</dt><dd><p>[–^ancestors] [–^csformat=&lt;格式字符串&gt;] [–^itemformat=&lt;格式字符串&gt;]
[–^xml[=&lt;输出文件&gt;]] [–^encoding=&lt;名称&gt;]
[–^repositorypaths | –^fullpaths | –^fp]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>变更集规格            该命令将返回在相应规格的变更集内</dt><dd><p>所做的所有更改。
（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集
规格。）</p>
</dd>
<dt>存储库规格             该命令将列出在指定存储库中进行的</dt><dd><p>所有更改。
（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
规格。）</p>
</dd>
<dt>–^from              列出从变更集规格 [变更集规格起点]</dt><dd><p>到变更集规格 [变更集规格] 的每个变更集内
进行的所有更改。
[变更集规格起点] 变更集不包含在
输出中。
提供存储库规格后会忽略此选项。</p>
</dd>
<dt>–^allbranches       对于创建了相应变更集的所有分支，</dt><dd><p>显示指定时间间隔内创建的
这些变更集的相关信息。</p>
</dd>
<dt>–^ancestors         显示可通过给定变更集（[变更集规格]）的</dt><dd><p>父链接和合并链接来访问的变更集
的相关信息。如果也提供了起点
变更集（[变更集规格起点]），此变更集将用作
所有路径的下限。备注：使用此选项时，
不会显示变更集更改。</p>
</dd>
<dt>–^csformat          检索特定格式的变更集信息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
<dt>–^itemformat        检索特定格式的项信息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
<dt>–^xml               以 XML 格式将输出打印到标准输出。</dt><dd><p>可以指定输出文件。</p>
</dd>
<dt>–^encoding          与 ‘–^xml’ 选项结合使用，指定要在 XML 输出</dt><dd><p>中使用的编码（例如：utf-8）。
请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
<dt>–^fullpaths, –^fp   如果可能，强制打印文件和目录的完整</dt><dd><p>工作区路径。</p>
</dd>
<dt>–^repositorypaths   打印存储库路径（服务器路径）</dt><dd><p>而不是工作区路径。（此选项将覆盖
‘–^fullpaths’ 选项。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_LOG ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>如果“变更集规格”和选项均未指定，该命令将显示
每个分支中上个月内创建的每个变更集的
相关信息。</p></li>
<li><p>如果仅包含 ‘–^from’ 选项，该命令显示
在创建指定变更集的分支中从该变更集到最后一个
变更集的每个变更集的相关信息。</p></li>
<li><p>如果显示不带时间间隔的选项 ‘–^allbranches’，
该命令会检索与仅指定“变更集规格”时相同的
信息。</p></li>
<li><p>如果使用 ‘–^from’，输出包含从“变更集规格起点”+1 开始的
变更集的信息。</p></li>
<li><p>用于显示变更集信息的存储库就是在执行命令的
路径中加载的存储库。</p></li>
</ul>
<p>此命令接受项的格式字符串 (’–^itemformat’) 以及
变更集的格式字符串 (’–^csformat’)。</p>
<dl>
<dt>‘–^csformat’ 的输出参数如下：</dt><dd><p>{^tab}           插入一个制表符空格位。
{^newline}       插入一个新行。
{^changesetid}   变更集编号。
{^branch}        在其中创建变更集的分支。
{^date}          变更集的日期。
{^owner}         变更集的所有者。
{^comment}       变更集的注释。
{^items}         变更集内涉及的项。
{^repository}    变更集所在的存储库。
{^repserver}     服务器名称。</p>
</dd>
<dt>‘–^itemformat’ 的输出参数如下：</dt><dd><p>{^tab}           插入一个制表符空格位。
{^newline}       插入一个新行。
{^path}          项路径。
{^branch}        在其中创建变更集的分支。
{^date}          变更集的日期。
{^owner}         变更集的所有者。
{^shortstatus}   打印短格式。请参阅下文。
{^fullstatus}    打印长格式。请参阅下文。</p>
<dl class="simple">
<dt>短格式及其对应的长格式：</dt><dd><p>‘^A’   ^Added
‘^D’   ^Deleted
‘^M’   ^Moved
‘^C’   ^Changed</p>
</dd>
</dl>
</dd>
<dt>这些是有效的输出字符串：</dt><dd><p>–^csformat=”{^newline}变更集 {^changesetid} 创建于 {^date}；{^tab} 已更改项：{^items}。”
–^itemformat=”{^newline}分支 {^branch} 中的项 {^path} 已更改。”</p>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^log
（显示每个分支中上个月创建的每个变更集的相关
信息。）</p>
<p>cm ^log ^cs:16
（显示在其中创建变更集的分支内的变更集 16 中
所做更改的相关信息。）</p>
<dl class="simple">
<dt>cm ^log ^cs:16 –^csformat=”{^newline}变更集 {^changesetid} 创建于 </dt><dd><p>{^date}；{^tab} 已更改项：{^items}。”</p>
</dd>
</dl>
<p>（按指定格式显示此信息。）</p>
<p>cm ^log –^from=^cs:20 ^cs:50
（显示从变更集 21 到变更集 50 的每个变更集中包含的
每个修订的相关信息。）</p>
<p>cm ^log –^from=^cs:20 ^cs:50 –^allbranches
（显示存储库的每个分支中从变更集 21 到
变更集 50 的每个变更集中包含的每个修订的
相关信息。）</p>
<p>cm ^log ^rep:<a class="reference external" href="mailto:myrep&#37;&#52;&#48;localhost">myrep<span>&#64;</span>localhost</a>:8084
（显示在指定存储库中进行的更改的相关信息。
无需工作区也可运行此命令。）</p>
<p>cm ^log –^from=^cs:<a class="reference external" href="mailto:20&#37;&#52;&#48;^rep">20<span>&#64;</span>^rep</a>:<a class="reference external" href="mailto:mainRep&#37;&#52;&#48;localhost">mainRep<span>&#64;</span>localhost</a>:8084
（显示从变更集 21 开始的每个变更集内包含的每个修订
的相关信息。无需工作区也可运行此命令，因为
已指定完整变更集规格。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LS ==
列出树的内容。</p>
<p>== CMD_USAGE_LS ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^ls | ^dir [&lt;路径&gt;[ …]] [–^format=&lt;格式字符串&gt;] [–^symlink]</dt><dd><p>[–^selector[=&lt;选择器格式&gt;]] [–^tree=&lt;对象规格&gt;]
[-^R | -^r | –^recursive]
[–^xml[=&lt;输出文件&gt;]] [–^encoding=&lt;名称&gt;]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>路径               要显示的路径的列表。使用空格对各个路径进行</dt><dd><p>分隔。
使用双引号 (” “) 指定包含空格的
路径。</p>
</dd>
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
<dt>–^symlink           将操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
<dt>–^selector          从活动的工作区选择器获取内容。</dt><dd><p>如果已指定选择器格式，则列出
指定的选择器。
自 Plastic SCM 4.x 开始，选择器不再是 Plastic SCM
的重要特性，因此大多数情况下已弃用。</p>
</dd>
<dt>–^tree              列出指定变更集或分支中的树。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
<p>-^R                  以递归方式列出。
–^xml               以 XML 格式将输出打印到标准输出。</p>
<blockquote>
<div><p>可以指定输出文件。</p>
</div></blockquote>
<dl class="simple">
<dt>–^encoding          与 ‘–^xml’ 选项结合使用，指定要在 XML 输出</dt><dd><p>中使用的编码（例如：utf-8）。
请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_LS ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>可以使用元字符来键入路径。</p></li>
<li><p>此列表取决于工作区选择器。</p></li>
<li><p>可以指定格式字符串，从而将命令的输出格式化。</p></li>
<li><p>如果指定 ‘–^tree’ 或 ‘–^selector’ 选项，则给定的
路径必须是服务器路径（也就是：’cm path’）：/dir/file.txt，而不是
工作区路径：C:Usersmyusermywkdirfile.txt</p></li>
<li><p>如果未提供路径，则认为工作区路径是当前
目录。如果使用 ‘–^tree’ 或 ‘–^selector’ 选项，
则采用根路径 (“/”)。</p></li>
</ul>
<dl class="simple">
<dt>默认格式字符串为：</dt><dd><dl class="simple">
<dt>“{^size,10} {^date:dd/MM/yyyy} {^date:HH:mm}</dt><dd><p>{^type,-6} {^location,-12} {^checkout,-5} {^name}{^symlinktarget}”</p>
</dd>
</dl>
</dd>
</dl>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{^size}
{^formattedsize}
{^date}
{^type}</p>
<blockquote>
<div><p>^dir     目录，
^txt     文本文件，
^File    文件。</p>
</div></blockquote>
<p>{^location}      示例：^br:branch#cset
{^checkout}
{^name}
{^changeset}
{^path}
{^repspec}
{^owner}
{^revid}
{^parentrevid}
{^itemid}
{^brid}
{^repid}
{^server}
{^symlinktarget}
{^hash}
{^chmod}
{^wkpath}        相对于工作区根目录的路径
{^branch}
{^newlocation}   <a class="reference external" href="mailto:cset&#37;&#52;&#48;branch">cset<span>&#64;</span>branch</a>
{^guid}          （将需要更长时间来解析）
{^itemguid}
{^transformed}   显示已变换项的适用规则</p>
</div></blockquote>
<p>可以设置 PLASTIC_LS_FORMAT 环境变量以便自定义
‘^ls’ 格式。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^ls
cm ^ls c:workspacesrc</p>
<p>cm ^ls –^format={^name}
（仅文件名。）</p>
<p>cm ^ls –^symlink
（显示有关符号链接的信息，而不是“符号链接”的文件或
目录。适用于 UNIX 环境。）</p>
<p>cm ^ls code –^selector
（显示当前工作区选择器中 ‘code’ 子目录的
内容。）</p>
<p>cm ^ls /code –^selector=”^rep ‘myrep’ ^path ‘/’ ^branch ‘/^main’”
（显示指定选择器中 ‘/code’ 子目录的内容。
请注意，该路径是按服务器格式指定的。）</p>
<p>cm ^ls /code –^tree=44&#64;myrep&#64;denver:7070
（列出服务器 ‘denver:7070’ 存储库 ‘myrep’ 变更集 44 的
‘/code’ 子目录。）</p>
<p>cm ^ls /code –^tree=^br:/main/scm13596&#64;myrep&#64;denver:7070
（列出服务器 ‘denver:7070’ 存储库 ‘myrep’ 分支
‘/main/scm13596’ 中的最新变更集的 ‘/code’ 子目录。）</p>
<p>cm ^ls /code –^tree=ae1390ed-7ce9-4ec3-a155-e5a61de0dc77&#64;myrep&#64;denver:7070
（列出服务器 ‘denver:7070’ 存储库 ‘myrep’
的变更集 ae1390ed-7ce9-4ec3-a155-e5a61de0dc77 的
‘/code’ 子目录。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_TRIGGER_LIST ==
列出服务器上给定类型的触发器。</p>
<p>== CMD_USAGE_TRIGGER_LIST ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^trigger | ^tr ^list | ^ls [&lt;子类型-类型&gt;] [–^server=&lt;存储库服务器规格&gt;]</dt><dd><p>[–^format=&lt;格式字符串&gt;]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>子类型-类型        触发器执行和触发器操作。</dt><dd><p>键入 ‘cm ^showtriggertypes’ 可查看触发器类型
列表。</p>
</dd>
<dt>–^server            列出指定服务器上的触发器。</dt><dd><p>如果未指定服务器，则在客户端上配置的
服务器上执行命令。
（使用 ‘cm ^help ^objectspec’ 可进一步了解服务器
规格。）</p>
</dd>
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_TRIGGER_LIST ==
备注：</p>
<blockquote>
<div><p>如果未指定类型，则列出服务器上的所有触发器。</p>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{0}             触发器位置。
{1}             触发器名称。
{2}             触发器路径。
{3}             触发器所有者。
{4}             触发器类型。
{5}             触发器筛选器。</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^trigger list after-mklabel
cm ^tr ^ls ^before-mkbranch –^server=myserver:8084</p>
</dd>
</dl>
<p>== CMD_DESCRIPTION_MANIPULATESELECTOR ==
将选择器更改为日期。</p>
<p>== CMD_USAGE_MANIPULATESELECTOR ==
这是一个自动化命令，仅用于自动执行 ‘cm’。
此命令的用户友好度不如预期。</p>
<p>用法：</p>
<blockquote>
<div><p>cm ^manipulateselector | ^ms [&lt;工作区路径&gt; | &lt;工作区规格&gt;] –^atdate=&lt;选择器日期&gt;</p>
<p>工作区路径             工作区的路径。
工作区规格             工作区的规格。（使用 ‘cm ^help ^objectspec’ 可</p>
<blockquote>
<div><p>进一步了解规格。）</p>
</div></blockquote>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^atdate            返回一个选择器以用于重新创建工作区，</dt><dd><p>就像在指定日期看到的工作区一样。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_MANIPULATESELECTOR ==
备注：</p>
<blockquote>
<div><p>如果路径和工作区规格均未指定，则该命令将采用
当前目录作为工作区路径。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^manipulateselector c:workspace –^atdate=yyyy-MM-ddTHH:mm:ss
cm ^manipulateselector –^atdate=yyyy-MM-ddTHH:mm:ss
cm ^manipulateselector &gt; mySelector.txt –^atdate=yyyy-MM-ddTHH:mm:ss
cm ^manipulateselector ^wk:build_wk&#64;BUILDER –^atdate=yyyy-MM-ddTHH:mm:ss</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_MERGE ==
将一个分支与另一个分支合并。</p>
<p>== CMD_USAGE_MERGE ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^merge &lt;源规格&gt; [–^merge] [–^cherrypicking] [–^forced]</dt><dd><p>[–^mergetype=(^onlyone|^onlysrc|^onlydst|^try|^forced)]
[–^interval-origin=&lt;变更集规格&gt; | –^ancestor=&lt;变更集规格&gt;]
[–^keepsource | –^ks] [–^keepdestination | –^kd]
[–^automaticresolution=&lt;冲突类型&gt;[;…]]
[–^subtractive] [–^mount] [–^printcontributors]
[–^noprintoperations] [–^silent]
[(–^to=&lt;分支规格&gt; | –^destination=&lt;分支规格&gt;)[–^shelve]]
[–^no-dst-changes]
[-^c=&lt;注释字符串&gt; | –^commentsfile=&lt;注释文件&gt;]
[–^resolveconflict –^conflict=&lt;索引&gt;
–^resolutionoption=(^src|^dst|(^rename –^resolutioninfo=&lt;字符串名称&gt;))
–^mergeresultfile=&lt;路径&gt; –^solvedconflictsfile=&lt;路径&gt;]
[–^nointeractiveresolution]
[–^machinereadable [–^startlineseparator=&lt;分隔符&gt;]</p>
<blockquote>
<div><p>[–^endlineseparator=&lt;分隔符&gt;] [–^fieldseparator=&lt;分隔符&gt;]]</p>
</div></blockquote>
</dd>
<dt>源规格           要合并的源对象的规格：</dt><dd><ul class="simple">
<li><p>分支规格：’[^br:/]br_name’</p></li>
<li><p>标签规格：’^lb:lb_name’</p></li>
<li><p>变更集规格：’^cs:cs_number’</p></li>
<li><p>搁置规格：’^sh:shelve_number’</p></li>
</ul>
<p>（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^merge                   执行合并。否则，打印找到的</dt><dd><p>冲突。</p>
</dd>
<dt>–^cherrypicking           合并源变更集内包含的</dt><dd><p>变更。如果合并源规格是标签，
则不会使用此选项。</p>
</dd>
<dt>–^forced                  不检查源和目标是否</dt><dd><p>已连接。
此选项仅可用于间隔合并
和挑拣。</p>
</dd>
</dl>
<p>–^mergetype               请参阅“备注”以了解更多信息。
–^interval-origin         指定将哪个变更集选为</p>
<blockquote>
<div><p>间隔原点，以便合并仅考虑
源变更集与指定间隔原点
之间的差异。</p>
</div></blockquote>
<p>–^ancestor                这是 –^interval-origin 的别名。
–^keepsource              对于有冲突的项，接受源参与者</p>
<blockquote>
<div><p>的所有更改。</p>
</div></blockquote>
<dl class="simple">
<dt>–^keepdestination         对于有冲突的项，保留目标参与者</dt><dd><p>的更改。</p>
</dd>
<dt>–^automaticresolution     用于解决目录冲突。此选项</dt><dd><p>可让您决定应该自动选择
源参与者还是目标参与者
来解决冲突。
使用分号对各个冲突类型进行分隔。
请参阅“备注”以了解更多信息。</p>
</dd>
<dt>–^subtractive             删除由合并引入的更改。传递给</dt><dd><p>命令的参数（源规格）用于
指定要删除哪个源的
更改。必须是变更集。如果是变更集
间隔，必须使用 ‘–^interval-origin’ 来
定义间隔原点。为了删除更改，
系统将创建一个新的已签出修订，
该修订将具有上一个
修订的内容（不包含已删除的更改）。</p>
</dd>
</dl>
<p>–^mount                   给定存储库的装入点。
–^printcontributors       打印参与者（基项、源和</p>
<blockquote>
<div><p>目标）。</p>
</div></blockquote>
<dl class="simple">
<dt>–^noprintoperations       以静默方式解决合并问题，</dt><dd><p>不显示有关解决情况的信息。</p>
</dd>
</dl>
<p>–^silent                  不显示任何输出。
–^to | –^destination      对指定分支执行“合并到”操作</p>
<blockquote>
<div><p>（通过输入分支规格）
并完全解决冲突。
“合并到”（或无工作区的合并）是在
服务器端进行的合并。正常的合并
发生在“从”分支、标签或变更集合并的
工作区上，而“合并到”完全发生
在服务器上。在正常合并中，
“目标”是工作区，而在“合并到”中，
必须始终指定目标（这就是称之为
“到”的原因）。
请查看以下链接以了解关于
“合并到”功能的更多信息：
<a class="reference external" href="https://www.plasticscm.com/download/help/mergeto">https://www.plasticscm.com/download/help/mergeto</a></p>
</div></blockquote>
<dl class="simple">
<dt>–^shelve                  使用合并结果的更改（加上合并</dt><dd><p>可追溯性信息）来创建一个搁置，
而不是创建新的变更集。合并源为
搁置时，此选项不可用。该选项
仅可用于服务器端合并
（又称为“合并到”）。因此，需要 ‘–^to’ 和
‘–^merge’ 选项。</p>
</dd>
<dt>–^no-dst-changes          确保目标参与者不具有</dt><dd><p>更改（目标变更集也是
共同上级）。目标上存在更改时，
不允许合并。</p>
</dd>
<dt>-^c                        将指定的注释应用于合并操作中</dt><dd><p>创建的变更集。</p>
</dd>
<dt>–^commentsfile            将指定文件中的注释应用于合并操作中</dt><dd><p>创建的变更集。</p>
</dd>
<dt>–^resolveconflict         （主要由插件使用。请参阅“备注”以了解更多信息。）</dt><dd><p>用于解决目录冲突。</p>
</dd>
<dt>–^conflict                与 ‘–^resolveconflict’ 标志结合使用，指定</dt><dd><p>要解决的冲突的索引（从 1 开始）。</p>
</dd>
<dt>–^resolutionoption        与 ‘–^resolveconflict’ 标志结合使用，指示</dt><dd><p>冲突解决类型。使用以下
选项之一：’^src’、’^dst’、’^rename’。
请参阅“备注”以了解更多信息。</p>
</dd>
<dt>–^resolutioninfo          与 ‘–^resolveconflict’ 标志结合使用，提供在</dt><dd><p>‘–^resolutionoption’ 选项为 ‘rename’ 时
要使用的名称。</p>
</dd>
<dt>–^mergeresultfile         与 ‘–^resolveconflict’ 标志结合使用，将</dt><dd><p>不同调用之间的合并结果的信息
输出到文件中。指定的路径将在第一次
调用期间创建，并在每个后续
调用时更新。</p>
</dd>
<dt>–^solvedconflictsfile     与 ‘–^resolveconflict’ 标志结合使用，</dt><dd><p>将不同调用之间已解决的冲突
的信息输出到文件中。指定的路径
将在第一次调用期间创建，并在每个
后续调用时更新。</p>
</dd>
<dt>–^nointeractiveresolution （主要由插件使用。请参阅“备注”以了解更多信息。）</dt><dd><p>避免提示用户已发生手动冲突。
这样就不会解决目录冲突。</p>
</dd>
<dt>–^machinereadable         （主要由插件使用。请参阅“备注”以了解更多信息。）</dt><dd><p>以易于解析的格式输出结果。</p>
</dd>
<dt>–^startlineseparator      与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>行应如何开头。（默认值：空字符串。）</p>
</dd>
<dt>–^endlineseparator        与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>行应如何结尾。（默认值：空字符串。）</p>
</dd>
<dt>–^fieldseparator          与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>应如何分隔字段。（默认值：
空格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_MERGE ==
备注：</p>
<blockquote>
<div><p>此命令用于合并两个分支之间或标签与
分支之间的更改。合并的目标必须始终为分支。
合并源将指定为参数。
目标是工作区的当前内容。
例如，要显示从分支 task001 合并到主分支
的元素，选择器必须指向主分支，
工作区必须完成更新，然后：</p>
<blockquote>
<div><p>cm ^merge ^br:/task001</p>
</div></blockquote>
<dl class="simple">
<dt>添加 ‘–^merge’ 选项来切实执行合并：</dt><dd><p>cm ^merge ^br:/task001 –^merge</p>
</dd>
</dl>
<p>要定义合并源，可以使用以下规格：</p>
<ul class="simple">
<li><dl class="simple">
<dt>分支规格：</dt><dd><p>[^br:/]br_name
示例：^br:/main/task001
（以上示例从此分支上的最后一个变更集执行合并。）</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>标签规格：</dt><dd><p>^lb:lb_name
示例：^lb:BL001
（从标记的变更集合并。）</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>变更集规格：</dt><dd><p>^cs:cs_number
示例：^cs:25
（从给定的变更集内容合并。）</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>搁置规格：</dt><dd><p>^sh:shelve_number
示例：^sh:2
（从给定的搁置内容合并。）</p>
</dd>
</dl>
</li>
</ul>
<p>要自动解决目录冲突，请使用 ‘–^automaticresolution’
选项并指定冲突类型，然后指定在合并操作
期间必须选择的参与者（源或目标）。
（使用分号 (;) 对各个“冲突类型”-“参与者”对进行分隔。）
例如：</p>
<blockquote>
<div><p>cm ^merge ^cs:2634 –^merge –^automaticresolution=^eviltwin-src;^changedelete-src
（自变更集 2634 开始的合并操作将会解决 “^eviltwin” 和
“^changedelete” 冲突，解决方法是在两种情况下保留源 (“-^src”)
参与者）。</p>
</div></blockquote>
<ul class="simple">
<li><p>冲突类型之后的 “-^src” 后缀告诉合并命令保留
源参与者更改。</p></li>
<li><p>“-^dst” 后缀将保留目标参与者更改。</p></li>
</ul>
<dl class="simple">
<dt>以下是合并命令支持的冲突类型的列表：</dt><dd><p>“^movedeviltwin”、”^eviltwin”、”^changedelete”、”^deletechange”、”^movedelete”、
“^deletemove”、”^loadedtwice”、”^addmove”、”^moveadd”、”^divergentmove”、
“^cyclemove”、”^all”。</p>
</dd>
</dl>
<p>“^all” 值会覆盖其他选项。在以下示例中，
“^eviltwin-dst” 将被忽略：</p>
<blockquote>
<div><p>cm ^merge ^br:/main/task062 –^merge –^automaticresolution=^all-src;^eviltwin-dst</p>
</div></blockquote>
<p>请查看以下链接以了解关于合并冲突的更多信息：
<a class="reference external" href="https://www.plasticscm.com/download/help/directorymerges">https://www.plasticscm.com/download/help/directorymerges</a></p>
<dl>
<dt>以下是 ‘–^mergetype’ 的选项：</dt><dd><dl class="simple">
<dt>^onlyone         仅有一个参与者修改了该项的情况下，才进行</dt><dd><p>自动合并。</p>
</dd>
<dt>^onlysrc         仅有一个源参与者修改了该项的情况下，才进行</dt><dd><p>自动合并。</p>
</dd>
<dt>^onlydst         仅有一个目标参与者修改了该项的情况下，才进行</dt><dd><p>自动合并。</p>
</dd>
<dt>^try             仅有一个参与者修改了冲突代码段（每个冲突）</dt><dd><p>的情况下，才进行自动合并。</p>
</dd>
</dl>
<p>^forced          始终尝试解决所有非自动冲突。</p>
</dd>
<dt>以下是主要由插件和集成使用的选项：</dt><dd><ul>
<li><p>‘–^resolveconflict’，用于解决目录冲突。还必须使用
以下选项：</p>
<blockquote>
<div><ul>
<li><p>‘–^conflict’ 是要解决的冲突的索引
（从 1 开始）。</p></li>
<li><dl>
<dt>‘–^resolutionoption’ 指示要使用的冲突解决</dt><dd><dl>
<dt>方法。选项可以是：</dt><dd><ul>
<li><p>‘^src’，用于保留源更改而放弃
目标更改</p></li>
<li><p>‘^dst’，用于保留目标更改而放弃
源更改</p></li>
<li><p>‘^rename’（仅在冲突类型支持此解决方法
的情况下），用于将目标重命名为
通过 ‘–^resolutioninfo’ 选项提供的给定名称。</p>
<blockquote>
<div><ul class="simple">
<li><p>‘–^resolutioninfo’，用于提供在 ‘^rename’ 解决
方法中使用的名称</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><p>‘–^mergeresultfile’ 和 ‘–^solvedconflictsfile’，这两者用于
存储不同调用之间的合并信息。</p></li>
</ul>
</div></blockquote>
</li>
<li><p>‘–^nointeractiveresolution’ 指示合并操作不要求用户
进行手动冲突解决。</p></li>
<li><p>‘–^machinereadable’ 和 ‘–^startlineseparator’、’–^endlineseparator’、
‘–^fieldseparator’ 选项，用于以机器可读的方式
（易于解析）打印输出。</p></li>
</ul>
<p>示例：
cm ^merge –^machinereadable –^startlineseparator=start&#64;_&#64;line </p>
<blockquote>
<div><p>–^endlineseparator=new&#64;_&#64;line –^fieldseparator=def#_#sep –^mergeresultfile=C:UsersBorjaAppDataLocalTemp2tmp4D6C.tmp –^solvedconflictsfile=C:UsersBorjaAppDataLocalTemp2tmp4D6D.tmp –^resolveconflict –^conflict=1 –^resolutionoption=rename  –^resolutioninfo=bin_dst ^br:/main/task –^merge</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^merge ^br:/task001
（不合并，仅打印要合并的项。）</p>
<p>cm ^merge ^br:/task001 –^merge
（从分支 ‘task001’ 进行合并。）</p>
<p>cm ^merge ^cs:5 –^merge –^cherrypicking –^interval-origin=^cs:2
（从变更集间隔 (2,5] 进行挑拣。）</p>
<p>cm ^merge ^cs:8 –^merge –^subtractive –^keepdestination
（从变更集 8 进行减法合并，保留那些有冲突的
元素的目标更改。）</p>
<p>cm ^merge ^br:/main/task001 –^to=^br:/main –^merge -^c=”集成的新 UI”
（进行从分支 ‘task001’ 到分支 ‘main’ 的服务器端合并
（又称为“合并到”），并设置注释。）</p>
<p>cm ^merge ^br:/main/task001 –^to=^br:/main –^merge –^shelve
（进行从分支 ‘task001’ 到分支 ‘main’ 的服务器端合并，
并将结果保留在搁置中。）</p>
<p>cm ^merge ^sh:2 –^to=^br:/main –^merge –^no-dst-changes
（仅在从当前的 ‘main’ 头部创建时，才将搁置 2
应用于 ‘main’）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ATTRIBUTE_CREATE ==
创建新的属性。</p>
<p>== CMD_USAGE_ATTRIBUTE_CREATE ==
用法：</p>
<blockquote>
<div><p>cm ^attribute | ^att ^create | ^mk &lt;属性名&gt;</p>
<p>属性名            属性名称</p>
</div></blockquote>
<p>== CMD_HELP_ATTRIBUTE_CREATE ==
示例：</p>
<blockquote>
<div><p>cm ^attribute ^create 状态
（创建属性 ‘状态’。）</p>
<p>cm ^att ^mk 集成
（创建属性 ‘集成’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_BRANCH ==
允许用户管理分支。</p>
<p>== CMD_USAGE_BRANCH ==
用法：</p>
<blockquote>
<div><p>cm ^branch | ^br &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^create | ^mk
^delete | ^rm
^rename
^history
^showmain
^showmerges</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^branch &lt;命令&gt; –^usage
cm ^branch &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_BRANCH ==
示例：</p>
<blockquote>
<div><p>cm ^branch /main/scm21345
cm ^branch ^create /main/scm21345
cm ^branch ^delete /main/scm21345
cm ^branch ^rename /main/scm21345 scm21346
cm ^branch ^history /main/scm21345
cm ^branch ^showmain
cm ^branch ^showmerges file.txt</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_BRANCH_CREATE ==
创建新的分支。</p>
<p>== CMD_USAGE_BRANCH_CREATE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^branch | ^br [^create | ^mk] &lt;分支规格&gt;</dt><dd><p>[–^changeset=&lt;变更集规格&gt; | –^label=&lt;标签规格&gt;]
[-^c=&lt;注释字符串&gt; | -^commentsfile=&lt;注释文件&gt;]</p>
</dd>
<dt>分支规格         新分支名称或规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解分支规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^changeset     用作新分支的起点的变更集。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集规格。）</p>
</dd>
<dt>–^label         用作新分支的起点的标签。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解标签规格。）</p>
</dd>
<dt>-^c              用指定的文本填充新分支的“注释”</dt><dd><p>字段。</p>
</dd>
<dt>-^commentsfile   用指定文件的内容填充新分支的“注释”</dt><dd><p>字段。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_BRANCH_CREATE ==
备注：</p>
<blockquote>
<div><p>要创建顶级分支，请指定不含任何层次结构的名称。
例如：</p>
<blockquote>
<div><p>cm ^br /dev</p>
</div></blockquote>
<p>如果未指定可选参数 ‘–^changeset’，新分支的基项
将是父分支上的最后一个变更集。如果新分支
是顶级分支，则使用的基础变更集将为变更集 0。</p>
<p>可以使用 ‘-^c’ 或 ‘-^m’ 开关来指定注释：</p>
<blockquote>
<div><p>cm ^branch /main/task001 -^c=”这是注释”
cm ^branch /main/task001 -^m “这是注释”</p>
</div></blockquote>
<p>设置 PLASTICEDITOR 环境变量可指定用于输入注释的
编辑器。如果已设置 PLASTICEDITOR 环境变量，
并且注释为空，则会自动启动编辑器
以用于指定注释。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^branch task001
cm ^branch ^create task001
cm ^branch ^mk task001
cm ^br ^mk task001
（在当前工作区的存储库中创建顶级分支
‘task001’。）</p>
<p>cm ^branch ^br:/task001/task002&#64;
（创建 ‘task002’ 分支作为 ‘task001’ 的子级。）</p>
<p>cm ^br /main/task001&#64;myrep&#64;myserver:8084 -^c=”我的注释”
（在存储库 <a class="reference external" href="mailto:'myrep&#37;&#52;&#48;myserver">‘myrep<span>&#64;</span>myserver</a>:8084’ 中，创建 ‘task001’ 分支
作为 ‘main’ 的子级，并包含注释 ‘我的注释’。）</p>
<p>cm ^branch ^br:/main/task001 –^changeset=2837 -^commentsfile=commenttask001.txt
（创建 ‘task001’ 分支作为 ‘main’ 的子级，基础变更集 ‘changeset=2837’，
并应用 ‘commenttask001.txt’ 文件中的注释。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_BRANCH_DELETE ==
删除一个或多个分支。</p>
<p>== CMD_USAGE_BRANCH_DELETE ==
用法：</p>
<blockquote>
<div><p>cm ^branch | ^br ^delete | ^rm &lt;分支规格&gt;[ …]</p>
<dl class="simple">
<dt>分支规格              要删除的分支。使用空格对各个分支进行分隔。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解分支
规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_BRANCH_DELETE ==
备注：</p>
<blockquote>
<div><p>此命令将删除一个或多个分支。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^branch ^delete /main/task001
（在当前工作区的存储库中删除名为 ‘task001’ 分支
（’main’ 的子级）。）</p>
<p>cm ^br ^rm main/task002 /main/task012&#64;reptest&#64;myserver:8084
（删除当前工作区的存储库中的分支 ‘/main/task002
以及存储库 <a class="reference external" href="mailto:'reptest&#37;&#52;&#48;myserver">‘reptest<span>&#64;</span>myserver</a>:8084’ 中的分支 ‘/main/task012’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_BRANCH_RENAME ==
重命名分支。</p>
<p>== CMD_USAGE_BRANCH_RENAME ==
用法：</p>
<blockquote>
<div><p>cm ^branch | ^br ^rename &lt;分支规格&gt; &lt;新名称&gt;</p>
<dl class="simple">
<dt>分支规格          要重命名的分支。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解分支规格。）</p>
</dd>
</dl>
<p>新名称        分支的新名称。</p>
</div></blockquote>
<p>== CMD_HELP_BRANCH_RENAME ==
备注：</p>
<blockquote>
<div><p>此命令将重命名分支。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^branch ^rename /main/task0 task1
（将分支 ‘/main/task0’ 重命名为 ‘/main/task1’。）</p>
<p>cm ^br ^rename ^br:/main&#64;reptest&#64;server2:8084 secondary
（将存储库 ‘reptest’ 的 ‘main’ 分支重命名为 ‘secondary’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_BRANCH_HISTORY ==
显示分支的历史记录。</p>
<p>== CMD_USAGE_BRANCH_HISTORY ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^branch | ^br ^history &lt;分支规格&gt; [–^dateformat=&lt;日期格式&gt;]</dt><dd><p>[–^machinereadable]</p>
</dd>
<dt>分支规格          用于获取历史记录的分支规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解分支规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^dateformat            用于输出日期的格式。
–^machinereadable       以易于解析的格式输出结果。</p>
</div></blockquote>
<p>== CMD_HELP_BRANCH_HISTORY ==
示例：</p>
<blockquote>
<div><p>cm ^branch ^history ^br:/main/scm001&#64;myrepository&#64;myserver:8084
（显示 ‘myserver’ 服务器中的 ‘myrepository’ 存储库的 ‘/main/scm001’
分支的历史记录。）</p>
<p>cm ^br ^history main –^dateformat=”yyyy, dd MMMM” –^machinereadable
（以给定的日期格式和易于解析的格式，显示当前
存储库的 ‘main’ 分支的历史记录。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_BRANCH_SHOWMAIN ==
显示存储库的主分支。
这是一个自动化命令，仅用于自动执行 ‘cm’。
存储库的主分支很有可能是 ‘/main’。</p>
<p>== CMD_USAGE_BRANCH_SHOWMAIN ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^branch | ^br ^showmain [&lt;存储库规格&gt;] [–^encoding=&lt;名称&gt;]</dt><dd><p>[–^format=&lt;格式字符串&gt;] [–^dateformat=&lt;日期格式&gt;]</p>
</dd>
<dt>存储库规格             要显示分支的存储库</dt><dd><p>规格。
（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^encoding          指定输出中使用的编码，</dt><dd><p>如：utf-8。
请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
<p>–^dateformat        用于输出日期的格式。</p>
</div></blockquote>
<p>== CMD_HELP_BRANCH_SHOWMAIN ==
备注：</p>
<blockquote>
<div><p>此命令将显示存储库的主分支。</p>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{^id}                分支 ID。
{^comment}           注释。
{^date}              日期。
{^name}              名称。
{^owner}             所有者。
{^parent}            父分支名称。
{^repository}        存储库。
{^repname}           存储库名称。
{^repserver}         服务器。
{^changeset}         分支的头部变更集。</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^branch ^showmain
（显示当前工作区的存储库的主分支。）</p>
<p>cm ^branch ^showmain <a class="reference external" href="mailto:repo&#37;&#52;&#48;server">repo<span>&#64;</span>server</a>:8084
（显示服务器 ‘server:8084’ 中的存储库 ‘repo’ 的
主分支。）</p>
<p>cm ^br ^showmain –^dateformat=”yyyy, dd MMMM” –^encoding=utf8
（以给定日期格式显示存储库的主分支，
输出编码为 utf8。）</p>
<p>cm ^br ^showmain –^format=”{^id} - {^name}”
（显示存储库的主分支，仅打印其 ID 和名称。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_BRANCH_SHOWMERGES ==
显示待合并的分支。</p>
<p>== CMD_USAGE_BRANCH_SHOWMERGES ==
这是一个自动化命令，仅用于自动执行 ‘cm’。
此命令的用户友好度不如预期。</p>
<p>用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^branch | ^br ^showmerges &lt;项路径&gt;[ …]</dt><dd><p>[–^format=&lt;格式字符串&gt;]
[–^dateformat=&lt;日期格式&gt;]</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>选项：</dt><dd><dl class="simple">
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
<p>–^dateformat        用于输出日期的格式。</p>
</dd>
</dl>
<p>== CMD_HELP_BRANCH_SHOWMERGES ==
备注：</p>
<blockquote>
<div><p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{^id}                分支 ID。
{^comment}           注释。
{^date}              日期。
{^name}              名称。
{^owner}             所有者。
{^parent}            父分支名称。
{^parentid}          父分支 ID。
{^repid}             存储库 ID。
{^repository}        存储库。
{^repname}           存储库名称。
{^repserver}         存储库服务器。</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^branch ^showmerges file.txt
（显示 ‘file.txt’ 的待定合并中涉及的分支。）</p>
<p>cm ^branch ^showmerges file.txt –^format=”{^date} {^name}” –^dateformat=”yyMMdd”
（显示合并中涉及的分支，仅以给定的日期格式打印
日期和名称。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REPOSITORY ==
允许用户管理存储库。</p>
<p>== CMD_USAGE_REPOSITORY ==
用法：</p>
<blockquote>
<div><p>cm ^repository | ^repo &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^create | ^mk
^delete | ^rm
^list   | ^ls
^rename
^add</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^repository &lt;命令&gt; –^usage
cm ^repository &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_REPOSITORY ==
示例：</p>
<blockquote>
<div><p>cm ^repository
cm ^repository ^list
cm ^repository 新存储库
cm ^repository ^create 新存储库
cm ^repository ^rename 旧名称 新名称
cm ^repository ^add C:repo</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REPOSITORY_CREATE ==
在服务器上创建存储库。</p>
<p>== CMD_USAGE_REPOSITORY_CREATE ==
用法：</p>
<blockquote>
<div><p>cm ^repository | ^repo &lt;存储库名称&gt;
cm ^repository | ^repo &lt;存储库服务器规格&gt; &lt;存储库名称&gt;[ …]
cm ^repository | ^repo [^create | ^mk] &lt;存储库名称&gt;</p>
<dl class="simple">
<dt>存储库服务器规格       存储库服务器规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
服务器规格。）</p>
</dd>
<dt>存储库名称            一个或多个新存储库的名称。</dt><dd><p>使用空格对各个存储库名称进行分隔。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_REPOSITORY_CREATE ==
示例：</p>
<blockquote>
<div><p>cm ^repository MyRep
cm ^repo 192.168.1.140:8087 Rep01 Rep01/ModuleA Rep01/ModuleB
cm ^repo ^create Rep01
cm ^repo ^mk 列表</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REPOSITORY_DELETE ==
从服务器删除存储库。</p>
<p>== CMD_USAGE_REPOSITORY_DELETE ==
用法：</p>
<blockquote>
<div><p>cm ^repository | ^repo ^delete | ^rm &lt;存储库规格&gt;</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>存储库规格            存储库的规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_REPOSITORY_DELETE ==
备注：</p>
<blockquote>
<div><p>从存储库服务器删除存储库。
不会从数据库后端删除数据，而是会断开，
因此将无法再进行访问。
（以后可以重新连接数据，请参阅 ‘cm ^repository ^add’。）</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^repository ^delete <a class="reference external" href="mailto:myrepository&#37;&#52;&#48;^repserver">myrepository<span>&#64;</span>^repserver</a>:myserver:8084
cm ^repository ^rm myrepository&#64;myserver:8084
cm ^repo ^rm myrepository</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REPOSITORY_LIST ==
列出服务器上的存储库。</p>
<p>== CMD_USAGE_REPOSITORY_LIST ==
用法：</p>
<blockquote>
<div><p>cm ^repository | ^repo [^list | ^ls] [&lt;存储库服务器规格&gt;] [–^format=&lt;格式字符串&gt;]</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>存储库服务器规格       存储库服务器规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
服务器规格。）</p>
</dd>
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_REPOSITORY_LIST ==
备注：</p>
<blockquote>
<div><p>此命令接受格式字符串以显示输出。</p>
<p>此命令的输出参数如下：</p>
<blockquote>
<div><p>{^repid}     | {0}           存储库标识符。
{^repname}   | {1}           存储库名称。
{^repserver} | {2}           服务器名称。
{^repowner}  | {3}           存储库所有者。
{^repguid}   | {4}           存储库的唯一标识符。
{^tab}                       插入一个制表符空格位。
{^newline}                   插入一个新行。</p>
</div></blockquote>
<p>如果格式参数值为 ‘^TABLE’，则会使用具有 {^repid}、
{^repname} 和 {^repserver} 字段的表格式来打印输出。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^repository
（列出所有存储库。）</p>
<p>cm ^repository ^list localhost:8084 –^format=”{1, -20} {3}”
（将存储库名称写入 20 个空格位，左对齐，然后留一个空白，
再然后是存储库所有者。）</p>
<p>cm ^repository ^ls localhost:8084 –^format=”{^repname, -20} {^repowner}”
（写入方式与前一个示例相同。）</p>
<p>cm ^repo ^ls localhost:8084 –^format=^TABLE
（使用具有以下字段的表格式来写入存储库列表：
存储库 ID、存储库名称和存储库服务器名称。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REPOSITORY_RENAME ==
重命名存储库。</p>
<p>== CMD_USAGE_REPOSITORY_RENAME ==
用法：</p>
<blockquote>
<div><p>cm ^repository | ^repo ^rename [&lt;存储库规格&gt;] &lt;新名称&gt;</p>
<dl class="simple">
<dt>存储库规格             要重命名的存储库。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
规格。）</p>
</dd>
</dl>
<p>新名称            存储库的新名称。</p>
</div></blockquote>
<p>== CMD_HELP_REPOSITORY_RENAME ==
备注：</p>
<blockquote>
<div><p>此命令将重命名存储库。
如果未指定存储库规格，则会采用当前存储库。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^repository ^rename development
（将当前存储库重命名为 ‘development’。）</p>
<p>cm ^repo ^rename ^rep:<a class="reference external" href="mailto:default&#37;&#52;&#48;SERVER">default<span>&#64;</span>SERVER</a>:8084 development
（将 ‘SERVER’ 上的 ‘default’ 存储库重命名为 ‘development’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REPOSITORY_ADD ==
通过添加现有存储库的数据库来连接此存储库。</p>
<p>== CMD_USAGE_REPOSITORY_ADD ==
用法：</p>
<blockquote>
<div><p>cm ^repository | ^repo ^add &lt;数据库文件&gt; &lt;存储库名称&gt; &lt;存储库服务器规格&gt;</p>
<p>数据库文件             数据库后端上的数据库文件的名称。
存储库名称            存储库的名称。
存储库服务器规格       存储库服务器规格。</p>
<blockquote>
<div><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
服务器规格。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_REPOSITORY_ADD ==
备注：</p>
<blockquote>
<div><p>将现有存储库数据库重新连接到服务器。
示例：使用 ‘cm ^repository ^delete’ 命令后，使用 ‘^add’ 命令
将存储库从一个服务器移动到另一个服务器或还原
已存档的存储库。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^repository ^add rep_27 myrepository myserver:8084</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_TRIGGER_CREATE ==
在服务器上创建新触发器。</p>
<p>== CMD_USAGE_TRIGGER_CREATE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^trigger | ^tr ^create | ^mk &lt;子类型-类型&gt; &lt;新名称&gt; &lt;脚本路径&gt;</dt><dd><p>[–^position=&lt;新位置&gt;]
[–^filter=&lt;筛选器字符串&gt;]
[–^server=&lt;存储库服务器规格&gt;]</p>
</dd>
<dt>子类型-类型        触发器执行和触发器操作。</dt><dd><p>键入 ‘cm ^showtriggertypes’ 可查看触发器类型
列表。</p>
</dd>
</dl>
<p>新名称            新触发器的名称。
脚本路径         服务器上包含要执行的脚本的</p>
<blockquote>
<div><p>磁盘路径。如果命令行以 “^webtrigger “ 开头，
则认为此触发器是 Web 触发器。请参阅
“备注”以了解更多信息。</p>
</div></blockquote>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^position          指定触发器的新位置。</dt><dd><p>此位置不能正在由相同类型的另一个
触发器使用。</p>
</dd>
</dl>
<p>–^filter            仅检查与指定筛选器匹配的项。
–^server            在指定服务器上创建触发器。</p>
<blockquote>
<div><p>如果未指定服务器，则在客户端上配置的
服务器上执行命令。
（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
服务器规格。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_TRIGGER_CREATE ==
备注：</p>
<blockquote>
<div><p>Web 触发器：创建 Web 触发器的方法是键入 “^webtrigger &lt;目标-URI&gt;”
作为触发器命令。在这种情况下，触发器将针对指定的 URI
执行 POST 查询，其中，请求主体包含带有触发器
环境变量的 JSON 字典，还有一个指向字符串数组的
固定 INPUT 键。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^trigger ^create ^after-setselector “BackupMgr” “/path/to/script” –^position=4</p>
<p>cm ^tr ^mk ^before-mklabel new “/path/to/script” –^server=myserver:8084</p>
<p>cm ^tr ^mk ^after-mklabel Log “/path/to/script” –^filter=”^rep:myRep,LB*”
（仅当标签名称以 ‘LB’ 开头并且标签是在名为 ‘myRep’ 的
存储库中创建时，才会执行此触发器。）</p>
<p>cm ^tr ^mk ^after-checkin NotifyTeam “^webtrigger <a class="reference external" href="http://myserver.org/api">http://myserver.org/api</a>”</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_MOVE ==
移动或重命名文件或目录。</p>
<p>== CMD_USAGE_MOVE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^move | ^mv &lt;源路径&gt; &lt;目标路径&gt; [–^format=&lt;格式字符串&gt;]</dt><dd><p>[–^errorformat=&lt;格式字符串&gt;]</p>
</dd>
</dl>
<p>源路径            源项的路径。
目标路径            目标项的路径。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
<dt>–^errorformat       检索特定格式的错误消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_MOVE ==
备注：</p>
<blockquote>
<div><p>此命令将移动或重命名存储库中的项。
还会在本地文件系统中进行更改。</p>
<p>如果源路径是文件，则目标路径可以是文件或
目录。在第一种情况下会重命名文件；否则会移动
相应的项。
如果源路径是目录，则目标路径必须是目录。</p>
<p>要移动或重命名的项必须已存在。</p>
<dl class="simple">
<dt>格式：</dt><dd><p>{0}         源路径（’–^format’ 和 ‘–^errorformat’）
{1}         目标路径（’–^format’ 和 ‘–^errorformat’）</p>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^move file.txt file.old
（重命名相应的项。）</p>
<p>cm ^mv .file.old .oldFiles
（将 ‘file.old’ 移到 ‘oldFiles’。）</p>
<p>cm ^move .src .src2
（重命名目录。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LABEL ==
允许用户管理标签。</p>
<p>== CMD_USAGE_LABEL ==
用法：</p>
<blockquote>
<div><p>cm ^label | ^lb &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^create | ^mk
^delete | ^rm
^rename</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^label &lt;命令&gt; –^usage
cm ^label &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_LABEL ==
示例：</p>
<blockquote>
<div><p>cm ^label myNewLabel ^cs:42
（’^create’ 命令是可选命令。）</p>
<p>cm ^label ^rename myNewLabel newLabelName
cm ^label ^delete newLabelName</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LABEL_CREATE ==
将标签应用于变更集，并在需要时创建标签。</p>
<p>== CMD_USAGE_LABEL_CREATE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^label [^create] &lt;标签规格&gt; [&lt;变更集规格&gt; | &lt;工作区路径&gt;]</dt><dd><p>[–^allxlinkedrepositories]
[-^c=&lt;注释字符串&gt; | -^commentsfile=&lt;注释文件&gt;]</p>
</dd>
<dt>标签规格              新标签名称。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解标签
规格。）</p>
</dd>
<dt>变更集规格            要标记的变更集的名称或完整规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集
规格。）</p>
</dd>
<dt>工作区路径             要标记的工作区的路径。（工作区指向的</dt><dd><p>变更集将被标记。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^allxlinkedrepositories  在所有通过 Xlink 链接的存储库中创建新标签。
-^c                        将指定的注释应用于新标签。
-^commentsfile             将指定文件中的注释应用于</p>
<blockquote>
<div><p>新标签。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_LABEL_CREATE ==
备注：</p>
<blockquote>
<div><p>设置 PLASTICEDITOR 环境变量可指定用于键入注释的
编辑器。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^label ^create ^lb:BL001 ^cs:1203 -^commentsfile=commentlb001.txt
（创建附加到变更集 1203 的标签 ‘BL001’，并应用 ‘commentlb001.txt’
文件中的注释。）</p>
<p>cm ^label BL002 ^cs:1203 -^c=”首次发布”
（创建带有注释的标签 ‘BL002’，并附加到变更集 1203。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LABEL_DELETE ==
删除一个或多个标签。</p>
<p>== CMD_USAGE_LABEL_DELETE ==
用法：</p>
<blockquote>
<div><p>cm ^label ^delete &lt;标签规格&gt;[ …]</p>
<dl class="simple">
<dt>标签规格          要删除的标签。使用空格对各个标签进行分隔。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解标签
规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_LABEL_DELETE ==
备注：</p>
<blockquote>
<div><p>此命令将删除一个或多个标签。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^label ^delete ^lb:BL001
（删除标签 ‘BL001’。）</p>
<p>cm ^label ^delete ^lb:BL001 ^lb:BL002&#64;reptest&#64;server2:8084
（删除标签 ‘BL001’ 和 ‘BL002’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LABEL_RENAME ==
重命名标签。</p>
<p>== CMD_USAGE_LABEL_RENAME ==
用法：</p>
<blockquote>
<div><p>cm ^label ^rename &lt;标签规格&gt; &lt;新名称&gt;</p>
<dl class="simple">
<dt>标签规格          要重命名的标签。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解标签规格。）</p>
</dd>
</dl>
<p>新名称        标签的新名称。</p>
</div></blockquote>
<p>== CMD_HELP_LABEL_RENAME ==
备注：</p>
<blockquote>
<div><p>此命令将重命名标签。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^label ^rename ^lb:BL001 BL002
（将标签 ‘BL001’ 重命名为 ‘BL002’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_OBLITERATE ==
已弃用</p>
<p>== CMD_USAGE_OBLITERATE ==
已弃用。</p>
<p>== CMD_HELP_OBLITERATE ==
已弃用。</p>
<p>== CMD_DESCRIPTION_OBJECTSPEC ==
描述如何编写对象规格。</p>
<p>== CMD_USAGE_OBJECTSPEC ==
用法：</p>
<blockquote>
<div><p>cm ^objectspec
获取关于如何构建对象规格的所有信息。</p>
</div></blockquote>
<p>== CMD_HELP_OBJECTSPEC ==
一些 Plastic SCM 命令要求将 ‘对象规格’ 作为输入来引用
给定对象（通常是分支、变更集、存储库等）。</p>
<p>本文档介绍可用的不同“规格”以及如何
构建规格。</p>
<p>每个规格类型以唯一标记（例如 “^rep:” 或 “^cs:”）开头。必须为
采用一般对象规格的命令指定标记（例如：
“cm ^setowner 对象规格” 命令），但对于仅采用单一类型规格的命令
常常可以省略标记（例如：”cm ^getfile 修订规格” 命令）。</p>
<dl>
<dt>– 存储库服务器规格 –</dt><dd><p>^repserver:name:port</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^repo ^list ^repserver:skull:8084
cm ^repo ^list skull:8084</p>
</dd>
<dt>旁注：</dt><dd><p>由于历史原因，我们称之为“存储库服务器规格”，而不只是
“服务器规格”。很久以前，我们有单独的工作区服务器和
存储库服务器，命名方式沿用至今。</p>
</dd>
</dl>
</dd>
<dt>– 存储库规格 –</dt><dd><p>^rep:rep_name&#64;[存储库服务器规格]</p>
<dl>
<dt>示例：</dt><dd><p>cm ^showowner ^rep:<a class="reference external" href="mailto:codice&#37;&#52;&#48;localhost">codice<span>&#64;</span>localhost</a>:6060
（此处的 “^rep:” 是必需的，因为 ^showowner 不仅容许存储库，
而且容许其他类型的对象。因此，需要用户指明</p>
<blockquote>
<div><p>对象类型。）</p>
</div></blockquote>
</dd>
</dl>
</dd>
<dt>– 分支规格 –</dt><dd><p>^br:[/]br_name[&#64;repspec]</p>
<dl>
<dt>示例：</dt><dd><p>cm ^switch ^br:<a class="reference external" href="mailto:/main&#37;&#52;&#48;^rep">/main<span>&#64;</span>^rep</a>:<a class="reference external" href="mailto:plastic&#37;&#52;&#48;^repserver">plastic<span>&#64;</span>^repserver</a>:skull:9095
（这种情况下不需要 “^br:”、”^rep” 和 “^repserver”，所以</p>
<blockquote>
<div><p>该命令容许简短很多的格式：</p>
</div></blockquote>
<p>“cm ^switch main&#64;plastic&#64;skull:9095”。）</p>
<p>cm ^find ^revisions “^where ^branch=’^br:/main/task001’”</p>
</dd>
<dt>备注：</dt><dd><p>分支上的初始 ‘/’ 不是必需的。我们曾经将所有分支
指定为 /main、/main/task001，依此类推。但是现在，我们首选
更短的 main、main/task001 形式，这使命令更简洁。</p>
</dd>
</dl>
</dd>
<dt>– 变更集规格 –</dt><dd><p>^cs:cs_number|cs_GUID[&#64;repspec]</p>
<p>可以指定变更集的编号或 GUID。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^ls /code –^tree=ae1390ed-7ce9-4ec3-a155-e5a61de0dc77&#64;code&#64;skull:7070</p>
</dd>
</dl>
</dd>
<dt>– 标签规格 –</dt><dd><p>^lb:lb_name[&#64;repspec]</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^switch ^lb:RELEASE2.0
cm ^switch ^lb:RELEASE1.4&#64;myrep&#64;MYSERVER:8084</p>
</dd>
</dl>
</dd>
</dl>
<p>– 修订规格 –
有不同类型的修订规格：</p>
<blockquote>
<div><p>^rev:item_path[#(分支规格|变更集规格|标签规格)]</p>
<p>^rev:^serverpath:item_path#(分支规格|变更集规格|标签规格)</p>
<p>^rev:^revid:rev_id[&#64;rep_spec]</p>
<p>^rev:^itemid:item_id#(分支规格|变更集规格|标签规格)</p>
<dl>
<dt>示例：</dt><dd><p>cm ^diff ^rev:readme.txt#^cs:19 ^rev:readme.txt#^cs:20</p>
<dl class="simple">
<dt>cm ^diff ^serverpath:/doc/readme.txt#^cs:<a class="reference external" href="mailto:19&#37;&#52;&#48;myrepo">19<span>&#64;</span>myrepo</a> </dt><dd><p>^serverpath:/doc/readme.txt#^br:/main&#64;myrepo&#64;localhost:8084</p>
</dd>
</dl>
<p>cm ^cat ^revid:<a class="reference external" href="mailto:1230&#37;&#52;&#48;^rep">1230<span>&#64;</span>^rep</a>:<a class="reference external" href="mailto:myrep&#37;&#52;&#48;^repserver">myrep<span>&#64;</span>^repserver</a>:myserver:8084</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>– 项规格 –</dt><dd><p>^item:path
极少使用。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^revision “^where ^item=’^item:.’”</p>
</dd>
</dl>
</dd>
<dt>– 属性规格 –</dt><dd><p>^att:att_name[&#64;repspec]</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^attribute ^set ^att:merged&#64;code&#64;doe:8084 ^cs:25&#64;code&#64;doe:8084 完成</p>
</dd>
</dl>
</dd>
<dt>– 搁置规格 –</dt><dd><p>^sh:sh_number[&#64;repspec]</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^diff ^sh:2 ^sh:4</p>
</dd>
</dl>
</dd>
<dt>– 工作区规格 –</dt><dd><p>^wk:<a class="reference external" href="mailto:name&#37;&#52;&#48;clientmachine">name<span>&#64;</span>clientmachine</a></p>
</dd>
</dl>
<p>极少使用，因为仅适用于工作区相关的命令。适合用于
按名称和机器（而不是路径）来指定工作区。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^showselector ^wk:<a class="reference external" href="mailto:codebase&#37;&#52;&#48;modok">codebase<span>&#64;</span>modok</a></p>
</dd>
<dt>旁注：</dt><dd><p>这些规格来自早期的 Plastic SCM 2.x，当时的
“工作区服务器”是一种集中存储工作区元数据
的方式。后期由于性能问题而被弃用。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL ==
在非完整的工作区中运行命令。</p>
<p>== CMD_USAGE_PARTIAL ==
用法：</p>
<blockquote>
<div><p>cm ^partial &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^configure
^add
^undo
^co   | ^checkout
^unco | ^undocheckout
^ci   | ^checkin
^mv   | ^move
^rm   | ^remove
^stb  | ^switch
^upd  | ^update</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^partial &lt;命令&gt; –^usage
cm ^partial &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_PARTIAL ==
示例：</p>
<blockquote>
<div><p>cm ^partial ^configure +/background-blue.png
cm ^partial ^update landscape-1024.png
cm ^partial ^checkin eyes-green.png eyes-black.png</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_ADD ==
向版本控制中添加项。</p>
<p>== CMD_USAGE_PARTIAL_ADD ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^partial ^add [-^R | -^r | –^recursive] [–^silent] [–^parents]</dt><dd><p>[–^ignorefailed] [–^skipcontentcheck] &lt;项路径&gt;[ …]</p>
</dd>
<dt>项路径           要添加的项。使用双引号 (” “) 指定包含空格</dt><dd><p>的路径。使用空格对各个路径进行分隔。
使用 * 添加当前目录的所有内容。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>-^R                  以递归方式添加项。
–^silent            不显示任何输出。
–^parents           在操作中包含指定项</p>
<blockquote>
<div><p>的父目录。</p>
</div></blockquote>
<dl class="simple">
<dt>–^ignorefailed      如果无法添加某一项，则添加操作将在没有</dt><dd><p>这一项的情况下继续进行。注意：如果无法添加
某个目录，则不会添加目录中的内容。</p>
</dd>
<dt>–^skipcontentcheck  如果不足以根据扩展名将文件设置为</dt><dd><p>文本或二进制，默认情况下会将该文件设置为二进制，
而不是检查内容来检测类型。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_ADD ==
备注：</p>
<blockquote>
<div><p>添加项的要求：
- 要添加的项的父目录必须已事先添加。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^add pic1.png pic2.png
（添加 ‘pic1.png’ 和 ‘pic2.png’ 项。）</p>
<p>cm ^partial ^add c:workspacepicture.png
（添加路径 ‘c:workspace’ 中的 ‘picture.png’ 项。）</p>
<p>cm ^partial ^add -^R c:workspacesrc
（以递归方式添加 ‘src’。）</p>
<p>cm ^partial ^add –^parents samplesdesign01.png
（添加 ‘design01.png’ 文件和 ‘samples’ 父文件夹。）</p>
<p>cm ^partial ^add -^R *
（以递归方式添加当前目录的所有内容。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_CHECKIN ==
将更改存储在存储库中。</p>
<p>== CMD_USAGE_PARTIAL_CHECKIN ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^partial ^checkin | ^ci [&lt;项路径&gt;[ …]]</dt><dd><p>[-^c=&lt;注释字符串&gt; | -^commentsfile=&lt;注释文件&gt;]
[–^all | -^a] [–^applychanged] [–^keeplock]
[–^symlink] [–^ignorefailed]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>项路径           要签入的项。使用双引号 (” “) 指定</dt><dd><p>包含空格的路径。使用空格对各个路径进行
分隔。
使用 . 将签入应用到当前目录。</p>
</dd>
<dt>-^c                  指定在签入操作中创建的变更集</dt><dd><p>的注释。</p>
</dd>
<dt>-^commentsfile       将指定文件中的注释应用于在签入操作中</dt><dd><p>创建的变更集。</p>
</dd>
<dt>–^all | -^a          还包括在指定路径上进行了本地更改、移动</dt><dd><p>和删除的项。</p>
</dd>
<dt>–^applychanged      将签入操作应用于在工作区中</dt><dd><p>检测到的已更改项以及
签出的项。</p>
</dd>
<dt>–^keeplock          签入操作后保持锁定项的</dt><dd><p>锁定状态。</p>
</dd>
<dt>–^symlink           将签入操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
<dt>–^ignorefailed      无法应用的任何更改（因为无法获得</dt><dd><p>锁定状态（又称为“独占签出”）或者
因为本地更改与服务器更改冲突）
将被丢弃，然后没有这些更改的情况下
继续进行签入操作。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_CHECKIN ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>如果未指定 &lt;项路径&gt;，则签入操作将涉及
工作区中的所有待定更改。</p></li>
<li><p>签入操作始终以递归方式从给定路径应用。</p></li>
<li><p>要签入项，必须满足以下条件：</p></li>
<li><p>项必须受源代码管理。</p></li>
<li><p>必须签出项。</p></li>
<li><p>如果已更改但未签出项，则除非 &lt;项路径&gt; 是目录
或包含通配符 (‘*’)，否则不需要
‘–^applychanged’ 标志。</p></li>
</ul>
<p>修订内容必须与以前的修订不同才能
签入。</p>
<p>设置 PLASTICEDITOR 环境变量可指定用于键入注释的
编辑器。</p>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^partial ^checkin’ 命令可从 stdin 读取路径。为此，请传递
一个破折号 “-”。
示例：cm ^partial ^checkin -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要签入的文件。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id11"><span class="problematic" id="id12">*</span></a>.c | cm ^partial ^checkin –^all -
（在 Windows 中，签入工作区中的所有 .c 文件。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^checkin figure.png landscape.png
（将签入应用于已签出的文件 ‘figure.png’ 和 ‘landscape.png’。）</p>
<p>cm ^partial ^checkin .-^commentsfile=mycomment.txt
（将签入应用于当前目录并设置 ‘mycomment.txt’ 文件
中的注释。）</p>
<p>cm ^partial ^ci background.png -^c=”我的注释” –^keeplock
（将签入应用于 ‘background.png’，包含注释，并保持
锁定。）</p>
<p>cm ^partial ^checkin –^applychanged
（将签入应用于工作区中的所有待定更改。）</p>
<p>cm ^partial ^checkin 链接 –^symlink
（将签入应用于链接文件而非目标，适用于
UNIX 环境。）</p>
<p>cm ^partial ^checkin .–^ignorefailed
（将签入应用于当前目录，忽略无法应用的
更改。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_CHECKOUT ==
将文件标记为修改就绪。</p>
<p>== CMD_USAGE_PARTIAL_CHECKOUT ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^partial ^checkout | ^co [&lt;项路径&gt;[ …]] [–^resultformat=&lt;格式字符串&gt;]</dt><dd><p>[–^silent] [–^ignorefailed]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>项路径           要签出的项。使用双引号 (” “) 指定</dt><dd><p>包含空格的路径。使用空格对各个路径进行
分隔。
使用 . 将签出应用到当前目录。</p>
</dd>
<dt>–^resultformat      检索特定格式的输出结果</dt><dd><p>消息。</p>
</dd>
</dl>
<p>–^silent            不显示任何输出。
–^ignorefailed      如果无法锁定某项（无法执行独占签出），</p>
<blockquote>
<div><p>则签出操作将在没有这一项的情况下
继续进行。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_CHECKOUT ==
备注：</p>
<blockquote>
<div><p>要签出项，必须满足以下条件：
- 项必须受源代码管理。
- 必须签入项。</p>
<p>如果在服务器上配置了锁（存在 lock.conf），则每次
在某条路径上进行签出时，Plastic 都会检查是否符合规则，
如果符合，该路径将处于独占签出（锁定）状态，以便任何其他人
都无法同时进行签出。
可使用 ‘cm ^lock ^list’ 获取服务器中的所有锁。
请查看《管理员指南》以了解锁定的工作原理：
<a class="reference external" href="https://www.plasticscm.com/download/help/locking">https://www.plasticscm.com/download/help/locking</a></p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^checkout pic1.png pic2.png
（签出 ‘pic1.png’ 和 ‘pic2.png’ 文件。）</p>
<p>cm ^partial ^co <a href="#id13"><span class="problematic" id="id14">*</span></a>.png
（签出所有 png 文件。）</p>
<p>cm ^partial ^checkout .
（签出当前目录。）</p>
<p>cm ^partial ^checkout -^R c:workspacesrc
（以递归方式签出 ‘src’ 文件夹。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_CONFIGURE ==
可以通过在工作区中加载或卸载项来配置工作区。</p>
<p>== CMD_USAGE_PARTIAL_CONFIGURE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^partial ^configure &lt;+|-路径&gt;[ …][–^silent] [–^ignorefailed]</dt><dd><p>[–^ignorecase] [–^restorefulldirs]</p>
</dd>
<dt>路径           要加载或卸载的路径。使用双引号 (” “)</dt><dd><p>指定包含空格的路径。使用空格对各个路径进行
分隔。
路径必须以 “/” 开头。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^silent            不显示任何输出。
–^ignorefailed      跳过该过程中的所有错误。错误路径</p>
<blockquote>
<div><p>不会导致命令停止。</p>
</div></blockquote>
<dl class="simple">
<dt>–^ignorecase        忽略路径中的大小写。使用此标志后，</dt><dd><p>即使用户写入 “/data/teXtures”，’^configure’ 也对
“/Data/Textures” 有效。</p>
</dd>
<dt>–^restorefulldirs   重置无效的目录配置（在非完整的工作区上</dt><dd><p>运行完整操作时发生）。
此列表中的目录将实现完全配置
（完全检查），这意味着这些目录将在
更新期间自动下载新内容。
此操作不会下载任何文件，只会
在非完整的工作区上还原目录
配置。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_CONFIGURE ==
备注：</p>
<blockquote>
<div><p>该命令采用递归操作。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^configure +/landscape_grey.png
（加载 ‘landscape_grey.png’ 项。）</p>
<p>cm ^partial ^configure -/landscape_black.png
（卸载 ‘landscape_black.png’ 项。）</p>
<p>cm ^partial ^configure +/soft -/soft/soft-black.png
（加载除 ‘soft-black.png’ 以外的所有 ‘soft’ 目录子项。）</p>
<p>cm ^partial ^configure -/
（卸载整个工作区。）</p>
<p>cm ^partial ^configure -/ +/
（加载整个工作区。）</p>
<p>cm ^partial ^configure -/figure-64.png –^ignorefailed
（即使已卸载 ‘figure-64.png’ 项，也要卸载该项。）</p>
<p>cm ^partial ^configure +/ –^restorefulldirs
（设置所有目录来自动下载新内容。）</p>
<p>cm ^partial ^configure +/src/lib –^restorefulldirs
（仅设置 ‘/src/lib’ 及其子目录来自动下载
新内容。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_MOVE ==
移动或重命名文件或目录。</p>
<p>== CMD_USAGE_PARTIAL_MOVE ==
用法：</p>
<blockquote>
<div><p>cm ^partial ^move | ^mv &lt;源路径&gt; &lt;目标路径&gt; [–^format=&lt;格式字符串&gt;]</p>
<p>源路径            源项的路径。
目标路径            目标项的路径。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_MOVE ==
备注：</p>
<blockquote>
<div><p>此命令将移动或重命名存储库中的项。
还会在本地文件系统中进行更改。</p>
<p>如果源路径是文件，则目标路径可以是文件或
目录。在第一种情况下将重命名文件；否则将移动
相应的项。
如果源路径是目录，则目标路径必须是目录。</p>
<p>要移动或重命名的项必须已存在。</p>
<dl class="simple">
<dt>格式：</dt><dd><p>{0}             源路径。
{1}             目标路径。</p>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^move file.png file-blue.png
（重命名相应的项。）</p>
<p>cm ^partial ^mv .file-blue.png .blueFiles
（将 ‘file-blue.png’ 移动到 ‘blueFiles’。）</p>
<p>cm ^partial ^move .design .marketing
（重命名目录。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_RM ==
从版本控制中删除一个文件或目录。</p>
<p>== CMD_USAGE_PARTIAL_RM ==
用法：</p>
<blockquote>
<div><p>cm ^partial ^remove | ^rm &lt;项路径&gt;[ …][–^nodisk]</p>
<dl class="simple">
<dt>项路径       要删除的项路径。使用双引号 (” “)</dt><dd><p>指定包含空格的路径。使用空格对各个路径进行
分隔。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^nodisk        从版本控制中删除相应的项，但是将该项保留在磁盘上。</p>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_RM ==
备注：</p>
<blockquote>
<div><p>磁盘中会删除项。删除的项会从源代码管理
中的父目录中被删除。</p>
<p>要求：
- 项必须受源代码管理。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^remove src
（删除 ‘src’。如果 ‘src’ 是目录，则等同于：
cm ^partial ^remove -^R src。）</p>
<p>cm ^partial ^remove c:workspacepic01.png –^nodisk
（从版本控制中删除 ‘pic01.png’，但将其保留在磁盘上。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_SWITCH ==
将分支设置为工作分支。</p>
<p>== CMD_USAGE_PARTIAL_SWITCH ==
用法：</p>
<blockquote>
<div><p>cm ^switch &lt;分支规格&gt; [–^report | –^silent] [–^workspace=&lt;路径&gt;]
（设置工作分支并更新工作区。）</p>
<dl class="simple">
<dt>cm ^switch &lt;分支规格&gt; –^configure &lt;+|-路径&gt;[ …][–^silent]</dt><dd><p>[–^ignorefailed] [–^ignorecase] [–^workspace=&lt;路径&gt;]</p>
</dd>
</dl>
<p>（设置工作分支并运行工作区配置，就像 ‘cm
^partial ^configure’ 命令一样。）</p>
<dl class="simple">
<dt>分支规格         分支的规格。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解分支规格。）</p>
</dd>
<dt>路径                要加载或卸载的路径。使用双引号 (” “)</dt><dd><p>指定包含空格的路径。使用空格对各个路径
进行分隔。路径必须以 “/” 开头。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^silent            不显示任何输出。
–^report            命令完成后，打印已应用更改</p>
<blockquote>
<div><p>的列表。使用 ‘–^silent’ 将会覆盖此设置。
此选项仅在未指定 ‘–^configure’ 选项
时有效。</p>
</div></blockquote>
<dl class="simple">
<dt>–^configure         更新工作分支后配置</dt><dd><p>（加载/卸载项）工作区。查看 ‘cm ^partial
^configure –^help’ 可了解如何指定要配置的
路径。</p>
</dd>
<dt>–^ignorefailed      跳过配置过程中的所有错误。</dt><dd><p>错误路径不会导致命令停止。</p>
</dd>
<dt>–^ignorecase        忽略路径中的大小写。使用此标志后，即使</dt><dd><p>用户写入 “/data/teXtures”，选项 ‘–^configure’ 也对
“/Data/Textures” 有效。</p>
</dd>
</dl>
<p>–^workspace=路径    工作区所在的路径。</p>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_SWITCH ==
备注：</p>
<blockquote>
<div><p>此命令允许用户更新工作分支。更新分支之后，
该命令就像 ‘cm ^partial ^update’ 命令一样会
将工作区更新到新分支。然而，如果指定了 ‘–^configure’
选项，该命令就像 ‘cm ^partial ^configure’ 命令一样会
允许使用新的分支配置来配置工作区。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^switch ^br:/main/task
（将 /main/task 设置为工作分支并更新工作区。）</p>
<p>cm ^switch ^br:/main/task –^configure +/art/images
（将 /main/task 设置为工作分支，并配置工作区来
加载 /art/images 文件夹。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_UNCO ==
撤销项的签出。</p>
<p>== CMD_USAGE_PARTIAL_UNCO ==
用法：</p>
<blockquote>
<div><p>cm ^partial ^undocheckout | ^unco &lt;项路径&gt;[ …][–^silent]</p>
<dl class="simple">
<dt>项路径           要应用操作的项。使用双引号 (” “)</dt><dd><p>指定包含空格的路径。使用空格对各个路径
进行分隔。
使用 . 将操作应用到当前目录。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^silent            不显示任何输出。</p>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_UNCO ==
备注：</p>
<blockquote>
<div><p>如果已签出某个项并且不想将这个项签入，则可以
使用此命令撤销签出。文件和文件夹都可以取消
签出。项将更新为签出之前的状态。</p>
<dl class="simple">
<dt>要求：</dt><dd><ul class="simple">
<li><p>项必须受源代码管理。</p></li>
<li><p>必须签出项。</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^undocheckout .
（撤销当前目录中的签出。）</p>
<p>cm ^partial ^undocheckout pic1.png pic2.png
cm ^unco c:workspacedesign01.png
（撤销签出所选文件。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_UNDO ==
撤销工作区中的更改。</p>
<p>== CMD_USAGE_PARTIAL_UNDO ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^partial ^undo [&lt;路径&gt;[ …]] [–^symlink] [-^r | –^recursive]</dt><dd><p>[&lt;筛选器&gt;[ …]]
[–^silent | –^machinereadable [–^startlineseparator=&lt;分隔符&gt;]</p>
<blockquote>
<div><p>[–^endlineseparator=&lt;分隔符&gt;] [–^fieldseparator=&lt;分隔符&gt;]]</p>
</div></blockquote>
</dd>
<dt>路径                    要应用操作的文件或目录</dt><dd><p>的路径。使用双引号 (” “) 指定
包含空格的路径。使用空格对各个路径
进行分隔。
如果未指定路径，则默认情况下，
撤销操作将应用于当前目录中的所有
文件。</p>
</dd>
<dt>筛选器                  将一个或多个指定筛选器应用于给定</dt><dd><p>路径。使用空格对各个筛选器进行分隔。请参阅
“筛选器”部分以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^symlink               将撤销操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
</dl>
<p>-^r                      以递归方式执行撤销。
–^silent                不显示任何输出。
–^machinereadable       以易于解析的格式输出结果。
–^startlineseparator    与 ‘–^machinereadable’ 标志结合使用，指定</p>
<blockquote>
<div><p>行应如何开头。</p>
</div></blockquote>
<dl class="simple">
<dt>–^endlineseparator      与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>行应如何结尾。</p>
</dd>
<dt>–^fieldseparator        与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>应如何分隔字段。</p>
</dd>
</dl>
</div></blockquote>
<p>筛选器：</p>
<blockquote>
<div><p>如果未指定标志，则默认情况下将撤销所有更改，但是
可以使用以下一个或多个标志来筛选路径。
如果文件或目录匹配一个或多个指定种类的更改，
则将撤销该文件或目录上的所有更改。
例如，如果同时指定了 ‘–^checkedout’ 和 ‘–^moved’，则在
已签出并移动文件的情况下，两项更改都将被撤销。</p>
<p>–^checkedout            选择已签出的文件和目录。
–^unchanged             选择内容不变的文件。
–^changed               选择本地更改的或签出的文件和</p>
<blockquote>
<div><p>目录。</p>
</div></blockquote>
<p>–^deleted               选择已删除的文件和目录。
–^moved                 选择已移动的文件和目录。
–^added                 选择已添加的文件和目录。</p>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_UNDO ==
备注：</p>
<blockquote>
<div><p>^undo 命令有风险，因为该命令在撤销工作后将不可逆。
^undo 完成后，无法将受其影响的文件和目录
恢复到先前状态。如果参数中
未指定路径，则默认情况下，该命令将撤销
当前目录中的所有更改，但不采用递归方式。
从 /src 目录执行时，以下命令是等效的：</p>
<blockquote>
<div><p>/src
<a href="#id15"><span class="problematic" id="id16">|</span></a>- file.txt
<a href="#id17"><span class="problematic" id="id18">|</span></a>- code.cs
- /test</p>
<blockquote>
<div><p><a href="#id19"><span class="problematic" id="id20">|</span></a>- test_a.py
- test_b.py</p>
</div></blockquote>
<p>cm ^partial ^undo
cm ^partial ^undo *
cm ^partial ^undo file.txt code.cs /test</p>
<p>cm ^partial ^undo .
cm ^partial ^undo /src file.txt code.cs</p>
</div></blockquote>
<p>如果希望操作以递归方式执行，必须指定 ‘-^r’ 标志。</p>
<p>撤销某一目录下的所有更改（包括影响目录
本身的更改）：</p>
<blockquote>
<div><p>cm ^partial ^undo 目录路径 -^r</p>
</div></blockquote>
<p>如果目录路径是工作区路径，则工作区中的每个更改都将
被撤销。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^undo .-^r
（以递归方式撤销当前目录中的所有更改。如果从工作区的
根目录执行，则撤销整个工作区中的所有更改。）</p>
<p>cm ^partial ^co file.txt
cm ^partial ^undo file.txt
（撤销对 file.txt 的签出。）</p>
<p>^echo ^content &gt;&gt; file.txt
cm ^partial ^undo file.txt
（撤销对 file.txt 的本地更改。）</p>
<p>cm ^partial ^undo src
（撤销对 src 目录及其文件的更改。）</p>
<p>cm ^partial ^undo src/*
（撤销对 src 中包含的每个文件和目录的更改，而不会
影响 src。）</p>
<p>cm ^partial ^undo <a href="#id21"><span class="problematic" id="id22">*</span></a>.cs
（撤销对当前目录中与 <a href="#id23"><span class="problematic" id="id24">*</span></a>.cs 匹配的每个文件或目录的
更改。）</p>
<p>cm ^partial ^undo <a href="#id25"><span class="problematic" id="id26">*</span></a>.cs-^r
（撤销对当前目录以及下级每个目录中与 <a href="#id27"><span class="problematic" id="id28">*</span></a>.cs 匹配的
每个文件或目录的更改。）</p>
<p>cm ^partial ^co file1.txt file2.txt
^echo ^content &gt;&gt; file1.txt
cm ^partial ^undo –^unchanged
（撤销对未更改的 file2.txt 的签出，并忽略本地更改的
file1.txt。）</p>
<p>^echo ^content &gt;&gt; file1.txt
^echo ^content &gt;&gt; file2.txt
cm ^partial ^co file1.txt
cm ^partial ^undo –^checkedout
（撤销已签出文件 file1.txt 中的更改，并忽略 file2.txt，
因为后者未签出。）</p>
<p>cm ^partial ^add file.txt
cm ^partial ^undo file.txt
（撤销添加 file.txt，使该文件再次成为私有文件。）</p>
<p>^rm file1.txt
^echo ^content &gt;&gt; file2.txt
cm ^partial ^add file3.txt
cm ^partial ^undo –^deleted –^added *
（撤销 file1.txt 的删除和 file3.txt 的添加，并忽略 file2.txt
的更改。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PARTIAL_UPDATE ==
更新非完整的工作区并下载最新的更改。</p>
<p>== CMD_USAGE_PARTIAL_UPDATE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^partial ^update [&lt;项路径&gt;[ …]] [–^changeset=&lt;编号&gt;]</dt><dd><p>[–^silent | –^report] [–^dontmerge]</p>
</dd>
<dt>项路径           要更新的项。使用双引号 (” “) 指定</dt><dd><p>包含空格的路径。使用空格对各个路径进行
分隔。
使用 . 将更新应用到当前目录。
如果未指定路径，则当前非完整的
工作区将完全更新。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^changeset         将非完整的工作区更新到特定变更集。
–^silent            不显示任何输出。
–^report            命令完成后，打印已应用更改</p>
<blockquote>
<div><p>的列表。使用 ‘–^silent’ 将会覆盖此设置。</p>
</div></blockquote>
<dl class="simple">
<dt>–^dontmerge         不合并文件冲突，只是跳过这些冲突。</dt><dd><p>其他更改会正确应用。此选项可用于
自动化，从而避免用户交互。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_PARTIAL_UPDATE ==
备注：</p>
<blockquote>
<div><p>‘^partial ^update’ 命令将更新已过期的文件。</p>
<p>该命令采用递归操作。</p>
<p>在使用 ‘–^changeset’ 选项时，如果所有指定的路径都是
同一 Xlink 内的文件，则会在通过 Xlink 链接的存储库的
指定变更集内搜索要下载的版本。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^partial ^update
（更新当前非完整的工作区中的所有内容。）</p>
<p>cm ^partial ^update .
（更新所有当前目录子项。）</p>
<p>cm ^partial ^update backgroud-blue.png
（更新 ‘backgroud-blue.png’ 项。）</p>
<p>cm ^partial ^update soft_black.png soft-grey.png
（更新 ‘soft_black.png’ 和 ‘soft-grey.png’ 项。）</p>
<p>cm ^partial ^update src –^report
（更新所有 ‘src’ 目录子项，并在最后打印已应用的
更改列表。）</p>
<p>cm ^partial ^update src –^changeset=4
（将所有 ‘src’ 目录子项更新为变更集 4 中
加载的相应内容。）</p>
<p>cm ^partial ^update xlink/first.png –^changeset=4
（将 ‘xlink/first.png’ 项更新为通过 Xlink 链接的存储库的变更集 4 中
加载的相应内容。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PATCH ==
从规格生成一个补丁文件，或者将生成的补丁应用于当前
工作区。</p>
<p>== CMD_USAGE_PATCH ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^patch &lt;源规格&gt; [&lt;源规格&gt;] [–^output=&lt;输出文件&gt;]</dt><dd><p>[–^tool=&lt;差异比较路径&gt;]</p>
</dd>
</dl>
<p>生成一个补丁文件，该文件包含分支的差异差、
变更集的差异差或变更集之间的差异。还用于跟踪
文本文件和二进制文件的差异。</p>
<p>cm ^patch –^apply &lt;补丁文件&gt; [–^tool=&lt;修补路径&gt;]
允许应用当前工作区中生成的补丁文件的
内容。</p>
<dl class="simple">
<dt>源规格     变更集或分支的完整规格。（使用</dt><dd><p>‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
<dt>输出文件     用于保存补丁内容的文件。如果未指定文件，</dt><dd><p>则会在标准输出中打印补丁内容。</p>
</dd>
</dl>
<p>补丁文件      要在当前工作区中应用的补丁文件。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^output        设置 patch 命令的输出文件。
–^tool          设置要使用的应用程序（差异比较还是修补）。</p>
</div></blockquote>
<p>== CMD_HELP_PATCH ==
限制：</p>
<blockquote>
<div><p>如果输出补丁文件已经存在，该命令不会覆盖这个文件。</p>
<p>应用补丁时，如果磁盘上没有已修改的文件，该命令不会
将更改应用于这些文件。</p>
</div></blockquote>
<p>重要信息：</p>
<blockquote>
<div><p>此命令需要差异比较工具和修补工具；可从以下网址公开获得这些工具：
<a class="reference external" href="http://gnuwin32.sourceforge.net/packages/patch.htm">http://gnuwin32.sourceforge.net/packages/patch.htm</a> 和
<a class="reference external" href="http://gnuwin32.sourceforge.net/packages/diffutils.htm">http://gnuwin32.sourceforge.net/packages/diffutils.htm</a></p>
<p>安装后，建议将工具的位置添加到 PATH
环境变量。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^patch ^cs:4&#64;default&#64;localhost:8084
（以统一格式在控制台上打印变更集 4 的差异。）</p>
<p>cm ^patch ^br:/main –^output=file.patch
（使用分支 “main” 的差异来生成补丁文件。）</p>
<p>cm ^patch ^br:/main –^output=file.patch –^tool=C:gnudiff.exe
（同上，使用的是自定义执行程序。）</p>
<p>cm ^patch ^cs:<a class="reference external" href="mailto:2&#37;&#52;&#48;default">2<span>&#64;</span>default</a> ^cs:<a class="reference external" href="mailto:4&#37;&#52;&#48;default">4<span>&#64;</span>default</a>
（以统一格式在控制台上打印变更集 2 和 4 之间的差异。）</p>
<p>cm ^patch –^apply file.patch –^tool=C:gnupatch.exe
（使用自定义执行程序将 ‘file.patch’ 中的补丁应用于本地工作区。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_QUERY ==
执行 SQL 查询。需要 SQL 存储。</p>
<p>== CMD_USAGE_QUERY ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^query &lt;SQL_命令&gt; [–^outputfile=&lt;输出文件&gt;]</dt><dd><p>[–^solveuser=&lt;列名称&gt;[,…]]
[–^solvepath=&lt;列名称&gt;[,…]]
[–^columnwidth=&lt;值&gt;] [–^nocolumnname]
[–^columnseparator=&lt;分隔符&gt;] [–^repository=&lt;名称&gt;]</p>
</dd>
</dl>
<p>SQL_命令         要执行的 SQL 查询。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^outputfile        将结果写入输出文件中。
–^solveuser         将指定的列设置为用户名列。查询</p>
<blockquote>
<div><p>解释器将假定这些列的数据将是用户，
并将尝试解析这些数据。</p>
</div></blockquote>
<dl class="simple">
<dt>–^solvepath         将指定的列设置为 itemid 列。查询</dt><dd><p>解释器将尝试将项 ID 解析为文件系统
路径。</p>
</dd>
</dl>
<p>–^columnwidth       指定每列的宽度以便格式化输出。
–^nocolumnname      不打印列名称。
–^columnseparator   使用字符作为列分隔符，而不是使用制表符 (t)。
–^repository        要查询的存储库。</p>
</div></blockquote>
<p>== CMD_HELP_QUERY ==
备注：</p>
<blockquote>
<div><p>此命令允许用户在服务器数据库中执行 SQL 查询。</p>
<p>为了编写 SQL 查询，请使用以下两个预定义的函数来管理
用户和路径：
- ‘^SolveUser(&lt;用户名&gt;)’，将用户名解析为 Plastic SCM 格式。
- ‘^SolvePath(&lt;路径&gt;)’，将磁盘路径解析为项 ID。</p>
<p>此外，还可使用选项以便于人工阅读的形式显示查询结果。</p>
<p>可以使用选项 ‘–^solveuser=&lt;列名称&gt;’ 和
‘–^solvepath=&lt;列名称&gt;’ 来指定必须由查询解释器
转换为易读文本的列。可以指定多个列名称，
以逗号分隔。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^query “^SELECT * ^FROM ^revision” –^columnwidth=25 –^repository=reptest
（从存储库 ‘reptest’ 中的 ‘修订’ 表检索数据。）</p>
<dl class="simple">
<dt>cm ^query “^SELECT b.^sname ^as 分支名称, o.^dtimestamp ^as 日期 ^from ^branch b, </dt><dd><p>^object o, ^seid s ^where b.^iobjid=o.^iobjid ^and o.^fidowner=s.^iseidid ^and s.^scode=’^SolveUser(john)’” –^outputfile=query.txt</p>
</dd>
</dl>
<p>（将所有者为 ‘john’ 的分支输出到文件中。）</p>
<dl class="simple">
<dt>cm ^query “^select r.^iobjid, r.^fiditem ^as 路径, s.^scode ^as 用户名 ^FROM </dt><dd><p>^revision r, ^object o, ^seid s ^WHERE r.^iobjid=o.^iobjid ^and o.^fidowner=s.^iseidid ^and o.^dtimestamp&gt;2014/04/25” </p>
</dd>
</dl>
<p>–^solveuser=用户名 –^solvepath=路径 <a class="reference external" href="mailto:--^repository=reptest&#37;&#52;&#48;server2">–^repository=reptest<span>&#64;</span>server2</a>:9095
（从所选存储库检索选定数据。）</p>
<p>cm ^query “^SELECT * ^FROM ^revision ^WHERE ^fiditem=^SolvePath(c:mywkpathinfo)”
（检索路径 ‘info’ 的所有修订数据。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ATTRIBUTE_DELETE ==
删除一个或多个属性。</p>
<p>== CMD_USAGE_ATTRIBUTE_DELETE ==
用法：</p>
<blockquote>
<div><p>cm ^attribute | ^att ^delete | ^rm &lt;属性规格&gt;[ …]</p>
<dl class="simple">
<dt>属性规格            要删除的属性。使用空格对各个属性进行</dt><dd><p>分隔。
（使用 ‘cm ^help ^objectspec’ 可进一步了解属性
规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_ATTRIBUTE_DELETE ==
备注：</p>
<blockquote>
<div><p>此命令将删除一个或多个属性。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^attribute ^delete ^att:status
（删除属性 ‘状态’。）</p>
<p>cm ^att ^rm 状态 ^att:integrated&#64;reptest&#64;server2:8084
（删除属性 ‘状态’ 和 ‘集成’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ATTRIBUTE_UNSET ==
取消设置对象的属性。</p>
<p>== CMD_USAGE_ATTRIBUTE_UNSET ==
用法：</p>
<blockquote>
<div><p>cm ^attribute | ^att ^unset &lt;属性规格&gt; &lt;对象规格&gt;</p>
<dl class="simple">
<dt>属性规格            属性的规格。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解属性规格。）</p>
</dd>
<dt>对象规格         要删除相应属性的对象</dt><dd><p>的规格。可以在以下对象上设置属性：分支、变更集、
搁置集、标签、项和修订。
（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_ATTRIBUTE_UNSET ==
备注：</p>
<blockquote>
<div><p>该命令将取消设置先前在对象上设置的某个属性。该命令
不会删除属性对象本身。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^attribute ^unset ^att:status ^br:/main/SCM105
（从分支 ‘main/SCM105’ 删除属性实现 ‘状态’。）</p>
<p>cm ^att ^unset ^att:integrated&#64;reptest&#64;localhost:8084 ^cs:25&#64;reptest&#64;localhost:8084
（从变更集 25 删除属性实现 ‘集成’，全都在
存储库 ‘reptest’ 中。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ATTRIBUTE_RENAME ==
为属性重命名。</p>
<p>== CMD_USAGE_ATTRIBUTE_RENAME ==
用法：</p>
<blockquote>
<div><p>cm ^attribute | ^att ^rename &lt;属性规格&gt; &lt;新名称&gt;</p>
<dl class="simple">
<dt>属性规格            要重命名的属性。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解属性规格。）</p>
</dd>
</dl>
<p>新名称            属性的新名称。</p>
</div></blockquote>
<p>== CMD_HELP_ATTRIBUTE_RENAME ==
备注：</p>
<blockquote>
<div><p>此命令将重命名一个属性。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^attribute ^rename ^att:status state
（将属性 ‘状态’ 重命名为 ‘状况’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ATTRIBUTE_EDIT ==
编辑属性的注释。</p>
<p>== CMD_USAGE_ATTRIBUTE_EDIT ==
用法：</p>
<blockquote>
<div><p>cm ^attribute | ^att ^edit &lt;属性规格&gt; &lt;新注释&gt;</p>
<dl class="simple">
<dt>属性规格        要更改相应注释的属性。（使用 ‘cm ^help ^objectspec’</dt><dd><p>可进一步了解属性规格。）</p>
</dd>
<dt>新注释     属性的新注释。还可以为属性指定</dt><dd><p>一个默认值列表。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_ATTRIBUTE_EDIT ==
备注：</p>
<blockquote>
<div><p>此命令将更改属性的注释。</p>
<p>要指定属性的默认值列表，只需将
如下的行包含在属性注释中：
‘default: 值_一, “值二”, 值3, “最终值”’。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^attribute ^edit ^att:status “CI 管道中分支的状态。”
（编辑属性 ‘状态’ 的注释。）</p>
<p>cm ^attribute ^edit ^att:status “分支的状态。默认值：未完成、已解决、已审查”
（编辑属性 ‘状态’ 的注释。还指定一个值
列表。因此，当属性 ‘状态’ 设置为对象时，可以选择
以下值之一：”未完成”、”已解决” 或 “已审查”。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REPLICATE ==
警告：已弃用此命令。</p>
<p>请使用 ‘cm ^pull’（等同于 ‘^replicate’）和 ‘cm ^push’（等同于
‘^replicate –^push’）。</p>
<p>== CMD_USAGE_REPLICATE ==</p>
<p>== CMD_HELP_REPLICATE ==</p>
<p>== CMD_DESCRIPTION_PULL ==
从另一个存储库拉取分支。</p>
<p>== CMD_USAGE_PULL ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^pull &lt;源分支规格&gt; &lt;目标存储库规格&gt;</dt><dd><blockquote>
<div><p>[–^preview] [–^nodata] [转换选项]
[–^user=&lt;用户名&gt; [–^password=&lt;密码&gt;] | 身份验证选项]</p>
</div></blockquote>
<p>（服务器之间的直接复制。从存储库拉取分支。）</p>
</dd>
<dt>cm ^pull &lt;目标存储库规格&gt; –^package=&lt;包文件&gt; [身份验证选项]</dt><dd><p>（基于包的复制。将包导入目标存储库中。）</p>
</dd>
<dt>cm ^pull ^hydrate &lt;目标分支规格&gt; [&lt;源存储库规格&gt;]</dt><dd><blockquote>
<div><p>[–^user=&lt;用户名&gt; [–^password=&lt;密码&gt;] | 身份验证选项]</p>
</div></blockquote>
<p>（为分支中先前使用 ‘–^nodata’ 复制的所有变更集
引入缺失的数据。如果未指定用于获取数据的存储库，
Plastic 会尝试使用“复制源”（复制分支
的来源））。</p>
</dd>
<dt>cm ^pull ^hydrate &lt;目标变更集规格&gt; [&lt;源存储库规格&gt;]</dt><dd><blockquote>
<div><p>[–^user=&lt;用户名&gt; [–^password=&lt;密码&gt;] | 身份验证选项]</p>
</div></blockquote>
<p>（为先前使用 ‘–^nodata’ 复制的变更集引入缺失的
数据。如果未指定用于获取数据的存储库，Plastic 会尝试
使用“复制源”）。</p>
</dd>
<dt>源分支规格     要从远程存储库拉取的分支。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解分支规格。）</p>
</dd>
<dt>目标分支规格     要进行 hydrate 的分支。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解分支规格。）</p>
</dd>
<dt>目标变更集规格     要进行 hydrate 的变更集。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集
规格。）</p>
</dd>
<dt>目标存储库规格    目标存储库。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
规格。）</p>
</dd>
<dt>–^package       指定要导入的先前创建的包文件以进行</dt><dd><p>基于包的复制。
适合在没有直接网络连接时用于在服务器
之间移动数据。
请参阅 ‘cm ^push’ 以创建包文件。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^preview           提供关于将拉取哪些更改的信息，</dt><dd><p>但实际上不进行任何更改。此选项
可用于检查在复制更改之前要传输
的数据。</p>
</dd>
<dt>–^nodata            复制分支更改而不复制</dt><dd><p>数据。复制包时，不允许使用
此选项。</p>
</dd>
</dl>
<p>转换选项    请参阅“转换选项”部分以了解更多信息。
–^user, –^password  源和目标的身份验证模式不同并且</p>
<blockquote>
<div><p>没有可用于目标身份验证的配置文件
的情况下使用的凭据。</p>
</div></blockquote>
<dl class="simple">
<dt>身份验证选项         请参阅“身份验证选项”部分以了解更多</dt><dd><p>信息。</p>
</dd>
</dl>
</div></blockquote>
<p>转换选项：</p>
<blockquote>
<div><dl>
<dt>–^trmode=(^copy|^name|^table –^trtable=&lt;转换表文件&gt;)</dt><dd><p>源和目标存储库可能使用不同的身份验证
模式。’–^trmode’ 选项指定如何将用户名从源
转换到目标。’–^trmode’ 必须为以下值
之一：</p>
<blockquote>
<div><p>^copy    （默认值）。表示只会复制用户标识符。
^name    按名称来匹配用户标识符。
^table   使用选项 ‘–^trtable’ 中指定的转换表</p>
<blockquote>
<div><p>（见下文）。</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p class="attribution">—^trtable=&lt;转换表文件&gt;
如果转换模式为 ‘table’，则转换表文件中包含
格式为 &lt;旧名称;新名称&gt; 的行（每行一个）。将分支
写入目标存储库时，源存储库中由“旧名称”
标识的用户所创建的对象将设置到目标上
具有“新名称”的用户。</p>
</div></blockquote>
<p>身份验证选项：</p>
<blockquote>
<div><p>可以使用以下两种模式之一来指定身份验证数据：</p>
<ol class="arabic">
<li><p>使用身份验证参数：–^authmode=&lt;模式&gt; –^authdata=&lt;数据&gt;</p>
<blockquote>
<div><p>–^authmode=(^NameWorkingMode|^LDAPWorkingMode|^ADWorkingMode|^UPWorkingMode)
示例：
(^LDAPWorkingMode) –^authdata=::0:dave:fPBea2rPsQaagEW3pKNveA
(^UPWorkingMode)   –^authdata=dave:fPBea2rPsQaagEW3pKNveA==</p>
<p>‘–^authdata’ 行是 client.conf 文件和 profiles.conf 文件
中的 &lt;^SecurityConfig&gt; 条目的内容。可以从
Plastic GUI 中的“首选项”下的“复制配置文件”选项卡
轻松生成 profiles.conf 文件。</p>
<p>如果使用 ^UPWorkingMode，则只需指定：</p>
<p class="attribution">—^authmode=^UPWorkingMode –^user=&lt;用户&gt; –^password=&lt;密码&gt;</p>
</div></blockquote>
</li>
<li><p>身份验证文件，对于连接到的每个服务器，文件可能会
有所不同，其中包含该服务器的凭据。</p>
<blockquote>
<div><dl class="simple">
<dt>–^authfile=&lt;身份验证文件&gt;</dt><dd><p>该文件包含 2 行：
第 1 行是模式，如 ‘–^authmode’ 中所述
第 2 行是身份验证数据，如 ‘–^authdata’ 中所述</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>== CMD_HELP_PULL ==
备注：</p>
<blockquote>
<div><p>‘^pull’ 命令可以在源存储库与目标存储库之间
复制分支（以及这些分支的变更集）。
这些存储库可以位于不同服务器中。</p>
<p>有两种复制操作：’^push’ 和 ‘^pull’。</p>
<p>‘^pull’ 操作表示复制操作要求将数据从源存储库
存储到目标存储库。
客户端将连接到目标存储库，然后建立
从该主机到源存储库的连接以便检索
目标数据。在拉取期间，目标服务器将
连接到源。</p>
<p>尽管在典型的分布式场景中，开发者会将数据
从本地服务器推送到主服务器，但开发者可能也希望
从主服务器拉取最新的存储库更新。</p>
<p>复制操作可以解决在同一分支上两个复制的存储库
已进行并发更改的情况：</p>
<ul class="simple">
<li><p>推送：如果尝试将数据推送到一个存储库，但这个存储库中的
更改比发送的更改更新，则系统会要求提取最新的更改，
解决合并操作问题，最后尝试再次推送。</p></li>
<li><p>拉取：每次从远程分支拉取变更集时，都会将这些变更集
正确链接到相应的父变更集。如果拉取的变更集不是
分支中最后一个变更集的子级，则会出现
一种多头场景。该分支将具有多个“头部”，即分支中的
最后一个变更集。此时需要先合并两个“头部”，
然后才能再次推送。</p></li>
</ul>
<p>可以按两种模式进行拉取：</p>
<ol class="arabic simple">
<li><p>服务器之间的直接通信：目标服务器将
从源服务器提取数据，自动为指定
分支同步数据。</p></li>
<li><p>使用推送和 ‘–^package’ 选项来导入先前生成的包。</p></li>
</ol>
<p>模式 1) 要求远程服务器对运行命令的用户进行身份验证，
方法是使用 client.conf 文件中的默认身份验证，
或者指定 ‘–^authmode’ 和 ‘–^authdata’ 修饰符
或 ‘–^authmode’、’–^user’ 和 ‘–^password’（如果身份验证模式为
^UPWorkingMode）。</p>
<p>模式 2) 要求使用先前通过推送命令生成的
包文件。</p>
<p>请记住，拉取复制是以间接方式进行的。执行时，
该命令要求目标存储库连接到源
并获取所选分支。</p>
<p>然而，可以使用推送命令来直接实现这一点。
因此，该命令会将所选分支从源复制到
目标。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^pull ^br:/main&#64;project1&#64;remoteserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;myserver">projectx<span>&#64;</span>myserver</a>:8084
（将 ‘main’ 分支从 ‘remoteserver’ 拉取到 ‘myserver’。这种情况下，
两个服务器会配置为相同的身份验证模式。）</p>
<dl class="simple">
<dt>cm ^pull ^br:/main&#64;project1&#64;remoteserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;myserver">projectx<span>&#64;</span>myserver</a>:8084 </dt><dd><p>–^authmode=^LDAPWorkingMode –^authdata=::0:dave:fPBea2rPsQaagEW3pKNveA</p>
</dd>
</dl>
<p>（拉取与以前相同的分支，但现在将远程服务器配置为
使用 Active Directory 对用户进行身份验证。例如，我正在从 Linux
计算机连接到配置为使用 Active Directory 集成模式
的 Windows 服务器。我会指定自己的 Active Directory 用户名和密码，
并以 LDAP 形式将此信息传递给服务器。）</p>
<dl class="simple">
<dt>cm ^pull ^br:/main&#64;project1&#64;remoteserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;myserver">projectx<span>&#64;</span>myserver</a>:8084 </dt><dd><p>–^authmode=^UPWorkingMode –^user=dave –^password=mysecret</p>
</dd>
</dl>
<p>（拉取同一个分支，但现在利用 Plastic SCM 中
包含的用户名/密码数据库在远程服务器上对用户
进行身份验证。）</p>
<p>cm ^pull ^br:/main&#64;project1&#64;remoteserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;myserver">projectx<span>&#64;</span>myserver</a>:8084 –^nodata
（将 ‘main’ 分支从 ‘remoteserver’ 复制到 ‘myserver’ 而不复制数据。）</p>
<p>cm ^pull ^hydrate ^br:/main&#64;projectx&#64;myserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;remoteserver">projectx<span>&#64;</span>remoteserver</a>:8084
（从远程服务器获取数据，对 ‘main’ 分支中的所有变更集
进行 hydrate 操作。）</p>
<p>cm ^pull ^hydrate ^cs:122169&#64;projectx&#64;myserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;remoteserver">projectx<span>&#64;</span>remoteserver</a>:8084
（从远程服务器获取数据，对 ‘myserver’ 中的变更集 122169 进行
hydrate 操作。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_PUSH ==
将分支推送到另一个存储库。</p>
<p>== CMD_USAGE_PUSH ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^push &lt;源分支规格&gt; &lt;目标存储库规格&gt;</dt><dd><blockquote>
<div><p>[–^preview] [转换选项]
[–^user=&lt;用户名&gt; [–^password=&lt;密码&gt;] | 身份验证选项]</p>
</div></blockquote>
<p>（服务器之间的直接复制。从存储库推送分支。）</p>
</dd>
<dt>cm ^push &lt;源分支规格&gt; –^package=&lt;包文件&gt; [身份验证选项]</dt><dd><p>（基于包的复制。使用所选分支在源服务器中
创建复制包。）</p>
</dd>
<dt>源分支规格     要推送到远程存储库的分支。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解分支规格。）</p>
</dd>
<dt>目标存储库规格    目标存储库。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
规格。）</p>
</dd>
<dt>–^package       指定复制包的导出路径，从而进行</dt><dd><p>基于包的复制。
适合在没有直接网络连接时用于在服务器
之间移动数据。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^preview           提供关于将推送哪些更改的信息，</dt><dd><p>但实际上不进行任何更改。此选项
可用于检查在复制更改之前要传输
的数据。</p>
</dd>
</dl>
<p>转换选项    请参阅“转换选项”部分以了解更多信息。
–^user, –^password  源和目标的身份验证模式不同并且</p>
<blockquote>
<div><p>没有可用于目标身份验证的配置文件
的情况下使用的凭据。</p>
</div></blockquote>
<dl class="simple">
<dt>身份验证选项         请参阅“身份验证选项”部分以了解更多</dt><dd><p>信息。</p>
</dd>
</dl>
</div></blockquote>
<p>转换选项：</p>
<blockquote>
<div><dl>
<dt>–^trmode=(^copy|^name|^table –^trtable=&lt;转换表文件&gt;)</dt><dd><p>源和目标存储库可能使用不同的身份验证
模式。’–^trmode’ 选项指定如何将用户名从源
转换到目标。’–^trmode’ 必须为以下值
之一：</p>
<blockquote>
<div><p>^copy    （默认值）。表示只会复制用户标识符。
^name    按名称来匹配用户标识符。
^table   使用选项 ‘–^trtable’ 中指定的转换表</p>
<blockquote>
<div><p>（见下文）。</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p class="attribution">—^trtable=&lt;转换表文件&gt;
如果转换模式为 ‘table’，则转换表文件中包含
格式为 &lt;旧名称;新名称&gt; 的行（每行一个）。将分支
写入目标存储库时，源存储库中由“旧名称”
标识的用户所创建的对象将设置到目标上
具有“新名称”的用户。</p>
</div></blockquote>
<p>身份验证选项：</p>
<blockquote>
<div><p>可以使用以下两种模式之一来指定身份验证数据：</p>
<ol class="arabic">
<li><p>使用身份验证参数：–^authmode=&lt;模式&gt; –^authdata=&lt;数据&gt;</p>
<blockquote>
<div><p>–^authmode=(^NameWorkingMode|^LDAPWorkingMode|^ADWorkingMode|^UPWorkingMode)
示例：
(^LDAPWorkingMode) –^authdata=::0:dave:fPBea2rPsQaagEW3pKNveA
(^UPWorkingMode)   –^authdata=dave:fPBea2rPsQaagEW3pKNveA==</p>
<p>‘–^authdata’ 行是 client.conf 文件和 profiles.conf 文件
中的 &lt;^SecurityConfig&gt; 条目的内容。可以从
Plastic GUI 中的“首选项”下的“复制配置文件”选项卡
轻松生成 profiles.conf 文件。</p>
<p>如果使用 ^UPWorkingMode，则只需指定：</p>
<p class="attribution">—^authmode=^UPWorkingMode –^user=&lt;用户&gt; –^password=&lt;密码&gt;</p>
</div></blockquote>
</li>
<li><p>身份验证文件，对于连接到的每个服务器，文件可能会
有所不同，其中包含该服务器的凭据。</p>
<blockquote>
<div><dl class="simple">
<dt>–^authfile=&lt;身份验证文件&gt;</dt><dd><p>该文件包含 2 行：
第 1 行是模式，如 ‘–^authmode’ 中所述
第 2 行是身份验证数据，如 ‘–^authdata’ 中所述</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>== CMD_HELP_PUSH ==
备注：</p>
<blockquote>
<div><p>‘^push’ 命令可以在源存储库与目标存储库之间
复制分支（以及这些分支的变更集）。
这些存储库可以位于不同服务器中。</p>
<p>有两种复制操作：’^push’ 和 ‘^pull’。</p>
<p>‘^push’ 操作表示复制操作会将数据从源存储库
发送到目标存储库。在这种情况下，
客户端将连接到源存储库，获取要复制的数据，
然后将数据发送到目标存储库。虽然
前者（源）必须与目标连接，但是后者（目标）
本身不会连接到源。</p>
<p>在典型的分布式场景中，开发者会将数据从本地服务器
推送到主服务器。此外，开发者可能也希望从主服务器
拉取最新的存储库更新。</p>
<p>复制可以解决在两个复制存储库的同一分支上
已进行并发更改的情况。</p>
<ul class="simple">
<li><p>推送：如果尝试将数据推送到一个存储库，但这个存储库中的
更改比发送的更改更新，则系统会要求提取最新的更改，
解决合并操作问题，最后尝试再次推送。</p></li>
<li><p>拉取：每次从远程分支拉取变更集时，都会将这些变更集
正确链接到相应的父变更集。如果拉取的变更集不是
分支中最后一个变更集的子级，则会出现
一种多头场景。该分支将具有多个“头部”，即分支中的
最后一个变更集。此时需要先合并两个“头部”，
然后才能再次推送。</p></li>
</ul>
<p>可以按两种模式进行推送：</p>
<ol class="arabic simple">
<li><p>服务器之间的直接通信：源服务器将
把数据发送到目标服务器，自动为指定
分支同步数据。</p></li>
<li><p>导出包模式：客户端将仅连接到源
并获取指定分支的数据和元数据来生成一个
复制包。此模式下将使用 ‘–^package’ 修饰符。</p></li>
</ol>
<p>这两种模式都要求服务器对运行命令的用户进行身份验证，
方法是使用 client.conf 文件中的默认身份验证，
或者指定 ‘–^authmode’ 和 ‘–^authdata’ 修饰符。</p>
<p>^push 推送复制是以直接方式进行的。执行时，
该命令将所选分支从源复制到目标
（而不是要求目标存储库连接到源）并获取
所选分支（与拉取操作一样）。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^push ^br:/main&#64;project1&#64;myserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;remoteserver">projectx<span>&#64;</span>remoteserver</a>:8084
（将 ‘main’ 分支从 ‘myserver’ 复制到 ‘remoteserver’。这种情况下，
两个服务器会配置为相同的身份验证模式。）</p>
<dl class="simple">
<dt>cm ^push ^br:/main&#64;project1&#64;myserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;remoteserver">projectx<span>&#64;</span>remoteserver</a>:8084 </dt><dd><p>–^authmode=^LDAPWorkingMode –^authdata=::0:dave:fPBea2rPsQaagEW3pKNveA</p>
</dd>
</dl>
<p>（复制与以前相同的分支，但现在将远程服务器配置为
使用 Active Directory 对用户进行身份验证。例如，我正在从 Linux
计算机连接到配置为使用 Active Directory 集成模式
的 Windows 服务器。我会指定自己的 Active Directory 用户名和密码，
并以 LDAP 形式将此信息传递给服务器。）</p>
<dl class="simple">
<dt>cm ^push ^br:/main&#64;project1&#64;myserver:8084 <a class="reference external" href="mailto:projectx&#37;&#52;&#48;remoteserver">projectx<span>&#64;</span>remoteserver</a>:8084 </dt><dd><p>–^authmode=^UPWorkingMode –^user=dave –^password=mysecret</p>
</dd>
</dl>
<p>（复制同一个分支，但现在利用 Plastic SCM 中
包含的用户名/密码数据库在远程服务器上对用户
进行身份验证。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_CLONE ==
克隆远程存储库。</p>
<p>== CMD_USAGE_CLONE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^clone &lt;源存储库规格&gt; [&lt;目标存储库规格&gt; | &lt;目标存储库服务器规格&gt;]</dt><dd><dl class="simple">
<dt>[–^user=&lt;用户名&gt; [–^password=&lt;密码&gt;] | 身份验证选项]</dt><dd><p>[转换选项]</p>
</dd>
</dl>
</dd>
</dl>
<p>（存储库之间的直接克隆。）</p>
<dl class="simple">
<dt>cm ^clone &lt;源存储库规格&gt; –^package=&lt;包文件&gt;</dt><dd><p>[–^user=&lt;用户名&gt; [–^password=&lt;密码&gt;] | 身份验证选项]</p>
</dd>
</dl>
<p>（克隆到中间包，随后可以使用拉取操作将中间包
导入到目标存储库。）</p>
<dl class="simple">
<dt>源存储库规格        克隆操作的源存储库。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
规格。）</p>
</dd>
<dt>目标存储库规格        克隆操作的目标存储库。如果</dt><dd><p>已存在，必须为空。如果不存在，
则会进行创建。
如果未指定，该命令将使用用户的
默认存储库服务器。
（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
规格。）</p>
</dd>
<dt>目标存储库服务器规格  克隆操作的目标存储库服务器。</dt><dd><p>如果存在与目标存储库服务器中的
&lt;源存储库规格&gt; 同名的存储库，此存储库
必须为空。如果没有，则会进行创建。
如果未指定，该命令将使用用户的
默认存储库服务器。
（使用 ‘cm ^help ^objectspec’ 可进一步了解存储库
服务器规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^user, –^password  源和目标的身份验证模式不同并且</dt><dd><p>没有可用于目标身份验证的配置文件
的情况下使用的凭据。</p>
</dd>
<dt>–^package           将指定的存储库导出到包文件，</dt><dd><p>而不是存储库。
适合在没有直接网络连接时用于在服务器
之间移动数据。
必须使用拉取命令来导入
生成的包。</p>
</dd>
</dl>
<p>转换选项    请参阅“转换选项”部分以了解更多信息。
身份验证选项         请参阅“身份验证选项”部分以了解更多</p>
<blockquote>
<div><p>信息。</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>转换选项：</dt><dd><dl>
<dt>–^trmode=(^copy|^name|^table –^trtable=&lt;转换表文件&gt;)</dt><dd><p>源和目标存储库可能使用不同的身份验证
模式。’–^trmode’ 选项指定如何将用户名从源
转换到目标。’–^trmode’ 必须为以下值
之一：</p>
<blockquote>
<div><p>^copy    （默认值）。表示只会复制用户标识符。
^name    按名称来匹配用户标识符。
^table   使用选项 ‘–^trtable’ 中指定的转换表</p>
<blockquote>
<div><p>（见下文）。</p>
</div></blockquote>
</div></blockquote>
</dd>
<dt>–^trtable=&lt;转换表文件&gt;</dt><dd><p>如果转换模式为 ‘table’，则转换表文件中包含
格式为 &lt;旧名称;新名称&gt; 的行（每行一个）。将分支
写入目标存储库时，源存储库中由“旧名称”
标识的用户所创建的对象将设置到目标上
具有“新名称”的用户。</p>
</dd>
</dl>
</dd>
</dl>
<p>身份验证选项：</p>
<blockquote>
<div><p>可以使用以下两种模式之一来指定身份验证数据：</p>
<ol class="arabic">
<li><p>使用身份验证参数：–^authmode=&lt;模式&gt; –^authdata=&lt;数据&gt;</p>
<blockquote>
<div><p>–^authmode=(^NameWorkingMode|^LDAPWorkingMode|^ADWorkingMode|^UPWorkingMode)
示例：
(^LDAPWorkingMode) –^authdata=::0:dave:fPBea2rPsQaagEW3pKNveA
(^UPWorkingMode)   –^authdata=dave:fPBea2rPsQaagEW3pKNveA==</p>
<p>‘–^authdata’ 行是 client.conf 文件和 profiles.conf 文件
中的 &lt;^SecurityConfig&gt; 条目的内容。可以从
Plastic GUI 中的“首选项”下的“复制配置文件”选项卡
轻松生成 profiles.conf 文件。</p>
<p>如果使用 ^UPWorkingMode，则只需指定：</p>
<p class="attribution">—^authmode=^UPWorkingMode –^user=&lt;用户&gt; –^password=&lt;密码&gt;</p>
</div></blockquote>
</li>
<li><p>身份验证文件，对于连接到的每个服务器，文件可能会
有所不同，其中包含该服务器的凭据。</p>
<blockquote>
<div><dl class="simple">
<dt>–^authfile=&lt;身份验证文件&gt;</dt><dd><p>该文件包含 2 行：
第 1 行是模式，如 ‘–^authmode’ 中所述
第 2 行是身份验证数据，如 ‘–^authdata’ 中所述</p>
</dd>
</dl>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>== CMD_HELP_CLONE ==
备注：</p>
<blockquote>
<div><p>克隆命令可以将分支（以及这些分支的变更集、
标签、属性、审查等）从源存储库复制到
目标存储库。这些存储库可以位于不同服务器中。</p>
<p>可以预先创建目标存储库，但是如果此存储库包含
以前的数据，克隆操作会失败。</p>
<p>克隆操作不会克隆存储库子模块，也不会克隆 Xlink 下的
存储库。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^clone awesomeProject&#64;tardis&#64;cloud
（将 ‘awesomeProject’ 存储库从 <a class="reference external" href="mailto:'tardis&#37;&#52;&#48;cloud">‘tardis<span>&#64;</span>cloud</a>’ 组织
克隆到同名的本地存储库。）</p>
<p>cm ^clone <a class="reference external" href="mailto:repo&#37;&#52;&#48;server&#46;home">repo<span>&#64;</span>server<span>&#46;</span>home</a>:9095 repo-local
（将 ‘repo’ 从 ‘server.home:9095’ 克隆到用户的默认存储库服务器
中的 ‘repo-local’。）</p>
<p>cm ^clone <a class="reference external" href="mailto:project&#37;&#52;&#48;192&#46;168&#46;111&#46;130">project<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>111<span>&#46;</span>130</a>:8084 ^repserver:192.168.111.200:9095
（将 ‘project’ 存储库从 ‘192.168.111.130:8084’ 克隆到
<a class="reference external" href="mailto:'project&#37;&#52;&#48;192&#46;168&#46;111&#46;200">‘project<span>&#64;</span>192<span>&#46;</span>168<span>&#46;</span>111<span>&#46;</span>200</a>:9095’。）</p>
<dl class="simple">
<dt>cm ^clone <a class="reference external" href="mailto:project&#37;&#52;&#48;ldapserver">project<span>&#64;</span>ldapserver</a>:8084 –authfile=credentials.txt </dt><dd><p>–^trmode=table –^trtable=table.txt</p>
</dd>
</dl>
<p>（从 ‘ldapserver:8084’ 克隆 ‘project’ 存储库，使用针对
远程存储库的身份验证文件，并按照指定的
转换表来转换用户。）</p>
<p>cm ^clone <a class="reference external" href="mailto:project&#37;&#52;&#48;server&#46;home">project<span>&#64;</span>server<span>&#46;</span>home</a>:9095 –^package=project.plasticpkg
cm ^repository ^create <a class="reference external" href="mailto:project&#37;&#52;&#48;mordor&#46;home">project<span>&#64;</span>mordor<span>&#46;</span>home</a>:8084
cm ^pull –^package=project.plasticpkg <a class="reference external" href="mailto:project&#37;&#52;&#48;mordor&#46;home">project<span>&#64;</span>mordor<span>&#46;</span>home</a>:8084
（将 ‘project’ 存储库从 ‘server.home:9095’ 克隆到包
‘project.plasticpkg’，随后通过拉取操作将这个包导入到
‘mordor.home:8084’ 的’project’ 存储库。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REVERT ==
将项还原到先前的修订。</p>
<p>== CMD_USAGE_REVERT ==
用法：</p>
<blockquote>
<div><p>cm ^revert &lt;修订规格&gt;</p>
<dl class="simple">
<dt>修订规格             包含修订（修订的内容将加载到工作区中）</dt><dd><p>的变更集的规格。
（使用 ‘cm ^help ^objectspec’ 可进一步了解修订
规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_REVERT ==
备注：</p>
<blockquote>
<div><p>必须签入项。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^revert dir#^cs:0
cm ^revert C:mywksdirfile1.txt#23456</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REVISION_HISTORY ==
显示文件或目录的历史记录。</p>
<p>== CMD_USAGE_REVISION_HISTORY ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^history | ^hist &lt;项路径&gt;[ …][–^long | –^format=&lt;格式字符串&gt;]</dt><dd><p>[–^symlink] [–^xml[=&lt;输出文件&gt;]] [–^encoding=&lt;名称&gt;]</p>
</dd>
<dt>项路径           项的路径。使用空格对各个路径进行分隔。使用</dt><dd><p>双引号 (” “) 指定包含空格的路径。
路径也可以是服务器路径修订。
（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^long              显示其他信息。
–^format            检索特定格式的输出消息。请参阅</p>
<blockquote>
<div><p>“备注”以了解更多信息。</p>
</div></blockquote>
<dl class="simple">
<dt>–^symlink           将历史记录操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
<dt>–^xml               以 XML 格式将输出打印到标准输出。</dt><dd><p>可以指定输出文件。</p>
</dd>
<dt>–^encoding          与 ‘–^xml’ 选项结合使用，指定要在 XML 输出</dt><dd><p>中使用的编码（例如：utf-8）。
请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_REVISION_HISTORY ==
备注：</p>
<blockquote>
<div><p>此命令将显示给定项的修订列表，以及每个修订的标签、
分支和注释信息。</p>
<p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{0} | {^date}              日期。
{1} | {^changesetid}       变更集编号。
{2} | {^branch}            分支。
{4} | {^comment}           注释。
{5} | {^owner}             所有者。
{6} | {^id}                修订 ID。
{7} | {^repository}        存储库。
{8} | {^server}            服务器。
{9} | {^repspec}           存储库规格。
{^tab}                     插入一个制表符空格位。
{^newline}                 插入一个新行。</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^history file1.txt “file 2.txt”</p>
<p>cm ^hist c:workspace –^long
（显示所有信息。）</p>
<p>cm ^history 链接 –^symlink
（将历史记录操作应用于 ‘链接’ 文件而不是目标，
适用于 UNIX 环境。）</p>
<p>cm ^history ^serverpath:/src/foo/bar.c#^br:<a class="reference external" href="mailto:/main/task001&#37;&#52;&#48;myserver">/main/task001<span>&#64;</span>myserver</a>
（从给定分支中的服务器路径检索修订历史记录。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_REVISION_TREE ==
显示项的修订树。</p>
<p>== CMD_USAGE_REVISION_TREE ==
用法：</p>
<blockquote>
<div><p>cm ^tree &lt;路径&gt; [–^symlink]</p>
<p>路径        项路径。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^symlink   将操作应用于链接文件而不是目标。</p>
</div></blockquote>
<p>== CMD_HELP_REVISION_TREE ==
示例：</p>
<blockquote>
<div><p>cm ^tree fichero1.txt
cm ^tree c:workspace
cm ^tree 链接 –^symlink
（将操作应用于链接文件而不是目标；适用于
UNIX 环境。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_RM ==
允许用户删除文件和目录。</p>
<p>== CMD_USAGE_RM ==
用法：</p>
<blockquote>
<div><p>cm ^remove | ^rm &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^controlled（可选）
^private</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^remove &lt;命令&gt; –^usage
cm ^remove &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_RM ==
示例：</p>
<blockquote>
<div><p>cm ^remove pathcontrolled_file.txt
cm ^remove ^private pathprivate_file.txt</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_RM_CONTROLLED ==
从版本控制中删除一个文件或目录。</p>
<p>== CMD_USAGE_RM_CONTROLLED ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^remove | ^rm &lt;项路径&gt;[ …][–^format=&lt;格式字符串&gt;]</dt><dd><p>[–^errorformat=&lt;格式字符串&gt;] [–^nodisk]</p>
</dd>
<dt>项路径           要删除的项路径。使用双引号 (” “) 指定</dt><dd><p>包含空格的路径。使用空格对各个路径进行
分隔。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format            检索特定格式的输出进度</dt><dd><p>消息。请参阅“示例”以了解更多信息。</p>
</dd>
<dt>–^errorformat       检索特定格式的错误消息</dt><dd><p>（如果有）。请参阅“示例”以了解更多信息。</p>
</dd>
<dt>–^nodisk            从版本控制中删除相应的项，但是将该项保留在</dt><dd><p>磁盘上。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_RM_CONTROLLED ==
备注：</p>
<blockquote>
<div><p>磁盘中会删除项。删除的项会从源代码管理
中的父目录中被删除。</p>
<p>要求：
- 项必须受源代码管理。</p>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^remove’ 命令可从 stdin 读取路径。为此，请传递一个
破折号 “-”。
示例：cm ^remove -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要删除的文件。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id29"><span class="problematic" id="id30">*</span></a>.c | cm ^remove -
（在 Windows 中，删除工作区中的所有 .c 文件。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^remove src
（删除 ‘src’。如果 src 是目录，则等同于
‘cm ^remove -^R src’。）</p>
<dl class="simple">
<dt>cm ^remove c:workspacefile.txt –^format=”{0} - 已删除” </dt><dd><p>–^errorformat=”{0} - 删除时出错”</p>
</dd>
</dl>
<p>（从版本控制中和磁盘上删除 ‘file.txt’，
如果操作成功，则写入 “c:workspacefile.txt - ^REMOVED”，
否则写入 “c:workspacefile.txt - ^ERROR ^REMOVING”。）</p>
<p>cm ^remove c:workspacefile.txt –^nodisk
（从版本控制中删除 ‘file.txt’，但将其保留在磁盘上。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_RM_PRIVATE ==
删除一个私有文件或目录。</p>
<p>警告：使用该命令删除的文件将被永久擦除而无法
恢复。建议使用 ‘–^dry-run’ 选项来检查
哪些文件将受到该命令的影响。</p>
<p>== CMD_USAGE_RM_PRIVATE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^remove | ^rm ^private &lt;路径&gt;[ …][-^R | -^r | –^recursive] [–^ignored]</dt><dd><p>[–^verbose] [–^dry-run]</p>
</dd>
<dt>路径                要删除的文件或目录的路径。使用双</dt><dd><p>引号 (” “) 指定包含空格的路径。使用
空格对各个路径进行分隔。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^r                 以递归方式从受控目录内删除私有</dt><dd><p>文件。</p>
</dd>
</dl>
<p>–^ignored           还删除已忽略和掩蔽的文件和目录。
–^verbose           打印所有受影响的路径。
–^dry-run           运行此命令而不在磁盘上进行任何更改。</p>
</div></blockquote>
<p>== CMD_HELP_RM_PRIVATE ==
备注：</p>
<blockquote>
<div><p>如果路径是私有文件或目录，则会从磁盘上将其删除。
如果路径是受控文件，该命令会失败。
如果路径是受控目录，则除非指定 ‘-^r’ 选项
，否则该命令将失败，在这种情况下，它将删除指定目录下的
所有私有文件和目录。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^remove ^private private_directory
（删除 ‘private_directory’。）</p>
<p>cm ^remove ^private c:workspacecontrolled_directory
（失败，因为 ‘controlled_directory’ 并非私有目录。）</p>
<p>cm ^remove ^private -^r c:workspacecontrolled_directory
（删除 ‘controlled_directory’ 下的所有私有文件和目录。）</p>
<p>cm ^rm ^private –^dry-run –^verbose c:workspacecontrolled_directory -^r
（显示 ‘controlled_directory’ 下的私有文件被删除所影响的
所有路径，实际上不删除任何内容。）</p>
<p>cm ^rm ^private –^verbose c:workspacecontrolled_directory -^r
（显示 ‘controlled_directory’ 下的私有文件被删除所影响的
所有路径，并执行删除。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_TRIGGER_DELETE ==
删除触发器。</p>
<p>== CMD_USAGE_TRIGGER_DELETE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^trigger | ^tr ^delete | ^rm &lt;子类型-类型&gt; &lt;位置编号&gt;</dt><dd><p>[–^server=&lt;存储库服务器规格&gt;]</p>
</dd>
<dt>子类型-类型        触发器执行和触发器操作。</dt><dd><p>键入 ‘cm ^showtriggertypes’ 可查看触发器类型
列表。</p>
</dd>
</dl>
<p>位置编号     创建触发器时分配给触发器的位置。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^server            删除指定服务器上的触发器。</dt><dd><p>如果未指定服务器，则在客户端上配置的
服务器上执行命令。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_TRIGGER_DELETE ==
示例：</p>
<blockquote>
<div><p>cm ^trigger ^delete ^after-setselector 4
cm ^tr ^rm ^after-setselector 4</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_ATTRIBUTE_SET ==
在给定对象上设置属性。</p>
<p>== CMD_USAGE_ATTRIBUTE_SET ==
用法：</p>
<blockquote>
<div><p>cm ^attribute | ^att ^set &lt;属性规格&gt; &lt;对象规格&gt; &lt;属性值&gt;</p>
<dl class="simple">
<dt>属性规格           属性的规格。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解属性规格。）</p>
</dd>
<dt>对象规格        要设置相应属性的对象的规格。</dt><dd><p>可以在以下对象上设置属性：分支、变更集、
搁置集、标签、项和修订。
（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
<p>属性值          要为对象设置的属性值。</p>
</div></blockquote>
<p>== CMD_HELP_ATTRIBUTE_SET ==
备注：</p>
<blockquote>
<div><p>可以在一个对象上设置属性来保存此对象的
其他信息。
可以在以下对象上设置属性：分支、变更集、
搁置集、标签、项和修订。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^attribute ^set ^att:status ^br:/main/SCM105 未完成
（将属性 ‘状态’ 设置为分支 ‘SCM105’，值为 ‘未完成’。）</p>
<p>cm ^att ^set ^att:integrated&#64;reptest&#64;server2:8084 ^lb:LB008&#64;reptest&#64;server2:8084 是
（在存储库 ‘reptest’ 中将属性 ‘集成’ 设置为标签 ‘LB008’，
值为 ‘是’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SETOWNER ==
设置对象的所有者。</p>
<p>== CMD_USAGE_SETOWNER ==
用法：</p>
<blockquote>
<div><p>cm ^setowner | ^sto –^user=&lt;用户名&gt; | –^group=&lt;组&gt; &lt;对象规格&gt;</p>
<p>–^user              用户名。对象的新所有者。
–^group             组名称。对象的新所有者。
对象规格         要设置新所有者的对象的规格。</p>
<blockquote>
<div><p>可以在以下对象上设置所有者：
存储库服务器、存储库、分支、变更集、
标签、项、修订和属性。
（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_SETOWNER ==
备注：</p>
<blockquote>
<div><p>对象的所有者可以是用户或组。</p>
<p>可以在以下对象上设置所有者：存储库服务器、
存储库、分支、变更集、标签、项、修订和属性。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^setowner –^user=john ^repserver:localhost:8084
（将 ‘john’ 设置为存储库服务器所有者。）</p>
<p>cm ^sto –^group=development ^rep:<a class="reference external" href="mailto:mainRep&#37;&#52;&#48;PlasticServer">mainRep<span>&#64;</span>PlasticServer</a>:8084
（将 ‘development’ 组设置为 ‘mainRep’ 存储库的所有者。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SETSELECTOR ==
将选择器设置为工作区。</p>
<p>== CMD_USAGE_SETSELECTOR ==
已弃用此命令。为了向后兼容，此命令仍然存在，
但是在 Plastic SCM 4.0 中，已在很大程度上弃用选择器。仍然存在的选择器
是为了指定工作分支或变更集，但不再支持
用于筛选路径的旧规则。</p>
<dl class="simple">
<dt>用法：</dt><dd><dl class="simple">
<dt>cm ^setselector | ^sts [–^file=&lt;选择器文件&gt;] [–^ignorechanges]</dt><dd><p>[–^forcedetailedprogress] [&lt;工作区路径&gt; | &lt;工作区规格&gt;]</p>
</dd>
</dl>
</dd>
</dl>
<p>选项：</p>
<blockquote>
<div><p>–^file                   要从中加载选择器的文件。
–^ignorechanges          忽略在更新工作区时</p>
<blockquote>
<div><p>检测到待定更改的情况下显示
的待定更改警告消息。</p>
</div></blockquote>
<dl class="simple">
<dt>–^forcedetailedprogress  即使在标准输出被重定向的情况下也要强制显示</dt><dd><p>详细进度。</p>
</dd>
</dl>
<p>工作区路径                  用于设置选择器的工作区的路径。
工作区规格                  工作区的规格。（使用 ‘cm ^help ^objectspec’</p>
<blockquote>
<div><p>可进一步了解工作区规格。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_SETSELECTOR ==
备注：</p>
<blockquote>
<div><p>此命令将设置工作区的选择器。</p>
<p>工作区需要某些信息才能从存储库加载修订。
为了获得这些信息，Plastic SCM 需要使用选择器。</p>
<p>通过使用选择器，可以从给定的分支、标签或
变更集加载修订。</p>
<p>如果未指定用于加载选择器的文件，则将执行默认的
操作系统编辑器。</p>
<p>示例选择器：</p>
<dl class="simple">
<dt>^repository “^default” // 工作存储库</dt><dd><dl class="simple">
<dt>^path “/”           // 规则将应用于根目录</dt><dd><p>^branch “/^main”   // 从 ^br:/^main 获取最新修订
^checkout “/^main” // 将签出内容放在 ^br:/^main 分支中</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^sts
（打开要应用的当前选择器文件。）</p>
<p>cm ^sts ^wk:<a class="reference external" href="mailto:workspace_projA&#37;&#52;&#48;reptest">workspace_projA<span>&#64;</span>reptest</a>
（打开要应用的指定选择器文件。）</p>
<p>cm ^setselector –^file=c:selectorssel.xml
（在当前工作区中设置指定的选择器文件。）</p>
<p>cm ^setselector –^file=c:selectorssel.xml ^wk:MyWorkspace
（在选定工作区中设置指定的选择器文件。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHELVE ==
搁置已签出项的内容。</p>
<p>== CMD_USAGE_SHELVE ==
已弃用此命令。请改用 ‘cm ^shelveset’。</p>
<p>用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^shelve [&lt;项路径&gt;+] [–^all] [–^dependencies]</dt><dd><p>[-^c=注释字符串 | -^commentsfile=&lt;注释文件&gt;]
[–^encoding=名称] [–^comparisonmethod=比较方法]</p>
</dd>
</dl>
<p>（搁置内容。）</p>
<p>cm ^shelve –^apply=&lt;搁置规格&gt; [–^mount]
（应用存储的搁置集。）</p>
<p class="attribution">—^apply             还原指定搁置集的已搁置内容。
搁置规格：查看 ‘cm ^help ^objectspec’。</p>
</div></blockquote>
<blockquote>
<div><p>cm ^shelve –^delete=&lt;搁置规格&gt;
（删除存储的搁置集。）</p>
<p class="attribution">—^delete            删除指定的搁置集。
搁置集规格：查看 ‘cm ^help ^objectspec’。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>项路径           要搁置的项（以空格分隔）。可以使用引号 (“)</dt><dd><p>来指定包含空格的路径。</p>
</dd>
<dt>–^all               还包括在给定路径上进行了本地更改、</dt><dd><p>移动和删除的项。</p>
</dd>
<dt>–^dependencies      在要搁置的项中包含本地更改</dt><dd><p>依赖项。</p>
</dd>
</dl>
<p>-^c                  将指定的注释应用于创建的搁置集。
-^commentsfile       将指定文件中的注释应用于创建的</p>
<blockquote>
<div><p>搁置集。</p>
</div></blockquote>
<dl class="simple">
<dt>–^encoding          指定输出编码，如：utf-8。</dt><dd><p>请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
</dl>
<p>–^comparisonmethod  设置比较方法。请参阅“备注”以了解更多信息。
–^mount             给定存储库的装入点。</p>
</div></blockquote>
<p>== CMD_HELP_SHELVE ==</p>
<p>备注：</p>
<blockquote>
<div><p>如果既没有指定 &lt;项路径&gt;，也没有指定任何其他选项，则搁置将涉及
工作区中的所有待定更改。</p>
<p>搁置操作始终以递归方式从给定路径应用。</p>
<p>搁置项的要求：
- 项必须受源代码管理。
- 必须签出或更改项（必须使用 –^all 选项）。</p>
<dl class="simple">
<dt>比较方法：</dt><dd><p>^ignoreeol               忽略行尾差异。
^ignorewhitespaces       忽略空格差异。
^ignoreeolwhitespaces    忽略行尾和空格差异。
^notignore               检测行尾和空格差异。</p>
</dd>
</dl>
<p>设置 PLASTICEDITOR 环境变量可指定用于键入注释的
编辑器。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^shelve -^c=”我的注释”
（搁置当前工作区中的所有待定更改，包括
注释。）</p>
<p>cm ^shelve file1.txt “file 2.txt” -^commentsfile=commentshelve.txt
（搁置选定的待定更改并应用 commentshelve.txt
文件中的注释。）</p>
<p>cm ^shelve –^apply=^sh:3
（应用存储的搁置集。）</p>
<p>cm ^shelve –^delete=^sh:3
（删除存储的搁置集。）</p>
<p>cm ^status –^short –^changelist=pending_to_review | cm ^shelve -
（搁置客户端更改列表。
以上命令将列出名为 ‘pending_to_review’
的更改列表中的路径，并且路径列表将重定向到
shelve 命令的输入。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHELVESET ==
允许用户管理搁置集。</p>
<p>== CMD_USAGE_SHELVESET ==
用法：</p>
<blockquote>
<div><p>cm ^shelveset &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^create | ^mk
^delete | ^rm
^apply</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^shelveset &lt;命令&gt; –^usage
cm ^shelveset &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_SHELVESET ==
示例：</p>
<blockquote>
<div><p>cm ^shelveset ^create -^c=”我的注释”
cm ^shelveset ^delete ^sh:3
cm ^shelve ^apply ^sh:3</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHELVESET_CREATE ==
搁置待定更改。</p>
<p>== CMD_USAGE_SHELVESET_CREATE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^shelveset ^create | ^mk [&lt;项路径&gt;[ …]] [–^all] [–^dependencies]</dt><dd><p>[-^c=&lt;注释字符串&gt; | -^commentsfile=&lt;注释文件&gt;]</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>项路径           要搁置的项。使用空格对各个用户名进行分隔。</dt><dd><p>使用双引号 (” “) 指定包含空格的
路径。</p>
</dd>
<dt>–^all               还包括在给定路径上进行了本地更改、</dt><dd><p>移动和删除的项。</p>
</dd>
<dt>–^dependencies      在要搁置的项中包含本地更改</dt><dd><p>依赖项。</p>
</dd>
</dl>
<p>-^c                  将指定的注释应用于创建的搁置。
-^commentsfile       将指定文件中的注释应用于创建的</p>
<blockquote>
<div><p>搁置。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_SHELVESET_CREATE ==
‘^shelveset ^create’ 命令可将已签出项的内容存储在</p>
<blockquote>
<div><p>存储库中。这样，无需签入文件便可以
保护内容。</p>
</div></blockquote>
<p>备注：</p>
<blockquote>
<div><p>如果既没有指定 &lt;项路径&gt;，也没有指定任何其他选项，则搁置集将
包含工作区中的所有待定更改。</p>
<p>‘^shelveset ^create’ 操作始终从给定路径以递归方式
应用。</p>
<p>搁置项的要求：
- 项必须受源代码管理。
- 必须签出或更改项（必须使用 ‘–^all’ 选项）。</p>
<p>设置 PLASTICEDITOR 环境变量可指定用于键入注释的
编辑器。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^shelveset ^create -^c=”我的注释”
（搁置当前工作区中的所有待定更改，包括
注释。）</p>
<p>cm ^shelveset file1.txt “file 2.txt” -^commentsfile=commentshelve.txt
（搁置选定的待定更改并应用 ‘commentshelve.txt’
文件中的注释。注意，’^create’ 是默认的子命令。）</p>
<p>cm ^status –^short –^changelist=pending_to_review | cm ^shelveset -
（搁置客户端更改列表。
以上命令将列出名为 ‘pending_to_review’
的更改列表中的路径，并且路径列表将重定向到
‘^shelveset’ 命令的输入。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHELVESET_DELETE ==
删除搁置集。</p>
<p>== CMD_USAGE_SHELVESET_DELETE ==
用法：</p>
<blockquote>
<div><p>cm ^shelveset ^delete | ^rm &lt;搁置规格&gt;</p>
<dl class="simple">
<dt>搁置规格             搁置集规格。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解搁置集规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_SHELVESET_DELETE ==
‘^shelveset ^delete’ 命令可删除搁置集。</p>
<p>示例：</p>
<blockquote>
<div><p>cm ^shelveset ^delete ^sh:3
（删除存储的搁置集。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHELVESET_APPLY ==
应用存储的搁置集。</p>
<p>== CMD_USAGE_SHELVESET_APPLY ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^shelveset ^apply &lt;搁置规格&gt; [–^mount] [–^encoding=&lt;名称&gt;]</dt><dd><dl class="simple">
<dt>[–^comparisonmethod=(^ignoreeol | ^ignorewhitespaces| </dt><dd><p>^ignoreeolwhitespaces | ^notignore)]</p>
</dd>
</dl>
</dd>
<dt>搁置规格             搁置集规格。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解搁置集规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^mount             给定存储库的装入点。
–^encoding          指定输出编码，如：utf-8。</p>
<blockquote>
<div><p>请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</div></blockquote>
<p>–^comparisonmethod  设置比较方法。请参阅“备注”以了解更多信息。</p>
</div></blockquote>
<p>== CMD_HELP_SHELVESET_APPLY ==
‘^shelveset ^apply’ 命令可还原存储的搁置集的内容。</p>
<p>备注：</p>
<blockquote>
<div><dl class="simple">
<dt>比较方法：</dt><dd><p>^ignoreeol               忽略行尾差异。
^ignorewhitespaces       忽略空格差异。
^ignoreeolwhitespaces    忽略行尾和空格差异。
^notignore               检测行尾和空格差异。</p>
</dd>
</dl>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^shelveset ^apply ^sh:3
（应用存储的搁置。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHOW_FIND_OBJECTS ==
列出对象和属性。</p>
<p>== CMD_USAGE_SHOW_FIND_OBJECTS ==
用法：</p>
<blockquote>
<div><p>cm ^showfindobjects</p>
</div></blockquote>
<p>== CMD_HELP_SHOW_FIND_OBJECTS ==
可用对象和属性：</p>
<dl>
<dt>^attribute:</dt><dd><p>可以通过使用以下字段进行筛选来查找属性：</p>
<p>^type    ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^attribute “^where ^type = ‘状态’”
（查找 ‘状态’ 类型的所有属性。）</p>
</dd>
</dl>
</div></blockquote>
<p>^value   ：字符串。
^date    ：日期。</p>
<blockquote>
<div><p>请在本指南中查看“日期常量”以了解更多信息。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^attribute “^where ^date &gt; ‘^this ^week’”
（查找本周内应用的所有属性。）</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>^owner   ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^attribute “^where ^value = ‘已解决’ ^and ^owner = ‘^me’”
（查找具有 ‘已解决’ 值并由我应用的所有属性。）</p>
</dd>
</dl>
</dd>
<dt>^GUID    ：全局唯一标识符。</dt><dd><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
</dd>
</dl>
<p>^comment ：字符串。
^srcobj  ：对象规格：项路径、分支、变更集、修订或标签。</p>
<blockquote>
<div><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定这些对象。</p>
<dl>
<dt>示例：</dt><dd><p>cm ^find ^attribute “^where ^srcobj = ‘^item:readme.txt’”
（查找应用于项 ‘readme.txt’ 的属性。）</p>
<p>cm ^find ^attribute “^where ^srcobj = ‘^br:/main/scm23343’”
（查找应用于分支 scm23343 的属性。）</p>
<p>cm ^find ^attribute “^where ^srcobj = ‘^rev:readme.txt#^br:/main/task002’”
（查找应用于指定修订的属性。）</p>
<p>cm ^find ^attribute “^where ^srcobj = ‘^rev:^revid:1126’”
（查找应用于指定修订 ID 的属性。）</p>
</dd>
</dl>
</div></blockquote>
<p>^ID      ：整数。</p>
</dd>
<dt>^attributetype:</dt><dd><p>可以通过使用以下字段进行筛选来查找属性类型：</p>
<p>^name    ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^attributetype “^where ^name ^like ‘st%’”
（查找名称以 ‘st’ 开头的所有属性。）</p>
</dd>
</dl>
</div></blockquote>
<p>^value   ：字符串。
^date    ：日期。</p>
<blockquote>
<div><p>请在本指南中查看“日期常量”以了解更多信息。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^attribute “^where ^date &gt; ‘^today’”
（查找今天应用的所有属性。）</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>^owner   ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
</dd>
<dt>^GUID    ：全局唯一标识符。</dt><dd><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
</dd>
</dl>
<p>^comment ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^attributetype “^where ^comment != ‘’” –^xml
（查找具有某个注释的所有属性类型，并且以 XML 格式
将输出打印到标准输出。）</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>^source  ：对象规格：项路径、分支、变更集或标签。</dt><dd><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定这些对象。</p>
<p>示例：</p>
<blockquote>
<div><p>cm ^find ^attributetype “^where ^source = ‘^item:readme.txt’”
（查找项 ‘readme.txt’ 中的所有属性类型。）</p>
<p>cm ^find ^attributetype “^where ^source = ‘^cs:30’”
（查找变更集 ‘30’ 中的所有属性类型。）</p>
<p>cm ^find ^attributetype “^where ^source = ‘^lb:v0.14.1’”
（查找标签 ‘v0.14.1’ 中的所有属性类型。）</p>
</div></blockquote>
</dd>
</dl>
<p>^ID      ：整数。</p>
<dl class="simple">
<dt>复制字段。查看下文的“与复制相关的字段”。</dt><dd><p>^ReplLogId
^ReplSrcDate
^ReplSrcId
^ReplSrcRepository
^ReplSrcServer</p>
</dd>
</dl>
</dd>
<dt>^branch:</dt><dd><p>可以通过使用以下字段进行筛选来查找分支：</p>
<p>^name       ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^branch “^where ^name ^like ‘scm23%’”
（查找名称以 ‘scm23’ 开头的分支。）</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>^date       ：日期。</dt><dd><p>请在本指南中查看“日期常量”以了解更多信息。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^branch “^where ^date &gt; ‘^one ^week ^ago’”
（查找上周创建的分支。）</p>
</dd>
</dl>
</dd>
<dt>^changesets ：日期（分支中变更集的日期）。</dt><dd><p>请在本指南中查看“日期常量”以了解更多信息。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^branch “^where ^changesets &gt;= ‘^today’”
（查找包含今天创建的变更集的分支。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^attribute  ：字符串。
^attrvalue  ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^branch “^where ^attribute = ‘状态’ ^and ^attrvalue = ‘已失败’”
（查找具有属性 ‘状态’ 且属性值为 ‘已失败’
的分支。）</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>^owner      ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
</dd>
<dt>^parent     ：分支规格。</dt><dd><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定此对象。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^branch “^where ^owner != ‘^me’ ^and ^parent != ‘^br:/main’”
（查找由我以外的人创建且父分支
不是 ‘/main’ 的分支。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^comment    ：字符串。
^GUID       ：全局唯一标识符。</p>
<blockquote>
<div><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
</div></blockquote>
<p>^ID         ：整数。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^branch “^where ^id = 2029607”
（查找 ID 为 2029607 的分支。）</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>复制字段。查看下文的“与复制相关的字段”。</dt><dd><p>^ReplLogId
^ReplSrcDate
^ReplSrcId
^ReplSrcRepository
^ReplSrcServer</p>
</dd>
</dl>
</dd>
<dt>^changeset:</dt><dd><p>可以通过使用以下字段进行筛选来查找变更集：</p>
<dl>
<dt>^branch            ：分支规格。</dt><dd><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定此
对象。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^changeset “^where ^branch = ‘/main/scm23119’”
（查找分支 ‘scm23119’ 中的所有变更集。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^changesetid       ：整数。
^attribute         ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^changeset “^where ^attribute = ‘状态’”
（查找包含属性 ‘状态’ 的变更集。）</p>
</dd>
</dl>
</div></blockquote>
<p>^attrvalue         ：字符串。
^date              ：日期。</p>
<blockquote>
<div><p>请在本指南中查看“日期常量”以了解更多信息。</p>
</div></blockquote>
<dl>
<dt>^owner             ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^changeset “^where ^date &gt;= ‘2018/8/6’ ^and ^owner != ‘^me’”
（查找创建日期等于或晚于 2018/8/6
并且由我以外的人创建的所有变更集。）</p>
</dd>
</dl>
</dd>
<dt>^GUID              ：全局唯一标识符。</dt><dd><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^changeset “^where ^guid = ‘1b30674f-14cc-4fd7-962b-676c8a6f5cb6’”
（查找具有指定 GUID 的变更集。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^comment           ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^changeset “^where ^comment = ‘’”
（查找不含注释的变更集。）</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>^onlywithrevisions ：布尔值。</dt><dd><p>筛选变更集是否具有修订。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^changeset “^where ^onlywithrevisions = ‘false’”
（查找不含修订的变更集。）</p>
</dd>
</dl>
</dd>
<dt>^returnparent      ：布尔值。</dt><dd><p>一种返回变更集父级的方法。非常适合用于编写脚本。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^changeset “^where ^changesetid = 29 ^and ^returnparent = ‘true’”
（查找变更集 29 的父级。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^parent            ：变更集 ID（整数）。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^changeset “^where ^parent = 548”
（查找父级为变更集 548 的所有变更集。）</p>
</dd>
</dl>
</div></blockquote>
<p>^ID                ：整数。</p>
<dl class="simple">
<dt>复制字段。查看下文的“与复制相关的字段”。</dt><dd><p>^ReplLogId
^ReplSrcDate
^ReplSrcId
^ReplSrcRepository
^ReplSrcServer</p>
</dd>
</dl>
</dd>
<dt>^label:</dt><dd><p>可以通过使用以下字段进行筛选来查找标签：</p>
<p>^name      ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^label “^where ^name ^like ‘7.0.16.%’”
（查找名称以 ‘7.0.16.’ 开头的标签。）</p>
</dd>
</dl>
</div></blockquote>
<p>^attribute ：字符串。
^attrvalue ：字符串。
^date      ：日期。</p>
<blockquote>
<div><p>请在本指南中查看“日期常量”以了解更多信息。</p>
<dl>
<dt>示例：</dt><dd><dl class="simple">
<dt>cm ^find ^label “^where ^date &gt;= ‘^this ^month’ ^and </dt><dd><p>^attribute = ‘发布状态’ ^and ^attrvalue != ‘已发布’”</p>
</dd>
</dl>
<p>（查找本月创建并且属性 ‘发布状态’ 设置为
‘已发布’ 以外的值的标签。）</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>^owner     ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
</dd>
<dt>^GUID      ：全局唯一标识符。</dt><dd><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
</dd>
<dt>^branch    ：分支规格。</dt><dd><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定此对象。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^label “^where ^branch = ‘/main’”
（查找应用于主分支的所有标签。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^branchid  ：整数。
^changeset ：变更集 ID（整数）。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^label “^where ^changeset = 111733”
（查找应用于变更集 111733 的标签。）</p>
</dd>
</dl>
</div></blockquote>
<p>^comment   ：字符串。
^ID        ：整数。</p>
<dl class="simple">
<dt>复制字段。查看下文的“与复制相关的字段”。</dt><dd><p>^ReplLogId
^ReplSrcDate
^ReplSrcId
^ReplSrcRepository
^ReplSrcServer</p>
</dd>
</dl>
</dd>
<dt>^merge:</dt><dd><p>可以通过使用以下字段进行筛选来查找合并：</p>
<dl>
<dt>^srcbranch    ：分支规格。</dt><dd><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定此对象。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^merge “^where ^srcbranch = ‘^br:/main’”
（从主分支中查找合并。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^srcchangeset ：变更集 ID（整数）。
^dstbranch    ：分支规格。</p>
<blockquote>
<div><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定此对象。</p>
</div></blockquote>
<p>^dstchangeset ：变更集 ID（整数）。</p>
<blockquote>
<div><dl>
<dt>示例：</dt><dd><dl class="simple">
<dt>cm ^find ^merge “^where ^dstchangeset = 108261” </dt><dd><p>–^format=”{^srcbranch} {^srcchangeset} {^dstbranch} {^dstchangeset} {^owner}”</p>
</dd>
</dl>
<p>（查找与变更集 108261 的合并，并打印
格式化的输出，从而显示源（分支和变更集 ID）、
目标（分支和变更集 ID）和合并所有者。）</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>^date         ：日期。</dt><dd><p>请在本指南中查看“日期常量”以了解更多信息。</p>
</dd>
<dt>^owner        ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
</dd>
<dt>^GUID         ：全局唯一标识符。</dt><dd><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
</dd>
<dt>^type         ：字符串。</dt><dd><dl class="simple">
<dt>可能的值有 ‘^merge’、’^cherrypick’、</dt><dd><p>‘^cherrypicksubstractive’、’^interval’、’^intervalcherrypick’
和 ‘^intervalcherrypicksubstractive’</p>
</dd>
<dt>示例：</dt><dd><p>cm ^find ^merge “^where ^type = ‘^cherrypick’ ^and ^owner = ‘^me’”
（查找我所有的挑拣。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^ID           ：整数。</p>
</dd>
<dt>^replicationlog:</dt><dd><p>可以通过使用以下字段进行筛选来查找复制日志：</p>
<dl>
<dt>^branch         ：分支规格。</dt><dd><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定此对象。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^replicationlog “^where ^branch = ‘/main/gm22358’”
（查找分支 ‘gm22358’ 的复制日志。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^repositoryname ：字符串。
^owner          ：用户。</p>
<blockquote>
<div><p>容许特殊用户 ‘^me’。</p>
</div></blockquote>
<dl class="simple">
<dt>^date           ：日期。</dt><dd><p>请在本指南中查看“日期常量”以了解更多信息。</p>
</dd>
</dl>
<p>^server         ：字符串。
^package        ：布尔值。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^replicationlog “^where ^package = ‘T’ ^and ^server ^like ‘%cloud%’”
（查找从服务器名称中包含 ‘cloud’ 的包
创建的复制日志。）</p>
</dd>
</dl>
</div></blockquote>
<p>^ID             ：整数。</p>
</dd>
<dt>^review:</dt><dd><p>可以通过使用以下字段进行筛选来查找代码审查：</p>
<p>^status     ：字符串。
^assignee   ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^review “^where ^status = ‘待定’ ^and ^assignee = ‘^me’”
（查找我所有的待定审查。）</p>
</dd>
</dl>
</div></blockquote>
<p>^title      ：字符串。
^target     ：对象规格：分支或变更集。</p>
<blockquote>
<div><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定此对象。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^review “^where ^target = ‘^br:/main/scm17932’”
（查找与分支 ‘scm17932’ 相关的审查。）</p>
</dd>
</dl>
</div></blockquote>
<p>^targetid   ：整数。
^targettype ：字符串。</p>
<blockquote>
<div><p>可能的值有 ‘^branch’ 和 ‘^changeset’。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^review “^where ^targettype = ‘^changeset’”
（查找目标类型为变更集的审查。）</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>^date       ：日期。</dt><dd><p>请在本指南中查看“日期常量”以了解更多信息。</p>
</dd>
<dt>^owner      ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
</dd>
<dt>^GUID       ：全局唯一标识符。</dt><dd><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
</dd>
</dl>
<p>^ID         ：整数。</p>
</dd>
<dt>^revision:</dt><dd><p>可以通过使用以下字段进行筛选来查找修订：</p>
<dl class="simple">
<dt>^branch              ：分支规格。</dt><dd><p>使用 ‘cm ^help ^objectspec’ 可了解如何指定此对象。</p>
</dd>
</dl>
<p>^changeset           ：变更集 ID（整数）。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^revision “^where ^changeset &gt;= 111756”
（查找在变更集 111756 以及更高版本中
创建的修订。）</p>
</dd>
</dl>
</div></blockquote>
<p>^item                ：字符串或整数。
^itemid              ：整数。</p>
<blockquote>
<div><dl>
<dt>示例：</dt><dd><p>cm ^find ^revision “^where ^item = ‘readme.txt’ ^or ^itemid = 2250”
（查找项 ‘readme.txt’ 和项 ID 2250
的修订。）</p>
<p>cm ^find ^revision “^where ^item = ‘readme.txt’ ^or ^item = 2250”
（获取与先前示例相同的修订。）</p>
</dd>
</dl>
</div></blockquote>
<p>^attribute           ：字符串。
^attrvalue           ：字符串。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^revision “^where ^attribute = ‘状态’ ^and ^attrvalue != ‘未完成’”
（查找包含属性 ‘状态’ 且属性值
不是 ‘未完成’ 的修订。）</p>
</dd>
</dl>
</div></blockquote>
<p>^archived            ：布尔值。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^revision “^where ^archived = ‘true’”
（查找在外部存储中存档
的修订。）</p>
</dd>
</dl>
</div></blockquote>
<p>^comment             ：字符串。
^date                ：日期。</p>
<blockquote>
<div><p>请在本指南中查看“日期常量”以了解更多信息。</p>
</div></blockquote>
<dl class="simple">
<dt>^GUID                ：全局唯一标识符。</dt><dd><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
</dd>
<dt>^owner               ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
</dd>
</dl>
<p>^parent              ：修订 ID（整数）。
^returnparent        ：布尔值。
^shelve              ：搁置 ID（整数）。
^size                ：整数（以字节为单位）。
^type                ：字符串。</p>
<blockquote>
<div><p>可能的值有 ‘^dir’、’^bin’ 和 ‘^txt’。</p>
<dl>
<dt>示例：</dt><dd><dl class="simple">
<dt>cm ^find ^revision “^where ^type = ‘^txt’ and </dt><dd><p>^size &gt; 300000 ^and ^owner = ‘^me’ and ^date &gt;= ‘2 ^months ^ago’”</p>
</dd>
</dl>
<p>（查找我两个月前创建且大小
大于 3MB 的文本修订。）</p>
</dd>
</dl>
</div></blockquote>
<p>^workspacecheckoutid ：整数。
^ID                  ：整数。</p>
<dl class="simple">
<dt>复制字段。查看下文的“与复制相关的字段”。</dt><dd><p>^ReplLogId
^ReplSrcDate
^ReplSrcId
^ReplSrcRepository
^ReplSrcServer</p>
</dd>
</dl>
</dd>
<dt>^shelve:</dt><dd><p>可以通过使用以下字段进行筛选来查找搁置：</p>
<dl>
<dt>^owner     ：用户。</dt><dd><p>容许特殊用户 ‘^me’。</p>
</dd>
<dt>^date      ：日期。</dt><dd><p>请在本指南中查看“日期常量”以了解更多信息。</p>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^shelve “^where ^owner != ‘^me’ ^and ^date &gt;= ‘^1 ^years ^ago’”
（查找去年我以外的人创建的
搁置。）</p>
</dd>
</dl>
</dd>
</dl>
<p>^attribute ：字符串。
^attrvalue ：字符串。
^comment   ：字符串。
^GUID      ：全局唯一标识符。</p>
<blockquote>
<div><p>十六进制 ID，格式为 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx。</p>
</div></blockquote>
<p>^parent    ：整数。
^shelveid  ：整数。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^shelve “^where ^shelveid = 2”
（查找名称为 2 的搁置。）</p>
</dd>
</dl>
</div></blockquote>
<p>^ID        ：整数。</p>
<blockquote>
<div><dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^shelve “^where ^id &gt;= 3848”
（查找对象 ID 大于 3848 的搁置。）</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>复制字段。查看下文的“与复制相关的字段”。</dt><dd><p>^ReplLogId
^ReplSrcDate
^ReplSrcId
^ReplSrcRepository
^ReplSrcServer</p>
</dd>
</dl>
</dd>
<dt>与复制相关的字段：</dt><dd><p>许多对象会跟踪复制数据，这意味着 Plastic 会跟踪最初创建复制
的位置。</p>
<p>可以使用的字段包括：</p>
<blockquote>
<div><dl>
<dt>^ReplSrcServer     ：存储库规格。表示“复制源服务器”。</dt><dd><blockquote>
<div><p>从中复制对象的服务器。</p>
</div></blockquote>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^branch “^where ^replsrcserver=’skull.codicefactory.com:9095’”
（查找从服务器 ‘skull’ 复制的分支。）</p>
</dd>
</dl>
</dd>
<dt>^ReplSrcRepository ：字符串。表示“复制源存储库”。这是</dt><dd><blockquote>
<div><p>从中复制对象的存储库。</p>
</div></blockquote>
<dl>
<dt>示例：</dt><dd><dl class="simple">
<dt>cm ^find ^branch “^where ^replsrcserver = ‘skull.codicefactory.com:9095’ </dt><dd><p>^and ^replsrcrepository = ‘codice’”</p>
</dd>
</dl>
<p>（查找从服务器 ‘skull’ 和存储库 ‘codice’
复制的分支。）</p>
</dd>
</dl>
</dd>
<dt>^ReplLogId         ：整数。复制操作的 ID。在 Plastic 中，</dt><dd><blockquote>
<div><p>每次从复本创建新对象时，
都会创建一个新的 ‘replicationlog’。</p>
</div></blockquote>
<dl class="simple">
<dt>示例：</dt><dd><p>cm ^find ^revision “^where ^repllogid = 2019974”
（查找从复本 2019974 复制
的修订。）</p>
</dd>
</dl>
</dd>
<dt>^ReplSrcDate       ：日期。这是实际发生复制的</dt><dd><blockquote>
<div><p>日期。
复制的对象将保留其原始创建
日期，如果要查找在特定时间
范围内复制的对象，则此字段
很有用。</p>
</div></blockquote>
<dl>
<dt>示例：</dt><dd><dl class="simple">
<dt>cm ^find ^label “^where ^replsrcdate &gt;= ‘^one ^month ^ago’ </dt><dd><p>^and ^date &gt;= ‘15 ^days ^ago’”</p>
</dd>
</dl>
<p>（查找 15 天前创建并在一个月前
复制的标签。）</p>
<p>cm ^find ^replicationlog “^where ^date &gt; ‘^one ^week ^ago’”
8780433  27/09/2018 8:49:38 <a class="reference external" href="mailto:codice&#37;&#52;&#48;BACKYARD">codice<span>&#64;</span>BACKYARD</a>:8087 F   mbarriosc
（查找一周前创建的复制日志。）</p>
<p>现在可以检查复制的分支是否是
在复制之前创建的：</p>
<p>cm ^find ^branch “^where ^repllogid = 8780433”
8780443  26/09/2018 12:20:55 /main/scm23078 maria    codice T</p>
</dd>
</dl>
</dd>
<dt>^ReplSrcId         ：整数。这是复制源服务器的 ID。</dt><dd><blockquote>
<div><p>可以使用 ‘cm ^find’ 命令搜索
‘^replicationsource’ 对象来发现此 ID。</p>
</div></blockquote>
<dl>
<dt>示例：</dt><dd><p>cm ^find ^replicationsource
7860739  <a class="reference external" href="mailto:codice&#37;&#52;&#48;AFRODITA">codice<span>&#64;</span>AFRODITA</a>:8087 d9c4372a-dc55-4fdc-ad3d-baeb2e975f27
8175854  <a class="reference external" href="mailto:codice&#37;&#52;&#48;BACKYARD">codice<span>&#64;</span>BACKYARD</a>:8087 66700d3a-036b-4b9a-a26f-adfc336b14f9</p>
<p>现在可以查找从 <a class="reference external" href="mailto:codice&#37;&#52;&#48;AFRODITA">codice<span>&#64;</span>AFRODITA</a>:8087
复制的变更集：</p>
<p>cm ^find ^changesets “^where ^replsrcid = 7860739”</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>日期常量：</dt><dd><p>可以使用遵循计算机本地化设置的日期格式。
例如，如果计算机以 ‘MM-dd-yyyy’ 格式显示日期，
则可以在查询中使用 ‘12-31-2019’ 之类的日期。</p>
<dl class="simple">
<dt>还可以使用以下常量来简化查询：</dt><dd><p>‘^today’         ：今天的日期。
‘^yesterday’     ：昨天的日期。
‘^this ^week’     ：本周星期一的日期。
‘^this ^month’    ：本月第一天的日期。
‘^this ^year’     ：本年 1 月 1 日。
‘^one ^day ^ago’   ：当前日期前一天。
‘^one ^week ^ago’  ：当前日期前七天。
‘^one ^month ^ago’ ：当前日期前一个月。
‘n ^days ^ago’    ：当前日期前 ‘n’ 天。
‘n ^months ^ago’  ：当前日期前 ‘n’ 个月。
‘n ^years ^ago’   ：当前日期前 ‘n’ 年。</p>
</dd>
<dt>以下 ‘^where’ 子句对于类型为 ‘^date’ 的字段有效：</dt><dd><p>‘(…)^where ^date &gt; ‘^today’ (…)’
‘(…)^where ^date &lt; ‘^yesterday’ (…)’
‘(…)^where ^date &gt; ‘^this ^week’ (…)’
‘(…)^where ^date &gt; ‘^this ^month’ (…)’
‘(…)^where ^date &lt; ‘^one ^day ^ago’ ^and ^date &gt; ‘3 ^days ^ago’ (…)’
‘(…)^where ^date &lt; ‘^one ^week ^ago’ ^and ^date &gt; ‘3 ^weeks ^ago’ (…)’
‘(…)^where ^date &lt; ‘^one ^month ^ago’ ^and ^date &gt; ‘3 ^months ^ago’ (…)’
‘(…)^where ^date &gt; ‘1 ^year ^ago’ (…)’</p>
</dd>
</dl>
<p>还可以在 ‘cm ^find’ 命令中强制使用特定日期格式，方法是使用
–^dateformat 标志。请查看 ‘cm ^find –^help’ 以了解更多详细信息。</p>
</dd>
</dl>
<p>== CMD_DESCRIPTION_TRIGGER_SHOWTYPES ==
显示可用的触发器类型。</p>
<p>== CMD_USAGE_TRIGGER_SHOWTYPES ==
用法：</p>
<blockquote>
<div><p>cm ^trigger ^showtypes</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHOWACL ==
显示对象的 ACL。</p>
<p>== CMD_USAGE_SHOWACL ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^showacl | ^sa &lt;对象规格&gt; [–^extended] [–^xml[=&lt;输出文件&gt;]]</dt><dd><p>[–^encoding=&lt;名称&gt;]</p>
</dd>
<dt>对象规格         要显示相应 ACL 的对象的规格。</dt><dd><p>此命令的有效对象为：
存储库服务器、存储库、分支、变更集、标签、项
和属性。
（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^extended        显示 ACL 层次结构树。
–^xml             以 XML 格式将输出打印到标准输出。</p>
<blockquote>
<div><p>可以指定输出文件。</p>
</div></blockquote>
<dl class="simple">
<dt>–^encoding        与 ‘–^xml’ 选项结合使用，指定要在 XML 输出</dt><dd><p>中使用的编码（例如：utf-8）。
请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_SHOWACL ==
示例：</p>
<blockquote>
<div><p>cm ^showacl ^repserver:PlasticServer:8084
（显示所选服务器的 ACL。）</p>
<p>cm ^sa ^br:/main –^extended
（显示所选分支规格的 ACL 层次结构树。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHOWCOMMANDS ==
显示所有可用命令。</p>
<p>== CMD_USAGE_SHOWCOMMANDS ==
用法：</p>
<blockquote>
<div><p>cm ^showcommands</p>
</div></blockquote>
<p>== CMD_HELP_SHOWCOMMANDS ==</p>
<p>== CMD_DESCRIPTION_SHOWOWNER ==
显示对象的所有者。</p>
<p>== CMD_USAGE_SHOWOWNER ==
用法：</p>
<blockquote>
<div><p>cm ^showowner | ^so &lt;对象规格&gt;</p>
<dl class="simple">
<dt>对象规格         要显示相应所有者的对象的规格。</dt><dd><p>对象必须为下列其中之一：
存储库服务器、存储库、分支、变更集、
标签、属性、修订和项。
（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_SHOWOWNER ==
备注：</p>
<blockquote>
<div><p>此命令将显示对象的所有者。所有者可以是用户或
组。可以使用 ‘cm ^setowner’ 命令修改所有者。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^showowner ^repserver:PlasticServer:8084
（显示所选服务器的所有者。）</p>
<p>cm ^so ^item:samples（显示所选项规格的所有者。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHOWPERMISSIONS ==
列出可用的权限。</p>
<p>== CMD_USAGE_SHOWPERMISSIONS ==
用法：</p>
<blockquote>
<div><p>cm ^showpermissions | ^sp</p>
</div></blockquote>
<p>== CMD_HELP_SHOWPERMISSIONS ==
示例：</p>
<blockquote>
<div><p>cm ^showpermissions</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SHOWSELECTOR ==
显示工作区选择器。</p>
<p>== CMD_USAGE_SHOWSELECTOR ==
已弃用此命令。为了向后兼容，此命令仍然存在，
但是在 Plastic SCM 4.0 中，已在很大程度上弃用选择器。仍然存在的选择器
是为了指定工作分支或变更集，但不再支持
用于筛选路径的旧规则。</p>
<p>用法：</p>
<blockquote>
<div><p>cm ^showselector | ^ss [&lt;工作区路径&gt; | &lt;工作区规格&gt;]</p>
<p>工作区路径             用于显示选择器的工作区的路径。
工作区规格             工作区的规格。（使用 ‘cm ^help ^objectspec’ 可</p>
<blockquote>
<div><p>可进一步了解工作区规格。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_SHOWSELECTOR ==
备注：</p>
<blockquote>
<div><p>如果路径和工作区规格均未指定，则该命令将采用
当前目录作为工作区路径。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^showselector c:workspace
（显示所选工作区路径的选择器。）</p>
<p>cm ^ss
（显示当前工作区的选择器。）</p>
<p>cm ^showselector &gt; mySelector.txt
（将当前工作区的选择器写入文件。）</p>
<p>cm ^showselector ^wk:<a class="reference external" href="mailto:mywk&#37;&#52;&#48;reptest">mywk<span>&#64;</span>reptest</a>
（显示存储库 ‘reptest’ 中的工作区 ‘mywk’ 的选择器。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SUPPORT ==
允许用户执行与支持相关的操作。</p>
<p>== CMD_USAGE_SUPPORT ==
用法：</p>
<blockquote>
<div><p>cm ^support &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^bundle</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^support &lt;命令&gt; –^usage
cm ^support &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_SUPPORT ==
示例：</p>
<blockquote>
<div><p>cm ^support
cm ^support ^bundle
cm ^support ^bundle c:outputfile.zip</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SUPPORT_BUNDLE ==
创建带有相关日志的“支持捆绑包”包。
可以在请求帮助、询问其他信息或者提交 bug 时
附加该文件。</p>
<p>== CMD_USAGE_SUPPORT_BUNDLE ==
用法：</p>
<blockquote>
<div><p>cm ^support ^bundle [&lt;输出文件&gt;]</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>输出文件          在指定的位置创建“支持捆绑包”</dt><dd><p>包。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_SUPPORT_BUNDLE ==
备注：</p>
<p>此命令允许用户创建一个“支持捆绑包”包，然后便可在请求帮助、
询问其他信息或提交 bug 时附加这个包。
用户可以选择指定输出文件的位置；否则，
输出文件将写入到临时目录。</p>
<p>示例：</p>
<blockquote>
<div><p>cm ^support ^bundle
（在临时目录中创建“支持捆绑包”。）</p>
<p>cm ^support ^bundle c:outputfile.zip
（在指定位置创建“支持捆绑包”。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SWITCH ==
将工作区切换到分支、变更集、标签或搁置集。</p>
<p>== CMD_USAGE_SWITCH ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^switch (&lt;分支规格&gt; | &lt;变更集规格&gt; | &lt;标签规格&gt; | &lt;搁置规格&gt;)</dt><dd><p>[–^workspace=&lt;路径&gt;] [–^repository=&lt;名称&gt;]
[–^forcedetailedprogress]</p>
</dd>
</dl>
<p>（使用 ‘cm ^help ^objectspec’ 可进一步了解分支、变更集、标签、
和搁置集规格。）</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>–^workspace             工作区所在的路径。
–^repository            切换到指定的存储库。
–^forcedetailedprogress 即使在标准输出被重定向的情况下也要强制</p>
<blockquote>
<div><p>显示详细进度。</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_SWITCH ==
备注：</p>
<blockquote>
<div><p>此命令允许用户将工作区树更新为指定对象
（分支、标签、搁置集或变更集）的内容。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^switch ^br:/main
cm ^switch ^lb:Rel1.1
cm ^switch ^br:/main/scm002 –^repository=rep2
cm ^switch ^cs:4375
cm ^switch ^sh:2</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SWITCH_TO_BRANCH ==
将分支设置为工作分支。</p>
<p>== CMD_USAGE_SWITCH_TO_BRANCH ==
已弃用此命令。请改用 cm switch。</p>
<p>用法：</p>
<blockquote>
<div><p>cm ^switchtobranch [选项] [分支规格]</p>
<p>分支规格：分支的规格。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^label=名称 | –^changeset=数字：从指定标签或变更集</dt><dd><p>加载修订。如果未提供任何分支规格，则需要这些选项
之一。</p>
</dd>
</dl>
<p>–^changeset=变更集：切换到指定的变更集。
–^repository=存储库：切换到指定的存储库。
–^workspace | -wk=路径：工作区所在的路径。</p>
</div></blockquote>
<p>== CMD_HELP_SWITCH_TO_BRANCH ==
备注：</p>
<blockquote>
<div><p>此命令允许用户在分支中工作。
如果未指定分支规格，则必须指定标签或变更集。
如果未指定存储库，则分支将设置为当前存储库。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^switchtobranch ^br:/main
cm ^switchtobranch ^br:/main/task001</p>
<p>cm ^switchtobranch –^label=BL050
（只读配置。该命令将加载已标记的变更集
的内容。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_SYNC ==
与 Git 同步。</p>
<p>== CMD_USAGE_SYNC ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^synchronize | ^sync &lt;存储库规格&gt; ^git [&lt;url&gt; [–^user=&lt;用户名&gt; –^pwd=&lt;密码&gt;]]</dt><dd><dl class="simple">
<dt>[(–^txtsimilaritypercent | –^binsimilaritypercent | </dt><dd><p>–^dirsimilaritypercent)=&lt;值&gt;]</p>
</dd>
</dl>
<p>[–^author] [–^skipgitlfs]</p>
</dd>
<dt>存储库规格             存储库的规格。（使用 ‘cm ^help ^objectspec’ 可</dt><dd><p>进一步了解存储库规格。）</p>
</dd>
</dl>
<p>git                 （默认值）。</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>url                       远程存储库 URL（http(s):// 或 git:// 或</dt><dd><p>SSH URL）。</p>
</dd>
</dl>
<p>–^user                    指定的 URL 的用户名。
–^pwd                     指定的 URL 的密码。
–^txtsimilaritypercent –^binsimilaritypercent –^dirsimilaritypercent</p>
<blockquote>
<div><p>要检测已移动的项，与 Plastic SCM GUI 的
方法相同。</p>
</div></blockquote>
<dl class="simple">
<dt>–^author                  使用 Git 作者提供的名称和时间戳值。</dt><dd><p>（默认为 Git 提交者）</p>
</dd>
<dt>–^skipgitlfs              忽略 .gitattributes 文件中的</dt><dd><p>Git LFS 配置。行为类似于不支持
Git LFS。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_SYNC ==
备注：</p>
<blockquote>
<div><p>如果 Git 存储库需要用户名和密码，则应使用 ‘^url’、’–^user’、
和 ‘–^pwd’ 选项。
如果 Git 存储库不需要用户名和密码，则应在第一次同步
操作中使用 ‘^url’ 选项。在后续的同步操作中，’^url’
选项是可选的。</p>
<p>要使用 SSH 协议执行同步，必须将 ‘ssh’ 客户端
添加到 PATH 环境变量，并正确配置为连接到
远程主机（即配置私钥/公钥）。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^sync <a class="reference external" href="mailto:default&#37;&#52;&#48;localhost">default<span>&#64;</span>localhost</a>:8087 ^git git://localhost/repository</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_TRIGGER ==
允许用户管理触发器。</p>
<p>== CMD_USAGE_TRIGGER ==
用法：</p>
<blockquote>
<div><p>cm ^trigger | ^tr &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^create | ^mk
^delete | ^rm
^edit
^list   | ^ls
^showtypes</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^trigger &lt;命令&gt; –^usage
cm ^trigger &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_TRIGGER ==
示例：</p>
<blockquote>
<div><p>cm ^tr ^mk ^before-mklabel new “/path/to/script” –^server=myserver:8084
cm ^tr ^edit ^before-mklabel 7 –^position=4 –^server=myserver:8084
cm ^tr ^ls ^before-mkbranch –^server=myserver:8084
cm ^tr ^rm ^after-setselector 4
cm ^tr ^showtypes</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_TUBE ==
运行与 Plastic Tube 有关的命令。</p>
<p>== CMD_USAGE_TUBE ==
用法：</p>
<blockquote>
<div><p>cm ^tube ^config -^u=&lt;用户&gt; -^p=&lt;密码&gt;
（配置 Plastic SCM 以将 Plastic Tube 与指定的用户和密码
配合使用。）</p>
<p>cm ^tube ^create &lt;远程用户&gt;
（创建 Tube“远程用户 -&gt; 我的用户”。
用户“我的用户”允许“远程用户”连接到“我的用户”服务器。
可以建立从“远程用户”到“我的用户”的连接。
只能创建其他用户到当前 Tube 用户的 Tube。）</p>
<p>cm ^tube ^remove &lt;远程用户&gt;
（删除 Tube“远程用户 -&gt; 我的用户”。）</p>
<p>cm ^tube ^local
（列出在本地服务器上共享的本地存储库以及共享到
的用户。）</p>
<p>cm ^tube ^remote
（列出与当前 Tube 用户共享的共享远程
存储库。）</p>
<p>cm ^tube ^share &lt;存储库规格&gt;[ …]-^u=&lt;远程用户&gt; -^a=(^pull | ^push | ^pull,^push)
（与远程用户共享本地存储库并设置指定的
访问模式。使用空格对各个存储库规格进行分隔。）</p>
<p>cm ^tube ^unshare &lt;存储库规格&gt;[ …]-^u=&lt;远程用户&gt;
（取消与远程用户共享本地存储库。使用空格
对各个存储库规格进行分隔。）</p>
<p>cm ^tube ^connect
（将 Plastic SCM 服务器连接到 Plastic Tube。）
cm ^tube ^disconnect
（断开 Plastic SCM 服务器与 Plastic Tube 的连接。）
cm ^tube ^status
（显示 Plastic SCM 服务器是否已连接到 Plastic Tube。）</p>
</div></blockquote>
<p>选项</p>
<blockquote>
<div><p>-^u                Tube 用户（plasticscm.com 用户）。
-^p                用户密码。
-^a                设置访问模式。
存储库规格          存储库的规格。（使用 ‘cm ^help ^objectspec’ 可</p>
<blockquote>
<div><p>进一步了解存储库规格。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_TUBE ==
备注：</p>
<blockquote>
<div><p>使用 ‘cm ^tube’ 命令来管理 Plastic Tube。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^tube ^config <a class="reference external" href="mailto:-^u=ruben&#37;&#52;&#48;codicesoftware&#46;com">-^u=ruben<span>&#64;</span>codicesoftware<span>&#46;</span>com</a> -^p=rubenpassword</p>
<p>cm ^tube ^create <a class="reference external" href="mailto:pablo&#37;&#52;&#48;codicesoftware&#46;com">pablo<span>&#64;</span>codicesoftware<span>&#46;</span>com</a>
（<a class="reference external" href="mailto:'pablo&#37;&#52;&#48;codicesoftware&#46;com">’pablo<span>&#64;</span>codicesoftware<span>&#46;</span>com</a>’ 可以连接到当前的 Plastic Tube 用户）
cm ^tube ^remove <a class="reference external" href="mailto:pablo&#37;&#52;&#48;codicesoftware&#46;com">pablo<span>&#64;</span>codicesoftware<span>&#46;</span>com</a></p>
<p>cm ^tube ^local
cm ^tube ^remote</p>
<p>cm ^tube ^share <a class="reference external" href="mailto:repo&#37;&#52;&#48;server">repo<span>&#64;</span>server</a>:8087 <a class="reference external" href="mailto:-^u=pablo&#37;&#52;&#48;codicesoftware&#46;com">-^u=pablo<span>&#64;</span>codicesoftware<span>&#46;</span>com</a> -^a=^pull,^push
cm ^tube ^share <a class="reference external" href="mailto:repo&#37;&#52;&#48;server">repo<span>&#64;</span>server</a>:8087 <a class="reference external" href="mailto:doc&#37;&#52;&#48;server">doc<span>&#64;</span>server</a>:8087 <a class="reference external" href="mailto:-^u=pablo&#37;&#52;&#48;codicesoftware&#46;com">-^u=pablo<span>&#64;</span>codicesoftware<span>&#46;</span>com</a> -^a=^push
cm ^tube ^unshare <a class="reference external" href="mailto:repo&#37;&#52;&#48;server">repo<span>&#64;</span>server</a>:8087 <a class="reference external" href="mailto:-^u=pablo&#37;&#52;&#48;codicesoftware&#46;com">-^u=pablo<span>&#64;</span>codicesoftware<span>&#46;</span>com</a></p>
<p>cm ^tube ^connect
cm ^tube ^disconnect
cm ^tube ^status</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_UNCO ==
撤销项的签出。</p>
<p>== CMD_USAGE_UNCO ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^undocheckout | ^unco &lt;项路径&gt;[ …][-^a | –^all] [–^symlink] [–^silent]</dt><dd><dl class="simple">
<dt>[–^machinereadable [–^startlineseparator=&lt;分隔符&gt;]</dt><dd><p>[–^endlineseparator=&lt;分隔符&gt;] [–^fieldseparator=&lt;分隔符&gt;]]</p>
</dd>
</dl>
</dd>
<dt>项路径           要应用操作的项。使用空格对各个路径进行</dt><dd><p>分隔。使用双引号 (” “) 指定包含空格
的路径。
使用 . 将操作应用到当前目录。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>-^a | –^all           撤销指定项中的所有更改。如果</dt><dd><p>已签出项，则签出将被
还原。如果项是在本地修改的，则
修改将被还原。</p>
</dd>
<dt>–^symlink            将 undocheckout 操作应用于链接而不是</dt><dd><p>目标。</p>
</dd>
</dl>
<p>–^silent             不显示任何输出。
–^machinereadable    以易于解析的格式输出结果。
–^startlineseparator 与 ‘–^machinereadable’ 标志结合使用，</p>
<blockquote>
<div><p>指定行应如何开头。</p>
</div></blockquote>
<dl class="simple">
<dt>–^endlineseparator   与 ‘–^machinereadable’ 标志结合使用，</dt><dd><p>指定行应如何结尾。</p>
</dd>
<dt>–^fieldseparator     与 ‘–^machinereadable’ 标志结合使用，</dt><dd><p>指定应如何分隔字段。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_UNCO ==
备注：</p>
<blockquote>
<div><p>如果已签出某个项并且不想将这个项签入，则可以
使用此命令撤销签出。文件和文件夹都可以取消
签出。项将更新为签出之前的状态。</p>
<dl class="simple">
<dt>要求：</dt><dd><ul class="simple">
<li><p>项必须受源代码管理。</p></li>
<li><p>必须签出项。</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^undocheckout’ 命令可从 stdin 读取路径。为此，请传递
一个破折号 “-”。
示例：cm ^undocheckout ^checkin -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要撤销签出的文件。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id31"><span class="problematic" id="id32">*</span></a>.c | cm ^undocheckout –^all -
（在 Windows 中，撤销对工作区中所有 .c 文件的签出。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^undocheckout .
（撤销当前目录中的签出。）</p>
<p>cm ^undocheckout file1.txt file2.txt
cm unco c:workspacefile.txt
（撤销签出所选文件。）</p>
<p>cm ^unco -^a file1.txt
（撤销对 ‘file1.txt’ 的签出或本地修改）</p>
<p>cm ^unco 链接 –^symlink
（将 undocheckout 操作应用于链接文件而不是目标，
适用于 UNIX 环境。）</p>
<p>cm ^status –^short –^changelist=pending_to_review | cm ^undocheckout -
（撤销客户端更改列表。
以上命令将列出名为 ‘pending_to_review’
的更改列表中的路径，并且路径列表将重定向到
undocheckout 命令的输入。）</p>
<p>cm ^unco .–^machinereadable
（撤销当前目录中的签出，并以易于解析的
简化格式打印结果。）</p>
<dl class="simple">
<dt>cm ^unco .–^machinereadable –^startlineseparator=”&gt;” –^endlineseparator=”&lt;” </dt><dd><p>–^fieldseparator=”,”</p>
</dd>
</dl>
<p>（撤销当前目录中的签出，并以易于解析的简化
格式打印结果，以指定的字符串作为行的开头和结尾以及
对各字段进行分隔。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_UNCOUNCHANGED ==
撤销未更改的已签出项。</p>
<p>== CMD_USAGE_UNCOUNCHANGED ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^uncounchanged | ^unuc &lt;项路径&gt;[ …][-^R | -^r | –^recursive]</dt><dd><p>[–^symlink] [–^silent]</p>
</dd>
<dt>项路径           要应用操作的项。使用空格对各个路径进行</dt><dd><p>分隔。使用双引号 (” “) 指定包含空格
的路径。
使用 . 将操作应用到当前目录。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>-^R                  在指定路径中以递归方式撤销未更改的项。
–^symlink           将 uncounchanged 操作应用于链接而不是</p>
<blockquote>
<div><p>目标。</p>
</div></blockquote>
<p>–^silent            不显示任何输出。</p>
</div></blockquote>
<p>== CMD_HELP_UNCOUNCHANGED ==
备注：</p>
<blockquote>
<div><p>此命令是从工作区根目录以递归方式应用的。</p>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^uncounchanged’ 命令可从 stdin 读取路径。为此，请传递
一个破折号 “-”。
示例：cm ^uncounchanged -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要撤销签出的
未更改文件。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id33"><span class="problematic" id="id34">*</span></a>.c | cm ^uncounchanged -
（在 Windows 中，撤销对工作区中所有未更改的 .c 文件
的签出。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^uncounchanged .-^R
（在当前目录中以递归方式撤销未更改文件的签出。）</p>
<p>cm ^unuc /home/myuser/mywk/project/templates -^R
（在所选目录中以递归方式撤销未更改文件的签出。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_UNDELETE ==
使用特定修订来取消删除某个项。</p>
<p>== CMD_USAGE_UNDELETE ==
用法：</p>
<blockquote>
<div><p>cm ^undelete &lt;修订规格&gt; &lt;路径&gt;</p>
<dl class="simple">
<dt>修订规格             所含内容将加载到工作区中的</dt><dd><p>修订的规格。（使用 ‘cm ^help ^objectspec’ 可
进一步了解修订规格。）</p>
</dd>
</dl>
<p>路径                还原路径。</p>
</div></blockquote>
<p>== CMD_HELP_UNDELETE ==
备注：</p>
<blockquote>
<div><p>要取消删除的项不应加载到工作区中。</p>
<p>Xlink 不支持 ‘^undelete’ 操作。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^undelete ^revid:756 C:mywkssrcfoo.c
cm ^undelete ^itemid:68#^cs:2 C:mywksdirmyfile.pdf
cm ^undelete ^serverpath:/src#^br:/main C:mywksDir</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_UNDOCHANGE ==
撤销路径中的更改。</p>
<p>== CMD_USAGE_UNDOCHANGE ==
用法：</p>
<blockquote>
<div><p>cm ^undochange | ^unc &lt;项路径&gt;[ …][-^R | -^r | –^recursive]</p>
<dl class="simple">
<dt>项路径       要应用操作的项。使用空格对各个路径进行</dt><dd><p>分隔。使用双引号 (” “) 指定包含空格
的路径。
使用 . 将操作应用到当前目录。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><p>-^R              以递归方式应用操作。</p>
</div></blockquote>
<p>== CMD_HELP_UNDOCHANGE ==
备注：</p>
<blockquote>
<div><p>如果已签出某个项或已修改但未签入这个项，并且不想
签入这个项，则可以使用此命令撤销更改。项将
更新为之前的内容。</p>
</div></blockquote>
<p>从 stdin 读取输入：</p>
<blockquote>
<div><p>‘^undochange’ 命令可从 stdin 读取路径。为此，请传递
一个破折号 “-”。
示例：cm ^undochange -</p>
<p>路径将一直读取到有空行输入为止。
这种情况下允许使用竖线指定要撤销更改的文件。
示例：</p>
<blockquote>
<div><p>dir /S /B <a href="#id35"><span class="problematic" id="id36">*</span></a>.c | cm ^undochange -
（在 Windows 中，撤销对工作区中所有 .c 文件的更改。）</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^unc .
（撤销当前目录中的文件更改。）</p>
<p>cm ^undochange .-^R
（以递归方式撤销当前目录中的文件更改。）</p>
<p>cm ^unc file1.txt “file 2.txt”
（撤销所选文件的更改。）</p>
<p>cm ^unc c:workspacefile.txt
（撤销所选文件的更改。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_UNDO ==
撤销工作区中的更改。</p>
<p>== CMD_USAGE_UNDO ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^undo [&lt;路径&gt;[ …]] [–^symlink] [-^r | –^recursive] [&lt;筛选器&gt;[ …]]</dt><dd><dl class="simple">
<dt>[–^silent | –^machinereadable [–^startlineseparator=&lt;分隔符&gt;]</dt><dd><p>[–^endlineseparator=&lt;分隔符&gt;] [–^fieldseparator=&lt;分隔符&gt;]]</p>
</dd>
</dl>
</dd>
<dt>路径                要应用操作的文件或目录</dt><dd><p>的路径。使用双引号 (” “) 指定包含空格的
路径。使用空格对各个路径进行分隔。
如果未指定路径，则默认情况下，
撤销操作将应用于当前目录中的所有
文件。</p>
</dd>
<dt>筛选器              将一个或多个指定筛选器应用于给定</dt><dd><p>路径。使用空格对各个筛选器进行分隔。请参阅
“筛选器”部分以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^symlink               将撤销操作应用于符号链接而不是</dt><dd><p>目标。</p>
</dd>
</dl>
<p>-^r                      以递归方式执行撤销。
–^silent                不显示任何输出。
–^machinereadable       以易于解析的格式输出结果。
–^startlineseparator    与 ‘–^machinereadable’ 标志结合使用，指定</p>
<blockquote>
<div><p>行应如何开头。</p>
</div></blockquote>
<dl class="simple">
<dt>–^endlineseparator      与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>行应如何结尾。</p>
</dd>
<dt>–^fieldseparator        与 ‘–^machinereadable’ 标志结合使用，指定</dt><dd><p>应如何分隔字段。</p>
</dd>
</dl>
</div></blockquote>
<p>筛选器：</p>
<blockquote>
<div><p>如果未指定标志，则默认情况下将撤销所有更改，但是
可以使用以下一个或多个标志来筛选路径。
如果文件或目录匹配一个或多个指定种类的更改，
则将撤销该文件或目录上的所有更改。
例如，如果同时指定了 ‘–^checkedout’ 和 ‘–^moved’，则在
已签出并移动文件的情况下，两项更改都将被撤销。</p>
<p>–^checkedout            选择已签出的文件和目录。
–^unchanged             选择内容不变的文件。
–^changed               选择本地更改的或签出的文件和</p>
<blockquote>
<div><p>目录。</p>
</div></blockquote>
<p>–^deleted               选择已删除的文件和目录。
–^moved                 选择已移动的文件和目录。
–^added                 选择已添加的文件和目录。</p>
</div></blockquote>
<p>== CMD_HELP_UNDO ==
备注：</p>
<blockquote>
<div><p>‘^undo’ 命令有风险，因为该命令在撤销工作后将不可逆。
^undo 完成后，无法将受其影响的文件和目录
恢复到先前状态。如果参数中
未指定路径，则默认情况下，该命令将撤销
当前目录中的所有更改，但不采用递归方式。
从 /src 目录执行时，以下命令是等效的：</p>
<blockquote>
<div><p>/src
<a href="#id37"><span class="problematic" id="id38">|</span></a>- file.txt
<a href="#id39"><span class="problematic" id="id40">|</span></a>- code.cs
- /test</p>
<blockquote>
<div><p><a href="#id41"><span class="problematic" id="id42">|</span></a>- test_a.py
- test_b.py</p>
</div></blockquote>
<p>cm ^undo
cm ^undo *
cm ^undo file.txt code.cs /test</p>
<p>cm ^undo .
cm ^undo /src file.txt code.cs</p>
</div></blockquote>
<p>如果希望操作以递归方式执行，必须指定 ‘-^r’ 标志。</p>
<p>撤销某一目录下的所有更改（包括影响目录
本身的更改）：</p>
<blockquote>
<div><p>cm ^undo 目录路径 -^r</p>
</div></blockquote>
<p>如果目录路径是工作区路径，则工作区中的每个更改都将
被撤销。</p>
</div></blockquote>
<p>已删除项：</p>
<blockquote>
<div><p>要撤销对文件和目录的删除，必须指定项的
完整路径，或者指定所属目录并使用递归 (‘-^r’)
标志。</p>
<p>例如：</p>
<p>cm ^undo .
（不撤销当前目录中的删除。）</p>
<p>cm ^undo .-^r
（以递归方式撤销当前目录中的所有删除（和其他更改）。）</p>
<p>cm ^undo src/file.txt
（撤销对 src/file.txt 的删除（或其他更改）。）</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^undo .-^r
（以递归方式撤销当前目录中的所有更改。如果从工作区的
根目录执行，则撤销整个工作区中的所有更改。）</p>
<p>cm ^co file.txt
cm ^undo file.txt
（撤销对 ‘file.txt’ 的签出。）</p>
<p>^echo ^content &gt;&gt; file.txt
cm ^undo file.txt
（撤销对 ‘file.txt’ 的本地更改。）</p>
<p>cm ^undo src
（撤销对 src 目录及其文件的更改。）</p>
<p>cm ^undo src/*
（撤销对 src 中包含的每个文件和目录的更改，而不会
影响 src。）</p>
<p>cm ^undo <a href="#id43"><span class="problematic" id="id44">*</span></a>.cs
（撤销对当前目录中与 <a href="#id45"><span class="problematic" id="id46">*</span></a>.cs 匹配的每个文件或目录的
更改。）</p>
<p>cm ^undo <a href="#id47"><span class="problematic" id="id48">*</span></a>.cs -^r
（撤销对当前目录中以及下级所有目录中与 <a href="#id49"><span class="problematic" id="id50">*</span></a>.cs 匹配的
每个文件或目录的更改。）</p>
<p>cm ^co file1.txt file2.txt
^echo ^content &gt;&gt; file1.txt
cm ^undo –^unchanged
（撤销对未更改的 ‘file2.txt’ 的签出，并忽略本地更改的
‘file1.txt’。）</p>
<p>^echo ^content &gt;&gt; file1.txt
^echo ^content &gt;&gt; file2.txt
cm ^co file1.txt
cm ^undo –^checkedout
（撤销已签出文件 ‘file1.txt’ 中的更改，并忽略 ‘file2.txt’，
因为后者未签出。）</p>
<p>cm ^add file.txt
cm ^undo file.txt
（撤销添加 ‘file.txt’，使该文件再次成为私有文件。）</p>
<p>^rm file1.txt
^echo ^content &gt;&gt; file2.txt
cm ^add file3.txt
cm ^undo –^deleted –^added *
（撤销 ‘file1.txt’ 的删除和 ‘file3.txt’ 的添加，并忽略 ‘file2.txt’
的更改。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_LOCK_UNLOCK ==
撤销锁定服务器上的项锁定。</p>
<p>== CMD_USAGE_LOCK_UNLOCK ==
用法：</p>
<blockquote>
<div><p>cm ^lock ^unlock [&lt;存储库服务器规格&gt;] &lt;GUID&gt;[ …]</p>
<dl class="simple">
<dt>存储库服务器规格   存储库服务器规格。（使用 ‘cm ^help ^objectspec’</dt><dd><p>可进一步了解存储库服务器规格。）</p>
</dd>
<dt>GUID            要解锁的项 GUID 的列表。使用空格对各个 GUID</dt><dd><p>进行分隔。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_LOCK_UNLOCK ==
备注：</p>
<blockquote>
<div><ul>
<li><p>该命令使用指定的服务器来解锁项。</p></li>
<li><p>如果未指定服务器，则该命令会尝试从当前工作区
获取服务器。</p></li>
<li><p>如果在先前的步骤中未计算服务器，则会从当前的
Plastic SCM 客户端配置中获取服务器。</p></li>
<li><p>只有服务器的管理员才能运行 ‘cm ^unlock’ 命令。</p></li>
<li><p>要指定 GUID，格式应为 32 位数字，并用
短横线分隔（也可以选择用花括号括起来）：</p>
<blockquote>
<div><p>{00000000-0000-0000-0000-000000000000}</p>
</div></blockquote>
<p>或 00000000-0000-0000-0000-000000000000</p>
</li>
</ul>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^lock ^unlock 91961b14-3dfe-4062-8c4c-f33a81d201f5
（撤销所选项锁定。）</p>
<dl class="simple">
<dt>cm ^lock ^unlock DIGITALIS:8084 2340b4fa-47aa-4d0e-bb00-0311af847865 </dt><dd><p>bcb98a61-2f62-4309-9a26-e21a2685e075</p>
</dd>
</dl>
<p>（撤销名为 ‘DIGITALIS’ 的锁定服务器上的所选项锁定。）</p>
<dl class="simple">
<dt>cm ^lock ^unlock <a class="reference external" href="mailto:tardis&#37;&#52;&#48;cloud">tardis<span>&#64;</span>cloud</a> 4740c4fa-56af-3dfe-de10-8711fa248635 </dt><dd><p>71263c17-5eaf-5271-4d2c-a25f72e101d4</p>
</dd>
</dl>
<p>（撤销名为 ‘tardis’ 的 Cloud 锁定服务器上的所选项锁定。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_UPDATE ==
更新工作区并下载最新的更改。</p>
<p>== CMD_USAGE_UPDATE ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^update [&lt;项路径&gt; | –^last]</dt><dd><p>[–^changeset=&lt;变更集规格&gt;] [–^cloaked] [–^dontmerge] [–^forced]
[–^ignorechanges] [–^override] [–^recursewk] [–^skipchangedcheck]
[–^silent] [–^verbose] [–^xml[=&lt;输出文件&gt;]] [–^encoding=&lt;名称&gt;]
[–^machinereadable [–^startlineseparator=&lt;分隔符&gt;]</p>
<blockquote>
<div><p>[–^endlineseparator=&lt;分隔符&gt;] [–^fieldseparator=&lt;分隔符&gt;]]</p>
</div></blockquote>
<p>[–^forcedetailedprogress]</p>
</dd>
<dt>项路径           要更新的路径。</dt><dd><p>使用 . 将更新应用到当前目录。
如果未指定路径，则当前工作区
将完全更新。</p>
</dd>
<dt>–^last              在更新之前，将工作区选择器</dt><dd><p>从变更集配置或标签配置更改为
分支配置。
选择器将更改为变更集或标签
所属的分支。</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^changeset             将工作区更新为特定变更集。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解
变更集规格。）</p>
</dd>
<dt>–^cloaked               在更新操作中包含掩蔽的项。</dt><dd><p>如果未指定此选项，则在操作中
将忽略掩蔽的项。</p>
</dd>
<dt>–^dontmerge             如果在更新操作期间需要</dt><dd><p>合并更新，请不要执行合并。</p>
</dd>
<dt>–^forced                强制将项更新为选择器中指定的</dt><dd><p>修订。</p>
</dd>
<dt>–^ignorechanges         忽略在更新工作区时</dt><dd><p>检测到待定更改的情况下显示
的待定更改警告消息。</p>
</dd>
<dt>–^override              覆盖不受 Plastic SCM 控制的已更改文件。</dt><dd><p>这些文件的内容将被服务器内容
覆盖。</p>
</dd>
<dt>–^recursewk             更新在当前路径中找到的所有</dt><dd><p>工作区。适合用于更新特定路径中包含的
所有工作区。</p>
</dd>
<dt>–^skipchangedcheck      该更新在开始之前会检查工作区中是否</dt><dd><p>存在本地更改。如果始终在修改
文件之前签出，则可以进行此检查并
加快操作速度。</p>
</dd>
</dl>
<p>–^silent                不显示任何输出。
–^verbose               显示其他信息。
–^xml                   以 XML 格式将输出打印到标准输出。</p>
<blockquote>
<div><p>可以指定输出文件。</p>
</div></blockquote>
<dl class="simple">
<dt>–^encoding              与 –^xml 选项结合使用，指定要在 XML 输出</dt><dd><p>中使用的编码（例如：utf-8）。
请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</dd>
</dl>
<p>–^machinereadable       以易于解析的格式输出结果。
–^startlineseparator    与 ‘–^machinereadable’ 标志结合使用，</p>
<blockquote>
<div><p>指定行应如何开头。</p>
</div></blockquote>
<dl class="simple">
<dt>–^endlineseparator      与 ‘–^machinereadable’ 标志结合使用，</dt><dd><p>指定行应如何结尾。</p>
</dd>
<dt>–^fieldseparator        与 ‘–^machinereadable’ 标志结合使用，</dt><dd><p>指定应如何分隔字段。</p>
</dd>
<dt>–^forcedetailedprogress 即使在标准输出被重定向的情况下也要强制显示</dt><dd><p>详细进度。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_UPDATE ==
备注：</p>
<blockquote>
<div><p>‘^update’ 命令仅下载所需的文件。</p>
<p>该命令采用递归操作。</p>
<p>使用 –^last’ 选项时，无需指定路径。
在这种情况下，当前工作目录所属的工作区
将更新。
（切记，如果工作区选择器先前指向某个
变更集或标签，则指定该标志可能导致
工作区选择器更改为分支配置。）</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^update
（更新当前工作区中的所有项。）</p>
<p>cm ^update .
（更新当前目录以及所有子项。）</p>
<p>cm ^update .–^forced –^verbose
（强制检索所有修订。）</p>
<p>cm ^update –^last</p>
<p>cm ^update .–^machinereadable –^startlineseparator=”&gt;”
（更新当前目录，并以易于解析的简化格式
打印结果，以指定的字符串作为行的
开头。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_VERSION ==
显示当前的客户端版本号。</p>
<p>== CMD_USAGE_VERSION ==
用法：</p>
<blockquote>
<div><p>cm ^version</p>
</div></blockquote>
<p>== CMD_HELP_VERSION ==</p>
<p>== CMD_DESCRIPTION_WHOAMI ==
显示当前的 Plastic SCM 用户。</p>
<p>== CMD_USAGE_WHOAMI ==
用法：</p>
<blockquote>
<div><p>cm ^whoami</p>
</div></blockquote>
<p>== CMD_HELP_WHOAMI ==</p>
<p>== CMD_USAGE_WKTREENODESTATUS ==
用法：</p>
<blockquote>
<div><p>cm ^wktreenodestatus 路径1, 路径2, …</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_WORKSPACE ==
允许用户管理工作区。</p>
<p>== CMD_USAGE_WORKSPACE ==
用法：</p>
<blockquote>
<div><p>cm ^workspace | ^wk &lt;命令&gt; [选项]</p>
</div></blockquote>
<p>命令：</p>
<blockquote>
<div><p>^list   | ^ls
^create | ^mk
^delete | ^rm
^move   | ^mv
^rename</p>
<p>要获取有关每条命令的更多信息，请运行：
cm ^workspace &lt;命令&gt; –^usage
cm ^workspace &lt;命令&gt; –^help</p>
</div></blockquote>
<p>== CMD_HELP_WORKSPACE ==
示例：</p>
<blockquote>
<div><p>cm ^workspace ^create myWorkspace 工作区路径
cm ^workspace ^list
cm ^workspace ^delete myWorkspace</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_WORKSPACE_CREATE ==
创建新的工作区。</p>
<p>== CMD_USAGE_WORKSPACE_CREATE ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^workspace | ^wk [^create | ^mk] &lt;工作区名称&gt; &lt;工作区路径&gt; [&lt;存储库规格&gt;]</dt><dd><p>[–^selector[=&lt;选择器文件&gt;]</p>
</dd>
</dl>
<p>（创建新的工作区。）</p>
<p>cm ^workspace | ^wk [^create | ^mk] &lt;工作区名称&gt; &lt;工作区路径&gt; –^dynamic –^tree=[&lt;树&gt;]
（创建动态工作区。此功能仍处于实验阶段，
仅适用于 Windows。）</p>
<p>工作区名称             新工作区的名称。
工作区路径             新工作区的路径。
存储库规格            使用指定的存储库创建新的工作区。</p>
<blockquote>
<div><p>存储库规格：查看 ‘cm ^help ^objectspec’。</p>
</div></blockquote>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^selector          编辑新工作区的选择器。</dt><dd><p>如果指定了选择器文件，则会从指定文件
为新工作区设置选择器。</p>
</dd>
<dt>–^dynamic           创建动态工作区。此功能仍处于</dt><dd><p>实验阶段，仅适用于 Windows。
指定此标志需要使用 –^tree 参数。</p>
</dd>
<dt>–^tree              与 ‘–^dynamic’ 标志结合使用，指定要</dt><dd><p>加载动态工作区的初始点。此选项
可以是分支、变更集或标签规格。
工作区稍后将使用规格中的
存储库。（使用 ‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_WORKSPACE_CREATE ==
备注：</p>
<blockquote>
<div><ul class="simple">
<li><p>工作区是映射到本地文件系统的存储库的视图。
工作区选择器可以定义用于指定工作区内容的规则。
使用 ‘cm ^showselector’ 显示工作区选择器，或使用 ‘cm ^setselector’ 修改
工作区选择器。</p></li>
<li><p>如果存储库规格和 ‘–^selector’ 均未指定，则工作区
将自动配置为使用 client.conf 文件中配置的
服务器的第一个存储库（按字母顺序）。</p></li>
<li><p>动态工作区是一项实验性功能（仅适用于 Windows），
并需要运行 plasticfs.exe 程序。</p></li>
</ul>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^workspace ^create myworkspace c:workspace
cm ^wk ^mk myworkspace /home/john/plastic_view
（分别在 Windows 和 Linux 中创建 ‘myworkspace’ 工作区。）</p>
<p>cm ^wk mywktest c:wkswktest –^selector=myselector.txt
（使用 ‘myselector.txt’ 文件中的选择器创建 ‘mywktest’ 工作区。）</p>
<p>cm ^wk mywkprj c:wkswkprj myrep&#64;^repserver:localhost:8084
（使用所选存储库创建 ‘mywkprj’ 工作区。）</p>
<p>cm ^wk mywkprj c:dynwksmywkprj –^dynamic –^tree=^br:/main&#64;myrep&#64;localhost:8084
（使用 ‘myrep&#64;localhost:8084’ 存储库创建动态的 ‘mywkprj’</p>
<blockquote>
<div><p>工作区，并在首次装入该工作区时指向 ‘^br:/main’。）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_DESCRIPTION_WORKSPACE_DELETE ==
删除工作区。</p>
<p>== CMD_USAGE_WORKSPACE_DELETE ==
用法：</p>
<blockquote>
<div><p>cm ^workspace | ^wk ^delete | ^rm [&lt;工作区路径&gt; | &lt;工作区规格&gt;] [–^keepmetadata]</p>
<p>工作区路径             要删除的工作区的路径。
工作区规格              要删除的工作区的规格。（使用</p>
<blockquote>
<div><p>‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</div></blockquote>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^keepmetadata      不删除 .plastic 文件夹中的元数据</dt><dd><p>文件。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_WORKSPACE_DELETE ==
备注：</p>
<blockquote>
<div><p>此命令将删除由路径或规格指定的工作区。
如果未指定任何参数，则将采用当前工作区。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^workspace ^delete
（删除当前工作区。）</p>
<p>cm ^wk ^delete c:workspace
cm ^workspace rm /home/danipen/wks
cm ^wk ^rm ^wk:MiWorkspace
cm ^wk ^rm ^wk:MiWorkspace&#64;DIGITALIS</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_WORKSPACE_LIST ==
列出工作区。</p>
<p>== CMD_USAGE_WORKSPACE_LIST ==
用法：</p>
<blockquote>
<div><p>cm ^workspace | ^wk [^list | ^ls] [–^format=&lt;格式字符串&gt;]</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>–^format            检索特定格式的输出消息。请参阅</dt><dd><p>“备注”以了解更多信息。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_WORKSPACE_LIST ==
备注：</p>
<blockquote>
<div><p>此命令接受格式字符串以显示输出。
此命令的输出参数如下：</p>
<blockquote>
<div><p>{0} | {^wkname}          工作区名称。
{1} | {^machine}         客户端机器名称。
{2} | {^path}            工作区路径。
{3} | {^wkid}            工作区唯一标识符。
{4} | {^wkspec}          使用以下格式的工作区规格：</p>
<blockquote>
<div><p><a class="reference external" href="mailto:'wkname&#37;&#52;&#48;machine">‘wkname<span>&#64;</span>machine</a>’。</p>
</div></blockquote>
<p>{^tab}                   插入一个制表符空格位。
{^newline}               插入一个新行。</p>
</div></blockquote>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^wk
（列出所有工作区。）</p>
<p>cm ^workspace ^list –^format={0}#{3,40}
cm ^workspace ^list –^format={^wkname}#{^wkid,40}
（列出所有工作区，并在 40 个空格位中显示工作区名称、# 符号
和工作区 GUID 字段（左对齐）。）</p>
<p>cm ^wk –^format=”路径 {2} 中的工作区 {0}”
cm ^wk –^format=”路径 {^path} 中的工作区 {^wkname}”
（列出所有工作区并将结果显示为格式化的字符串。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_WORKSPACE_MOVE ==
移动工作区。</p>
<p>== CMD_USAGE_WORKSPACE_MOVE ==
用法：</p>
<blockquote>
<div><p>cm ^workspace | ^wk ^move | ^mv [&lt;工作区规格&gt;] &lt;新路径&gt;</p>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>工作区规格              要移动的工作区的规格。（使用</dt><dd><p>‘cm ^help ^objectspec’ 可进一步了解规格。）</p>
</dd>
</dl>
<p>新路径            工作区将移动到此处。</p>
</div></blockquote>
<p>== CMD_HELP_WORKSPACE_MOVE ==
备注：</p>
<p>此命令允许用户将工作区移动到磁盘上的另一个位置。</p>
<p>示例：</p>
<blockquote>
<div><p>cm ^workspace ^move myWorkspace newworkspaceDirectory
（将 ‘myWorkspace’ 移动到指定位置。）</p>
<p>cm ^wk ^mv c:usersmariawkspacesnewlocation
（将当前工作区移动到新位置。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_WORKSPACE_RENAME ==
重命名工作区。</p>
<p>== CMD_USAGE_WORKSPACE_RENAME ==
用法：</p>
<blockquote>
<div><p>cm ^workspace | ^wk ^rename [&lt;工作区名称&gt;] &lt;新名称&gt;</p>
<p>工作区名称             要重命名的工作区。
新名称            工作区的新名称。</p>
</div></blockquote>
<p>== CMD_HELP_WORKSPACE_RENAME ==
备注：</p>
<blockquote>
<div><p>此命令将重命名工作区。
如果未提供工作区名称，则将使用当前工作区。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^workspace ^rename mywk1 wk2
（将工作区 ‘mywk1’ 重命名为 ‘wk2’。）</p>
<p>cm ^wk ^rename newname
（将当前工作区重命名为 ‘newname’。）</p>
</div></blockquote>
<p>== CMD_DESCRIPTION_WORKSPACESTATUS ==
显示工作区中的更改。</p>
<p>== CMD_USAGE_WORKSPACESTATUS ==
用法：</p>
<blockquote>
<div><dl>
<dt>cm ^status [&lt;工作区路径&gt;] [–^changelist[=&lt;名称&gt;] | –^changelists] [–^cutignored]</dt><dd><p>[ –^header] [ –^noheader] [ –^nomergesinfo] [ –^head]
[–^short] [–^symlink] [ –^dirwithchanges] [–^xml[=&lt;输出文件&gt;]]
[–^encoding=&lt;名称&gt;] [ –^wrp |  –^wkrootrelativepaths]
[–^fullpaths | –^fp] [&lt;旧选项&gt;] [&lt;搜索类型&gt;[ …]]
[–^machinereadable [–^startlineseparator=分隔符]</p>
<blockquote>
<div><p>[–^endlineseparator=分隔符] [–^fieldseparator=分隔符]]</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>工作区路径               要作为搜索范围的工作区的</dt><dd><p>路径。</p>
</dd>
</dl>
<p>–^changelist          显示所选更改列表中的更改。
–^changelists         显示按客户端更改列表进行分组的更改。
–^cutignored          跳过已忽略目录的内容。</p>
<blockquote>
<div><p>需要 ‘–^ignored’ 搜索类型。请参阅
“搜索类型”部分以了解更多信息。</p>
</div></blockquote>
<p>–^header              仅打印工作区状态。
–^noheader            仅打印修改后的项搜索结果。
–^nomergesinfo        不打印更改的合并信息。
–^head                打印分支上最后一个变更集的状态。
–^short               仅列出包含更改的路径。
–^symlink             将操作应用于符号链接而不是</p>
<blockquote>
<div><blockquote>
<div><p>目标。</p>
</div></blockquote>
<dl class="simple">
<dt>–^dirwithchanges     显示含有更改的目录</dt><dd><p>（含有已添加、移动、删除的项）。</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>–^xml                 以 XML 格式将输出打印到标准输出。</dt><dd><p>可以指定输出文件。</p>
</dd>
</dl>
<p>–^pretty              Prints workspace changes in a nice table format.
–^encoding            与 –^xml 选项结合使用，指定要在 XML 输出</p>
<blockquote>
<div><blockquote>
<div><p>中使用的编码（例如：utf-8）。
请参阅位于以下网址的 MSDN 文档：
<a class="reference external" href="http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx">http://msdn.microsoft.com/en-us/library/system.text.encoding.aspx</a>
以查看包含受支持编码及其格式的表格
（位于页面末尾的“名称”列中）。</p>
</div></blockquote>
<dl class="simple">
<dt>–^wrp                打印工作区根目录的相对路径，而不是</dt><dd><p>当前目录的相对路径。</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>–^fullpaths, –^fp     强制打印绝对路径，覆盖所有其他</dt><dd><p>路径打印设置。</p>
</dd>
</dl>
<p>–^machinereadable     以易于解析的格式输出结果。
–^startlineseparator  与 ‘–^machinereadable’ 标志结合使用，</p>
<blockquote>
<div><p>指定行应如何开头。</p>
</div></blockquote>
<dl class="simple">
<dt>–^endlineseparator    与 ‘–^machinereadable’ 标志结合使用，</dt><dd><p>指定行应如何结尾。</p>
</dd>
<dt>–^fieldseparator      与 ‘–^machinereadable’ 标志结合使用，</dt><dd><p>指定应如何分隔字段。</p>
</dd>
</dl>
</div></blockquote>
<p>旧选项：</p>
<blockquote>
<div><p>–^cset              以旧格式打印工作区状态。
–^compact           以旧格式打印工作区状态和</p>
<blockquote>
<div><p>更改列表。</p>
</div></blockquote>
<dl class="simple">
<dt>–^noheaders         与 ‘–^compact’ 标志结合使用时，不会</dt><dd><p>打印更改列表标题。（不适用于
新更改列表格式。）</p>
</dd>
</dl>
</div></blockquote>
<p>搜索类型：</p>
<blockquote>
<div><p>–^added                         打印已添加的项。
–^checkout                      打印已签出的项。
–^changed                       打印已更改的项。
–^copied                        打印已复制的项。
–^replaced                      打印已替换的项。
–^deleted                       打印已删除的项。
–^localdeleted                  打印已在本地删除的项。
–^moved                         打印已移动的项。
–^localmoved                    打印已在本地移动的项。
–^percentofsimilarity=&lt;值&gt;   为了将两个文件视为同一个项而需要</p>
<blockquote>
<div><p>两者之间达到的相似程度百分比。用于
搜索已在本地移动的项。默认值
为 20%。</p>
</div></blockquote>
<dl class="simple">
<dt>–^txtsameext                    在搜索已移动的项期间，</dt><dd><p>相似性内容匹配过程将
仅考虑具有相同扩展名的
文本文件。默认情况下，
将处理任何文本文件。</p>
</dd>
<dt>–^binanyext                     在搜索已移动的项期间，</dt><dd><p>相似性内容匹配过程将
考虑任何二进制文件。默认情况下，
只会处理具有相同扩展名的
二进制文件。</p>
</dd>
</dl>
<p>–^private                       打印非受控项。
–^ignored                       打印已忽略的项。
–^hiddenchanged                 打印隐藏的已更改项。（包括</p>
<blockquote>
<div><p>‘–^changed’）</p>
</div></blockquote>
<p>–^cloaked                       打印掩蔽的项。
–^controlledchanged             此标志替代以下选项：</p>
<blockquote>
<div><dl class="simple">
<dt>‘–^added’、’–^checkout’、’–^copied’、</dt><dd><p>‘–^replaced’、’–^deleted’、’–^moved’。</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>–^all                           此标志替换以下参数：</dt><dd><p>‘–^controlledchanged’、’–^changed’、
‘–^localdeleted’、’–^localmoved’、’–^private’。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_WORKSPACESTATUS ==
备注：</p>
<blockquote>
<div><p>‘^status’ 命令将打印工作区中已加载的变更集，并在工作区
内获取已更改的元素。</p>
<p>此命令可用于显示工作区中的待定更改；
可以使用命令参数来修改可以搜索的
更改类型。默认情况下将显示所有更改，无论是
受控更改还是本地更改。</p>
<p>搜索已在本地移动的项时会使用相似性参数百分比
‘–^percentofsimilarity’ (-^p) 来确定两个元素是否为同一个项。
默认值为 20%，但可以调整。</p>
<p>可以显示按客户端更改列表分组的工作区更改。
‘^default’ 更改列表包括其他更改列表中
未包含的更改。因此，默认更改列表将显示的更改
取决于指定的搜索类型标志。</p>
<p>要显示按更改列表分组的更改，还需要显示受控
的更改（状态为 ‘^added’、’^checkout’、’^copied’、
、’^replaced’、’^deleted’ 或 ‘^moved’ 的项）。因此，当显示更改列表时，
‘–^controlledchanged’ 选项将自动启用。</p>
<p>XML 输出的默认编码为 utf-8。</p>
<p>默认情况下，此命令将打印当前目录的相对路径，
除非指定了 ‘–^machinereadable’ 或 ‘–^short’ 标志。如果
指定了其中任何一个标志，该命令将打印绝对路径。</p>
<p>如果指定了 ‘–^xml’ 标志，则将打印工作区根目录的
相对路径（除非也指定了 ‘–^fp’ 标志，那么将
打印绝对路径）。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^status
（打印工作变更集以及工作区中所有已更改的
项类型，但已忽略的项除外。）</p>
<p>cm ^status –^controlledchanged
（打印工作变更集以及已签出、添加、复制、替换、
删除和移动的项。）</p>
<p>cm ^status –^added
（仅打印工作变更集和工作区中添加的项。）</p>
<p>cm ^status c:workspaceLocationcodeclient –^added
（以递归方式打印指定路径下的工作变更集和
添加的项。）</p>
<p>cm ^status –^changelists
cm ^status –^changelist
（显示按客户端更改列表分组的所有工作区更改。）</p>
<p>cm ^status –^changelist=pending_to_review
（显示名为 ‘pending_to_review’ 的更改列表中的更改。）</p>
<p>cm ^status –^changelist=default –^private
（显示 ‘default’ 更改列表中的更改，包括私有项以及
具有受控更改的项（如果有）。）</p>
<p>cm ^status –^short –^changelist=pending_to_review | cm ^checkin -
（签入更改列表 ‘pending_to_review’ 中的更改。）</p>
<p>cm ^status C:workspaceLocation –^xml=output.xml
（获取 XML 格式的状态信息，并在文件 output.xml 中
使用 utf-8。）</p>
<p>cm ^status –^ignored
（显示所有已忽略的项。）
输出：
/main&#64;myrepo&#64;local (^cs:2 - ^head)
^Added</p>
<blockquote>
<div><p>状态     大小       上次修改时间     路径</p>
<p>^Ignored    0 字节    19 秒前    outapp.exe
^Ignored               48 秒前    src
^Ignored    0 字节    48 秒前    srcversion.c</p>
</div></blockquote>
<p>cm ^status –^ignored –^cutignored
（显示父目录未被忽略的已忽略文件，并显示
内容未被忽略的已忽略目录。）
输出：
/main&#64;myrepo&#64;local (^cs:2 - ^head)
^Added</p>
<blockquote>
<div><p>状态     大小       上次修改时间     路径</p>
<p>^Ignored    0 字节    19 秒前    outapp.exe
^Ignored               48 秒前    src</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_DESCRIPTION_XLINK ==
创建、编辑或显示 Xlink 的详细信息。</p>
<p>== CMD_USAGE_XLINK ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^xlink [-^w] [-^rs] &lt;Xlink_路径&gt; / (&lt;变更集规格&gt; | &lt;标签规格&gt; | &lt;分支规格)&gt;</dt><dd><p>[&lt;扩展规则&gt;[ …]]</p>
</dd>
</dl>
<p>（创建一个 Xlink。）</p>
<dl class="simple">
<dt>cm ^xlink [-^rs] &lt;Xlink_路径&gt; /&lt;相对路径&gt; (&lt;变更集规格&gt; | &lt;标签规格&gt; | &lt;分支规格&gt;)</dt><dd><p>[&lt;扩展规则&gt;[ …]]</p>
</dd>
</dl>
<p>（创建指向 /&lt;相对路径&gt;（而不是指向默认根目录 /）的只读
部分 Xlink。）</p>
<p>cm ^xlink -^e &lt;Xlink_路径&gt; (&lt;变更集规格&gt; | &lt;标签规格&gt; | &lt;分支规格&gt;)
（编辑 Xlink 以更改目标规格。）</p>
<p>cm ^xlink -^s|–^show &lt;Xlink_路径&gt;
（显示 Xlink 信息，包括扩展规则。）</p>
<p>cm ^xlink -^ar|–^addrules &lt;Xlink_路径&gt; &lt;扩展规则&gt;[ …]
（将给定的扩展规则添加到 Xlink。）</p>
<p>cm ^xlink -^dr|–^deleterules &lt;Xlink_路径&gt; &lt;扩展规则&gt;[ …]
（从 Xlink 中删除给定的扩展规则。）</p>
<dl class="simple">
<dt>Xlink_路径          这是当前工作区中将装入（创建 Xlink 时）</dt><dd><p>或已经装入（编辑 Xlink 时）
已链接的存储库的目录。</p>
</dd>
<dt>变更集规格            远程存储库中的完整目标变更集</dt><dd><p>规格。
此规格确定了已链接的存储库的工作区中
加载了哪个版本和分支。
（使用 ‘cm ^help ^objectspec’ 可进一步了解变更集
规格。）</p>
</dd>
<dt>标签规格              远程存储库中的完整标签规格。</dt><dd><p>（使用 ‘cm ^help ^objectspec’ 可进一步了解标签
规格。）</p>
</dd>
<dt>分支规格              远程存储库中的完整分支规格。</dt><dd><p>此规格使用指定的分支所指向的
当前变更集。（使用 ‘cm ^help ^objectspec’ 可
可进一步了解分支规格。）</p>
</dd>
<dt>-^e                  编辑现有的 Xlink 以更改目标变更集</dt><dd><p>规格。</p>
</dd>
</dl>
<p>-^s | –^show         显示有关所选 Xlink 的信息。
-^ar | –^addrules    将一个或多个扩展规则添加到所选 Xlink。
-^dr | –^deleterules 从所选 Xlink 中删除一个或多个扩展</p>
<blockquote>
<div><p>规则。</p>
</div></blockquote>
<dl class="simple">
<dt>扩展规则     指定一个或多个扩展规则。每个扩展</dt><dd><p>规则都是一对分支/目标分支：
^br:/main/fix-^br:/main/develop/fix</p>
</dd>
</dl>
</div></blockquote>
<p>选项：</p>
<blockquote>
<div><dl class="simple">
<dt>-^w                  表示 Xlink 是可写的。这意味着</dt><dd><p>可以通过分支自动扩展功能来修改
目标存储库的内容。</p>
</dd>
<dt>-^rs                 相对服务器。此选项允许创建独立于</dt><dd><p>存储库服务器的相对 Xlink。这样，
在不同服务器的复制存储库中
创建的 Xlink 将被自动识别。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_HELP_XLINK ==
备注：</p>
<blockquote>
<div><p>此命令将创建指向给定变更集的 Xlink。默认情况下将创建一个
只读 Xlink。这意味着无法修改 Xlink 内部工作区中
加载的内容。为了能够更改通过 Xlink 链接的内容，
请创建可写的 Xlink（使用 ‘-^w’ 选项）。</p>
<p>在编辑 Xlink 的目标变更集时，可以使用
该命令的简化语法。这样，唯一需要的参数是
新的目标变更集。Xlink 的其余参数将不会
被修改。</p>
<p>分支自动扩展：</p>
<p>在任何可写 Xlink 链接的存储库（’-^w’ 选项）中进行更改时，
需要在目标存储库中创建一个新分支。新分支的
名称基于顶级存储库中定义的签出
分支。为了确定要使用的分支的名称，遵循以下规则：</p>
<ol class="arabic">
<li><p>系统会检查目标存储库中是否存在具有
相同全名的分支：</p>
<blockquote>
<div><ul>
<li><p>如果存在，则将此分支用作签出分支。</p></li>
<li><p>如果不存在，则通过以下方式构建分支名称：
- 通过 Xlink 链接的目标变更集的分支名称 + 签出分支</p>
<blockquote>
<div><p>的简短名称（最后一部分）。</p>
</div></blockquote>
<ul class="simple">
<li><p>如果存在此分支，则将此分支用作签出分支。</p></li>
<li><p>否则，将创建分支并将分支基项设置为
通过 Xlink 链接的变更集。</p></li>
</ul>
</li>
</ul>
</div></blockquote>
</li>
<li><dl class="simple">
<dt>在父存储库的分支中创建 Xlink 的新版本，</dt><dd><p>指向通过 Xlink 链接的存储库中的新变更集。</p>
</dd>
</dl>
</li>
</ol>
<p>最后，完整的 Xlink 结构会与正确版本中的
最新更改保持同步。</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^xlink codefirstrepo / 1&#64;first&#64;localhost:8084
（在当前工作区的文件夹 ‘firstrepo’ 中创建一个 Xlink，
在其中将装入存储库 ‘first’ 中的变更集 ‘1’。）</p>
<p>cm ^xlink openglinclude /includes/opengl 1627&#64;includes&#64;localhost:8087
（在当前工作区的目录 ‘openglinclude’ 中创建只读</p>
<blockquote>
<div><p>部分 Xlink，在其中，存储库 ‘includes’ 的变更集 ‘1627’ 中的路径
‘/includes/opengl’ 将作为根目录装入。这意味着 ‘/includes/opengl’
中的任何内容都将装入到 ‘openglinclude’ 中，</p>
</div></blockquote>
<p>而存储库的其余部分将被忽略。）</p>
<p>cm ^xlink -^w -^rs codesecondrepo / ^lb:LB001&#64;second&#64;localhost:8084
（在当前工作区的文件夹 ‘secondrepo’ 中创建一个</p>
<blockquote>
<div><p>可写的相对 Xlink，在其中将装入存储库 ‘second’ 中的</p>
</div></blockquote>
<p>标签 ‘LB001’。）</p>
<p>cm ^xlink codethirdrepo / 3&#64;third&#64;localhost:8087 ^br:/main-^br:/main/scm003
（在当前工作区的文件夹 ‘thirdrepo’ 中创建一个 Xlink，
在其中将装入存储库 ‘third’ 中的变更集 ‘3’。）</p>
<p>cm ^xlink -^e codesecondrepo ^br:/main/task1234&#64;second&#64;localhost:8084
（通过链接存储库 ‘second’ 中的分支 ‘main/task1234’，
编辑 Xlink ‘codesecondrepo’ 以更改目标存储库。）</p>
<p>cm ^xlink –^show codethirdrepo
（显示 Xlink ‘codethirdrepo’ 的信息，包括其扩展规则</p>
<blockquote>
<div><p>（如果存在））。</p>
</div></blockquote>
<p>cm ^xlink -^ar codesecondrepo ^br:/main-^br:/main/develop ^br:/main/fix-^br:/main/develop/fix
（将两个扩展规则添加到 Xlink ‘codesecondrepo’。）</p>
<p>cm ^xlink -^dr codesecondrepo ^br:/main/fix-^br:/main/develop/fix
（从 Xlink ‘codesecondrepo’ 中删除扩展规则）。</p>
</div></blockquote>
<p>== CMD_USAGE_AUTOCOMPLETE ==
用法：</p>
<blockquote>
<div><p>cm ^autocomplete ^install
（在 shell 中安装 ‘cm’ 命令补齐功能。）</p>
<p>cm ^autocomplete ^uninstall
（从 shell 中卸载 ‘cm’ 命令补齐功能。）</p>
<p>cm ^autocomplete –^line &lt;shell_行&gt; –^position &lt;光标位置&gt;
（返回自动补齐建议，以便将“shell_行”插入</p>
<blockquote>
<div><p>“光标位置”。此命令并非供最终用户使用，但这里记载
此命令是考虑到您可能需要扩展对所选 shell 的</p>
</div></blockquote>
<p>自动补齐支持。）</p>
<dl class="simple">
<dt>shell_行      当请求自动补齐时由用户</dt><dd><p>写入 shell 的行。
在 Bash 中，此值位于 COMP_LINE 环境变量中。
在 PowerShell 中，则位于 $wordToComplete 变量中。</p>
</dd>
<dt>光标位置 请求自动补齐时的</dt><dd><p>光标位置。
在 Bash 中，此值位于 COMP_POINT 环境变量中。
在 PowerShell 中，则位于 $cursorPosition 变量中。</p>
</dd>
</dl>
</div></blockquote>
<p>== CMD_DESCRIPTION_CONFIGURECLIENT ==
Configures the Plastic SCM client for the current machine user to work with a default server.</p>
<p>== CMD_USAGE_CONFIGURECLIENT ==
用法：</p>
<blockquote>
<div><dl class="simple">
<dt>cm ^configure [–^language=&lt;language&gt; –^workingmode=&lt;mode&gt; [AuthParameters]</dt><dd><p>–^server=&lt;server&gt; [–^port=&lt;port&gt;]] [–^clientconf=&lt;clientconfpath&gt;]</p>
</dd>
</dl>
<p class="attribution">—^language          可用语言：
en (English)
es (Spanish)</p>
</div></blockquote>
<blockquote>
<div><dl>
<dt>–^workingmode       可用的用户/安全工作模式：</dt><dd><p>NameWorkingMode (Name)
NameIDWorkingMode (Name + ID)
LDAPWorkingMode (LDAP)
ADWorkingMode (Active Directory)
UPWorkingMode (User and password)
SSOWorkingMode (Single Sign On)</p>
</dd>
<dt>AuthParameters      身份验证参数（仅适用于 ^LDAPWorkingMode 和 ^UPWorkingMode）：</dt><dd><p>–^user=&lt;user&gt;
–^password=&lt;password&gt;</p>
<p>Single Sign On parameters (only for ^SSOWorkingMode):
–^user=&lt;user&gt;
–^token=&lt;token&gt;</p>
</dd>
</dl>
<p class="attribution">—^server            Plastic SCM server IP / address</p>
</div></blockquote>
<blockquote>
<div><dl class="simple">
<dt>–^port              Plastic SCM server port</dt><dd><p>(port optional for Cloud servers)</p>
</dd>
</dl>
<p class="attribution">—^clientconf        用于创建配置文件的文件路径（可选）
参数可以是完整路径、文件名或目录。</p>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>示例：</p>
<p class="attribution">—^clientconf=c:/path/to/myclient.conf
（指定的路径将用于创建客户端配置文件）</p>
</div></blockquote>
<blockquote>
<div><p>–^clientconf=myclient.conf
（将使用默认配置目录中的文件 myclient.conf）</p>
<p class="attribution">—^clientconf=c:/exisitingDirectory
（将使用指定目录中的默认文件名 client.conf）</p>
</div></blockquote>
</div></blockquote>
<p>== CMD_HELP_CONFIGURECLIENT ==
备注：</p>
<blockquote>
<div><p>The cm ^configure command cannot be used on Cloud Edition or DVCS Edition of Plastic SCM.
Use ‘plastic –configure’ instead.</p>
</div></blockquote>
<p>示例：</p>
<blockquote>
<div><p>cm ^configure
(runs the interactive Plastic SCM client configuration command)</p>
<dl class="simple">
<dt>cm ^configure –^language=^en –^workingmode=^LDAPWorkingMode –^user=^jack –^password=^01234 </dt><dd><p>–^server=^plastic.mymachine.com –^port=^8084</p>
</dd>
</dl>
<p>(configures the Plastic SCM client with the specified parameters and creates the ‘client.conf’
configuration file in the default directory).
（Cloud 服务器的可选端口）</p>
<dl class="simple">
<dt>cm ^configure –^language=^en –^workingmode=^NameWorkingMode –^server=^plastic.mymachine.com </dt><dd><p>–^port=^8084 –^clientconf=^clientconf_exp.conf</p>
</dd>
</dl>
<p>(configures the Plastic SCM client with the specified parameters and creates the ‘client.conf’
configuration file in the specified path).
（Cloud 服务器的可选端口）</p>
</div></blockquote>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../../../../../../../_sources/Unity Files/DMXController/Library/PackageCache/com.unity.collab-proxy@1.17.7/Lib/Editor/PlasticSCM/localization/cm-help.zh-Hans.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../../../../../../../index.html">Board 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">&lt;no title&gt;</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, The FLS team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1.
    </div>
  </body>
</html>