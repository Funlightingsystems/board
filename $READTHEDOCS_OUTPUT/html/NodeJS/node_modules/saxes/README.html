<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>saxes &#8212; Board 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/classic.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Board 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">saxes</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="saxes">
<h1>saxes<a class="headerlink" href="#saxes" title="Permalink to this heading">¶</a></h1>
<p>A sax-style non-validating parser for XML.</p>
<p>Saxes is a fork of <a class="reference external" href="https://github.com/isaacs/sax-js">sax</a> 1.2.4. All mentions
of sax in this project’s documentation are references to sax 1.2.4.</p>
<p>Designed with <a class="reference external" href="http://nodejs.org/">node</a> in mind, but should work fine in the
browser or other CommonJS implementations.</p>
<p>Saxes does not support Node versions older than 10.</p>
<section id="notable-differences-from-sax">
<h2>Notable Differences from Sax.<a class="headerlink" href="#notable-differences-from-sax" title="Permalink to this heading">¶</a></h2>
<ul>
<li><p>Saxes aims to be much stricter than sax with regards to XML
well-formedness. Sax, even in its so-called “strict mode”, is not strict. It
silently accepts structures that are not well-formed XML. Projects that need
better compliance with well-formedness constraints cannot use sax as-is.</p>
<p>Consequently, saxes does not support HTML, or pseudo-XML, or bad XML. Saxes
will report well-formedness errors in all these cases but it won’t try to
extract data from malformed documents like sax does.</p>
</li>
<li><p>Saxes is much much faster than sax, mostly because of a substantial redesign
of the internal parsing logic. The speed improvement is not merely due to
removing features that were supported by sax. That helped a bit, but saxes
adds some expensive checks in its aim for conformance with the XML
specification. Redesigning the parsing logic is what accounts for most of the
performance improvement.</p></li>
<li><p>Saxes does not aim to support antiquated platforms. We will not pollute the
source or the default build with support for antiquated platforms. If you want
support for IE 11, you are welcome to produce a PR that adds a <em>new build</em>
transpiled to ES5.</p></li>
<li><p>Saxes handles errors differently from sax: it provides a default onerror
handler which throws. You can replace it with your own handler if you want. If
your handler does nothing, there is no <code class="docutils literal notranslate"><span class="pre">resume</span></code> method to call.</p></li>
<li><p>There’s no <code class="docutils literal notranslate"><span class="pre">Stream</span></code> API. A revamped API may be introduced later. (It is still
a “streaming parser” in the general sense that you write a character stream to
it.)</p></li>
<li><p>Saxes does not have facilities for limiting the size the data chunks passed to
event handlers. See the FAQ entry for more details.</p></li>
</ul>
</section>
<section id="conformance">
<h2>Conformance<a class="headerlink" href="#conformance" title="Permalink to this heading">¶</a></h2>
<p>Saxes supports:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.w3.org/TR/2008/REC-xml-20081126/">XML 1.0 fifth edition</a></p></li>
<li><p><a class="reference external" href="https://www.w3.org/TR/2006/REC-xml11-20060816/">XML 1.1 second edition</a></p></li>
<li><p><a class="reference external" href="https://www.w3.org/TR/2009/REC-xml-names-20091208/">Namespaces in XML 1.0 (Third Edition)</a>.</p></li>
<li><p><a class="reference external" href="https://www.w3.org/TR/2006/REC-xml-names11-20060816/">Namespaces in XML 1.1 (Second Edition)</a>.</p></li>
</ul>
</section>
<section id="limitations">
<h2>Limitations<a class="headerlink" href="#limitations" title="Permalink to this heading">¶</a></h2>
<p>This is a non-validating parser so it only verifies whether the document is
well-formed. We do aim to raise errors for all malformed constructs
encountered. However, this parser does not thorougly parse the contents of
DTDs. So most malformedness errors caused by errors <strong>in DTDs</strong> cannot be
reported.</p>
</section>
<section id="regarding-doctype-and-entity">
<h2>Regarding <code class="docutils literal notranslate"><span class="pre">&lt;!DOCTYPE</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;!ENTITY</span></code><a class="headerlink" href="#regarding-doctype-and-entity" title="Permalink to this heading">¶</a></h2>
<p>The parser will handle the basic XML entities in text nodes and attribute
values: <code class="docutils literal notranslate"><span class="pre">&amp;amp;</span> <span class="pre">&amp;lt;</span> <span class="pre">&amp;gt;</span> <span class="pre">&amp;apos;</span> <span class="pre">&amp;quot;</span></code>. It’s possible to define additional
entities in XML by putting them in the DTD. This parser doesn’t do anything with
that. If you want to listen to the <code class="docutils literal notranslate"><span class="pre">doctype</span></code> event, and then fetch the
doctypes, and read the entities and add them to <code class="docutils literal notranslate"><span class="pre">parser.ENTITIES</span></code>, then be my
guest.</p>
</section>
<section id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this heading">¶</a></h2>
<p>The source code contains JSDOC comments. Use them. What follows is a brief
summary of what is available. The final authority is the source code.</p>
<p><strong>PAY CLOSE ATTENTION TO WHAT IS PUBLIC AND WHAT IS PRIVATE.</strong></p>
<p>The move to TypeScript makes it so that everything is now formally private,
protected, or public.</p>
<p>If you use anything not public, that’s at your own peril.</p>
<p>If there’s a mistake in the documentation, raise an issue. If you just assume,
you may assume incorrectly.</p>
</section>
<section id="summary-usage-information">
<h2>Summary Usage Information<a class="headerlink" href="#summary-usage-information" title="Permalink to this heading">¶</a></h2>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this heading">¶</a></h3>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span><span class="w"> </span><span class="nx">saxes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;./lib/saxes&quot;</span><span class="p">),</span>
<span class="w">  </span><span class="nx">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">saxes</span><span class="p">.</span><span class="nx">SaxesParser</span><span class="p">();</span>

<span class="nx">parser</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// an error happened.</span>
<span class="p">});</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;text&quot;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// got some text.  t is the string of text.</span>
<span class="p">});</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;opentag&quot;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// opened a tag.  node has &quot;name&quot; and &quot;attributes&quot;</span>
<span class="p">});</span>
<span class="nx">parser</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;end&quot;</span><span class="p">,</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// parser stream is done, and ready to have more stuff written to it.</span>
<span class="p">});</span>

<span class="nx">parser</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s1">&#39;&lt;xml&gt;Hello, &lt;who name=&quot;world&quot;&gt;world&lt;/who&gt;!&lt;/xml&gt;&#39;</span><span class="p">).</span><span class="nx">close</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="constructor-arguments">
<h3>Constructor Arguments<a class="headerlink" href="#constructor-arguments" title="Permalink to this heading">¶</a></h3>
<p>Settings supported:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">xmlns</span></code> - Boolean. If <code class="docutils literal notranslate"><span class="pre">true</span></code>, then namespaces are supported. Default
is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">position</span></code> - Boolean. If <code class="docutils literal notranslate"><span class="pre">false</span></code>, then don’t track line/col/position. Unset is
treated as <code class="docutils literal notranslate"><span class="pre">true</span></code>. Default is unset. Currently, setting this to <code class="docutils literal notranslate"><span class="pre">false</span></code> only
results in a cosmetic change: the errors reported do not contain position
information. sax-js would literally turn off the position-computing logic if
this flag was set to false. The notion was that it would optimize
execution. In saxes at least it turns out that continually testing this flag
causes a cost that offsets the benefits of turning off this logic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fileName</span></code> - String. Set a file name for error reporting. This is useful only
when tracking positions. You may leave it unset.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fragment</span></code> - Boolean. If <code class="docutils literal notranslate"><span class="pre">true</span></code>, parse the XML as an XML fragment. Default is
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">additionalNamespaces</span></code> - A plain object whose key, value pairs define
namespaces known before parsing the XML file. It is not legal to pass
bindings for the namespaces <code class="docutils literal notranslate"><span class="pre">&quot;xml&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;xmlns&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">defaultXMLVersion</span></code> - The default version of the XML specification to use if
the document contains no XML declaration. If the document does contain an XML
declaration, then this setting is ignored. Must be <code class="docutils literal notranslate"><span class="pre">&quot;1.0&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;1.1&quot;</span></code>. The
default is <code class="docutils literal notranslate"><span class="pre">&quot;1.0&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">forceXMLVersion</span></code> - Boolean. A flag indicating whether to force the XML
version used for parsing to the value of <code class="docutils literal notranslate"><span class="pre">defaultXMLVersion</span></code>. When this flag
is <code class="docutils literal notranslate"><span class="pre">true</span></code>, <code class="docutils literal notranslate"><span class="pre">defaultXMLVersion</span></code> must be specified. If unspecified, the
default value of this flag is <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
<p>Example: suppose you are parsing a document that has an XML declaration
specifying XML version 1.1.</p>
<p>If you set <code class="docutils literal notranslate"><span class="pre">defaultXMLVersion</span></code> to <code class="docutils literal notranslate"><span class="pre">&quot;1.0&quot;</span></code> without setting
<code class="docutils literal notranslate"><span class="pre">forceXMLVersion</span></code> then the XML declaration will override the value of
<code class="docutils literal notranslate"><span class="pre">defaultXMLVersion</span></code> and the document will be parsed according to XML 1.1.</p>
<p>If you set <code class="docutils literal notranslate"><span class="pre">defaultXMLVersion</span></code> to <code class="docutils literal notranslate"><span class="pre">&quot;1.0&quot;</span></code> and set <code class="docutils literal notranslate"><span class="pre">forceXMLVersion</span></code> to
<code class="docutils literal notranslate"><span class="pre">true</span></code>, then the XML declaration will be ignored and the document will be
parsed according to XML 1.0.</p>
</li>
</ul>
</section>
<section id="methods">
<h3>Methods<a class="headerlink" href="#methods" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">write</span></code> - Write bytes onto the stream. You don’t have to pass the whole document
in one <code class="docutils literal notranslate"><span class="pre">write</span></code> call. You can read your source chunk by chunk and call <code class="docutils literal notranslate"><span class="pre">write</span></code>
with each chunk.</p>
<p><code class="docutils literal notranslate"><span class="pre">close</span></code> - Close the stream. Once closed, no more data may be written until it is
done processing the buffer, which is signaled by the <code class="docutils literal notranslate"><span class="pre">end</span></code> event.</p>
</section>
<section id="properties">
<h3>Properties<a class="headerlink" href="#properties" title="Permalink to this heading">¶</a></h3>
<p>The parser has the following properties:</p>
<p><code class="docutils literal notranslate"><span class="pre">line</span></code>, <code class="docutils literal notranslate"><span class="pre">column</span></code>, <code class="docutils literal notranslate"><span class="pre">columnIndex</span></code>, <code class="docutils literal notranslate"><span class="pre">position</span></code> - Indications of the position in the
XML document where the parser currently is looking. The <code class="docutils literal notranslate"><span class="pre">columnIndex</span></code> property
counts columns as if indexing into a JavaScript string, whereas the <code class="docutils literal notranslate"><span class="pre">column</span></code>
property counts Unicode characters.</p>
<p><code class="docutils literal notranslate"><span class="pre">closed</span></code> - Boolean indicating whether or not the parser can be written to.  If
it’s <code class="docutils literal notranslate"><span class="pre">true</span></code>, then wait for the <code class="docutils literal notranslate"><span class="pre">ready</span></code> event to write again.</p>
<p><code class="docutils literal notranslate"><span class="pre">opt</span></code> - Any options passed into the constructor.</p>
<p><code class="docutils literal notranslate"><span class="pre">xmlDecl</span></code> - The XML declaration for this document. It contains the fields
<code class="docutils literal notranslate"><span class="pre">version</span></code>, <code class="docutils literal notranslate"><span class="pre">encoding</span></code> and <code class="docutils literal notranslate"><span class="pre">standalone</span></code>. They are all <code class="docutils literal notranslate"><span class="pre">undefined</span></code> before
encountering the XML declaration. If they are undefined after the XML
declaration, the corresponding value was not set by the declaration. There is no
event associated with the XML declaration. In a well-formed document, the XML
declaration may be preceded only by an optional BOM. So by the time any event
generated by the parser happens, the declaration has been processed if present
at all. Otherwise, you have a malformed document, and as stated above, you
cannot rely on the parser data!</p>
</section>
<section id="error-handling">
<h3>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this heading">¶</a></h3>
<p>The parser continues to parse even upon encountering errors, and does its best
to continue reporting errors. You should heed all errors reported. After an
error, however, saxes may interpret your document incorrectly. For instance
<code class="docutils literal notranslate"><span class="pre">&lt;foo</span> <span class="pre">a=bc=&quot;d&quot;/&gt;</span></code> is invalid XML. Did you mean to have <code class="docutils literal notranslate"><span class="pre">&lt;foo</span> <span class="pre">a=&quot;bc=d&quot;/&gt;</span></code> or
<code class="docutils literal notranslate"><span class="pre">&lt;foo</span> <span class="pre">a=&quot;b&quot;</span> <span class="pre">c=&quot;d&quot;/&gt;</span></code> or some other variation?  For the sake of continuing to
provide errors, saxes will continue parsing the document, but the structure it
reports may be incorrect. It is only after the errors are fixed in the document
that saxes can provide a reliable interpretation of the document.</p>
<p>That leaves you with two rules of thumb when using saxes:</p>
<ul class="simple">
<li><p>Pay attention to the errors that saxes report. The default <code class="docutils literal notranslate"><span class="pre">onerror</span></code> handler
throws, so by default, you cannot miss errors.</p></li>
<li><p><strong>ONCE AN ERROR HAS BEEN ENCOUNTERED, STOP RELYING ON THE EVENT HANDLERS OTHER
THAN <code class="docutils literal notranslate"><span class="pre">onerror</span></code>.</strong> As explained above, when saxes runs into a well-formedness
problem, it makes a guess in order to continue reporting more errors. The guess
may be wrong.</p></li>
</ul>
</section>
<section id="events">
<h3>Events<a class="headerlink" href="#events" title="Permalink to this heading">¶</a></h3>
<p>To listen to an event, override <code class="docutils literal notranslate"><span class="pre">on&lt;eventname&gt;</span></code>. The list of supported events
are also in the exported <code class="docutils literal notranslate"><span class="pre">EVENTS</span></code> array.</p>
<p>See the JSDOC comments in the source code for a description of each supported
event.</p>
</section>
<section id="parsing-xml-fragments">
<h3>Parsing XML Fragments<a class="headerlink" href="#parsing-xml-fragments" title="Permalink to this heading">¶</a></h3>
<p>The XML specification does not define any method by which to parse XML
fragments. However, there are usage scenarios in which it is desirable to parse
fragments. In order to allow this, saxes provides three initialization options.</p>
<p>If you pass the option <code class="docutils literal notranslate"><span class="pre">fragment:</span> <span class="pre">true</span></code> to the parser constructor, the parser
will expect an XML fragment. It essentially starts with a parsing state
equivalent to the one it would be in if <code class="docutils literal notranslate"><span class="pre">parser.write(&quot;&lt;foo&quot;&gt;)</span></code> had been called
right after initialization. In other words, it expects content which is
acceptable inside an element. This also turns off well-formedness checks that
are inappropriate when parsing a fragment.</p>
<p>The option <code class="docutils literal notranslate"><span class="pre">additionalNamespaces</span></code> allows you to define additional prefix-to-URI
bindings known before parsing starts. You would use this over <code class="docutils literal notranslate"><span class="pre">resolvePrefix</span></code> if
you have at the ready a series of namespaces bindings to use.</p>
<p>The option <code class="docutils literal notranslate"><span class="pre">resolvePrefix</span></code> allows you to pass a function which saxes will use if
it is unable to resolve a namespace prefix by itself. You would use this over
<code class="docutils literal notranslate"><span class="pre">additionalNamespaces</span></code> in a context where getting a complete list of defined
namespaces is onerous.</p>
<p>Note that you can use <code class="docutils literal notranslate"><span class="pre">additionalNamespaces</span></code> and <code class="docutils literal notranslate"><span class="pre">resolvePrefix</span></code> together if you
want. <code class="docutils literal notranslate"><span class="pre">additionalNamespaces</span></code> applies before <code class="docutils literal notranslate"><span class="pre">resolvePrefix</span></code>.</p>
<p>The options <code class="docutils literal notranslate"><span class="pre">additionalNamespaces</span></code> and <code class="docutils literal notranslate"><span class="pre">resolvePrefix</span></code> are really meant to be
used for parsing fragments. However, saxes won’t prevent you from using them
with <code class="docutils literal notranslate"><span class="pre">fragment:</span> <span class="pre">false</span></code>. Note that if you do this, your document may parse
without errors and yet be malformed because the document can refer to namespaces
which are not defined <em>in</em> the document.</p>
<p>Of course, <code class="docutils literal notranslate"><span class="pre">additionalNamespaces</span></code> and <code class="docutils literal notranslate"><span class="pre">resolvePrefix</span></code> are used only if <code class="docutils literal notranslate"><span class="pre">xmlns</span></code>
is <code class="docutils literal notranslate"><span class="pre">true</span></code>. If you are parsing a fragment that does not use namespaces, there’s
no point in setting these options.</p>
</section>
<section id="performance-tips">
<h3>Performance Tips<a class="headerlink" href="#performance-tips" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>saxes works faster on files that use newlines (<code class="docutils literal notranslate"><span class="pre">\u000A</span></code>) as end of line
markers than files that use other end of line markers (like <code class="docutils literal notranslate"><span class="pre">\r</span></code> or
<code class="docutils literal notranslate"><span class="pre">\r\n</span></code>). The XML specification requires that conformant applications behave
as if all characters that are to be treated as end of line characters are
converted to <code class="docutils literal notranslate"><span class="pre">\u000A</span></code> prior to parsing. The optimal code path for saxes is a
file in which all end of line characters are already <code class="docutils literal notranslate"><span class="pre">\u000A</span></code>.</p></li>
<li><p>Don’t split Unicode strings you feed to saxes across surrogates. When you
naively split a string in JavaScript, you run the risk of splitting a Unicode
character into two surrogates. e.g.  In the following example <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>
each contain half of a single Unicode character: <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">&quot;\u{1F4A9}&quot;[0];</span> <span class="pre">const</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">&quot;\u{1F4A9}&quot;[1]</span></code> If you feed such split surrogates to versions of
saxes prior to 4, you’d get errors. Saxes version 4 and over are able to
detect when a chunk of data ends with a surrogate and carry over the surrogate
to the next chunk. However this operation entails slicing and concatenating
strings. If you can feed your data in a way that does not split surrogates,
you should do it. (Obviously, feeding all the data at once with a single write
is fastest.)</p></li>
<li><p>Don’t set event handlers you don’t need. Saxes has always aimed to avoid doing
work that will just be tossed away but future improvements hope to do this
more aggressively. One way saxes knows whether or not some data is needed is
by checking whether a handler has been set for a specific event.</p></li>
</ul>
</section>
</section>
<section id="faq">
<h2>FAQ<a class="headerlink" href="#faq" title="Permalink to this heading">¶</a></h2>
<p>Q. Why has saxes dropped support for limiting the size of data chunks passed to
event handlers?</p>
<p>A. With sax you could set <code class="docutils literal notranslate"><span class="pre">MAX_BUFFER_LENGTH</span></code> to cause the parser to limit the
size of data chunks passed to event handlers. So if you ran into a span of text
above the limit, multiple <code class="docutils literal notranslate"><span class="pre">text</span></code> events with smaller data chunks were fired
instead of a single event with a large chunk.</p>
<p>However, that functionality had some problematic characteristics. It had an
arbitrary default value. It was library-wide so all parsers created from a
single instance of the <code class="docutils literal notranslate"><span class="pre">sax</span></code> library shared it. This could potentially cause
conflicts among libraries running in the same VM but using sax for different
purposes.</p>
<p>These issues could have been easily fixed, but there were larger issues. The
buffer limit arbitrarily applied to some events but not others. It would split
<code class="docutils literal notranslate"><span class="pre">text</span></code>, <code class="docutils literal notranslate"><span class="pre">cdata</span></code> and <code class="docutils literal notranslate"><span class="pre">script</span></code> events. However, if a <code class="docutils literal notranslate"><span class="pre">comment</span></code>,
<code class="docutils literal notranslate"><span class="pre">doctype</span></code>, <code class="docutils literal notranslate"><span class="pre">attribute</span></code> or <code class="docutils literal notranslate"><span class="pre">processing</span> <span class="pre">instruction</span></code> were more than the
limit, the parser would generate an error and you were left picking up the
pieces.</p>
<p>It was not intuitive to use. You’d think setting the limit to 1K would prevent
chunks bigger than 1K to be passed to event handlers. But that was not the
case. A comment in the source code told you that you might go over the limit if
you passed large chunks to <code class="docutils literal notranslate"><span class="pre">write</span></code>. So if you want a 1K limit, don’t pass 64K
chunks to <code class="docutils literal notranslate"><span class="pre">write</span></code>. Fair enough. You know what limit you want so you can
control the size of the data you pass to <code class="docutils literal notranslate"><span class="pre">write</span></code>. So you limit the chunks to
<code class="docutils literal notranslate"><span class="pre">write</span></code> to 1K at a time. Even if you do this, your event handlers may get data
chunks that are 2K in size. Suppose on the previous <code class="docutils literal notranslate"><span class="pre">write</span></code> the parser has
just finished processing an open tag, so it is ready for text. Your <code class="docutils literal notranslate"><span class="pre">write</span></code>
passes 1K of text. You are not above the limit yet, so no event is generated
yet. The next <code class="docutils literal notranslate"><span class="pre">write</span></code> passes another 1K of text. It so happens that sax checks
buffer limits only once per <code class="docutils literal notranslate"><span class="pre">write</span></code>, after the chunk of data has been
processed. Now you’ve hit the limit and you get a <code class="docutils literal notranslate"><span class="pre">text</span></code> event with 2K of
data. So even if you limit your <code class="docutils literal notranslate"><span class="pre">write</span></code> calls to the buffer limit you’ve set,
you may still get events with chunks at twice the buffer size limit you’ve
specified.</p>
<p>We may consider reinstating an equivalent functionality, provided that it
addresses the issues above and does not cause a huge performance drop for
use-case scenarios that don’t need it.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">saxes</a><ul>
<li><a class="reference internal" href="#notable-differences-from-sax">Notable Differences from Sax.</a></li>
<li><a class="reference internal" href="#conformance">Conformance</a></li>
<li><a class="reference internal" href="#limitations">Limitations</a></li>
<li><a class="reference internal" href="#regarding-doctype-and-entity">Regarding <code class="docutils literal notranslate"><span class="pre">&lt;!DOCTYPE</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;!ENTITY</span></code></a></li>
<li><a class="reference internal" href="#documentation">Documentation</a></li>
<li><a class="reference internal" href="#summary-usage-information">Summary Usage Information</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#constructor-arguments">Constructor Arguments</a></li>
<li><a class="reference internal" href="#methods">Methods</a></li>
<li><a class="reference internal" href="#properties">Properties</a></li>
<li><a class="reference internal" href="#error-handling">Error Handling</a></li>
<li><a class="reference internal" href="#events">Events</a></li>
<li><a class="reference internal" href="#parsing-xml-fragments">Parsing XML Fragments</a></li>
<li><a class="reference internal" href="#performance-tips">Performance Tips</a></li>
</ul>
</li>
<li><a class="reference internal" href="#faq">FAQ</a></li>
</ul>
</li>
</ul>

  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../../_sources/NodeJS/node_modules/saxes/README.md.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Board 1.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">saxes</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, The FLS team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1.
    </div>
  </body>
</html>